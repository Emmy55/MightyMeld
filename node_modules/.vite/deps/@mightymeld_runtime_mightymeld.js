import {
  require_jsx_runtime
} from "./chunk-BX4QH3UP.js";
import "./chunk-YZZKIYU7.js";
import {
  __toESM
} from "./chunk-LQ2VYIYD.js";

// node_modules/@mightymeld/runtime/mightymeld/mjs/index.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
var Ty = Object.create;
var Rn = Object.defineProperty;
var Sy = Object.defineProperties;
var by = Object.getOwnPropertyDescriptor;
var Ey = Object.getOwnPropertyDescriptors;
var vy = Object.getOwnPropertyNames;
var zs = Object.getOwnPropertySymbols;
var Py = Object.getPrototypeOf;
var Qs = Object.prototype.hasOwnProperty;
var xy = Object.prototype.propertyIsEnumerable;
var Hs = (e, t, r) => t in e ? Rn(e, t, { enumerable: true, configurable: true, writable: true, value: r }) : e[t] = r;
var St = (e, t) => {
  for (var r in t || (t = {}))
    Qs.call(t, r) && Hs(e, r, t[r]);
  if (zs)
    for (var r of zs(t))
      xy.call(t, r) && Hs(e, r, t[r]);
  return e;
};
var bt = (e, t) => Sy(e, Ey(t));
var gy = (e, t) => () => (e && (t = e(e = 0)), t);
var x = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports);
var hy = (e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let i of vy(t))
      !Qs.call(e, i) && i !== r && Rn(e, i, { get: () => t[i], enumerable: !(n = by(t, i)) || n.enumerable });
  return e;
};
var Le = (e, t, r) => (r = e != null ? Ty(Py(e)) : {}, hy(t || !e || !e.__esModule ? Rn(r, "default", { value: e, enumerable: true }) : r, e));
var Mn = (e, t, r) => new Promise((n, i) => {
  var l = (P) => {
    try {
      S(r.next(P));
    } catch (A) {
      i(A);
    }
  }, y = (P) => {
    try {
      S(r.throw(P));
    } catch (A) {
      i(A);
    }
  }, S = (P) => P.done ? n(P.value) : Promise.resolve(P.value).then(l, y);
  S((r = r.apply(e, t)).next());
});
var E;
var o = gy(() => {
  E = {};
});
var eo = x((gF, Bn) => {
  "use strict";
  o();
  var Oy = Object.prototype.hasOwnProperty, Pe = "~";
  function kt() {
  }
  Object.create && (kt.prototype = /* @__PURE__ */ Object.create(null), new kt().__proto__ || (Pe = false));
  function Iy(e, t, r) {
    this.fn = e, this.context = t, this.once = r || false;
  }
  function Zs(e, t, r, n, i) {
    if (typeof r != "function")
      throw new TypeError("The listener must be a function");
    var l = new Iy(r, n || e, i), y = Pe ? Pe + t : t;
    return e._events[y] ? e._events[y].fn ? e._events[y] = [e._events[y], l] : e._events[y].push(l) : (e._events[y] = l, e._eventsCount++), e;
  }
  function Ir(e, t) {
    --e._eventsCount === 0 ? e._events = new kt() : delete e._events[t];
  }
  function Se() {
    this._events = new kt(), this._eventsCount = 0;
  }
  Se.prototype.eventNames = function() {
    var t = [], r, n;
    if (this._eventsCount === 0)
      return t;
    for (n in r = this._events)
      Oy.call(r, n) && t.push(Pe ? n.slice(1) : n);
    return Object.getOwnPropertySymbols ? t.concat(Object.getOwnPropertySymbols(r)) : t;
  };
  Se.prototype.listeners = function(t) {
    var r = Pe ? Pe + t : t, n = this._events[r];
    if (!n)
      return [];
    if (n.fn)
      return [n.fn];
    for (var i = 0, l = n.length, y = new Array(l); i < l; i++)
      y[i] = n[i].fn;
    return y;
  };
  Se.prototype.listenerCount = function(t) {
    var r = Pe ? Pe + t : t, n = this._events[r];
    return n ? n.fn ? 1 : n.length : 0;
  };
  Se.prototype.emit = function(t, r, n, i, l, y) {
    var S = Pe ? Pe + t : t;
    if (!this._events[S])
      return false;
    var P = this._events[S], A = arguments.length, L, D;
    if (P.fn) {
      switch (P.once && this.removeListener(t, P.fn, void 0, true), A) {
        case 1:
          return P.fn.call(P.context), true;
        case 2:
          return P.fn.call(P.context, r), true;
        case 3:
          return P.fn.call(P.context, r, n), true;
        case 4:
          return P.fn.call(P.context, r, n, i), true;
        case 5:
          return P.fn.call(P.context, r, n, i, l), true;
        case 6:
          return P.fn.call(P.context, r, n, i, l, y), true;
      }
      for (D = 1, L = new Array(A - 1); D < A; D++)
        L[D - 1] = arguments[D];
      P.fn.apply(P.context, L);
    } else {
      var te = P.length, X;
      for (D = 0; D < te; D++)
        switch (P[D].once && this.removeListener(t, P[D].fn, void 0, true), A) {
          case 1:
            P[D].fn.call(P[D].context);
            break;
          case 2:
            P[D].fn.call(P[D].context, r);
            break;
          case 3:
            P[D].fn.call(P[D].context, r, n);
            break;
          case 4:
            P[D].fn.call(P[D].context, r, n, i);
            break;
          default:
            if (!L)
              for (X = 1, L = new Array(A - 1); X < A; X++)
                L[X - 1] = arguments[X];
            P[D].fn.apply(P[D].context, L);
        }
    }
    return true;
  };
  Se.prototype.on = function(t, r, n) {
    return Zs(this, t, r, n, false);
  };
  Se.prototype.once = function(t, r, n) {
    return Zs(this, t, r, n, true);
  };
  Se.prototype.removeListener = function(t, r, n, i) {
    var l = Pe ? Pe + t : t;
    if (!this._events[l])
      return this;
    if (!r)
      return Ir(this, l), this;
    var y = this._events[l];
    if (y.fn)
      y.fn === r && (!i || y.once) && (!n || y.context === n) && Ir(this, l);
    else {
      for (var S = 0, P = [], A = y.length; S < A; S++)
        (y[S].fn !== r || i && !y[S].once || n && y[S].context !== n) && P.push(y[S]);
      P.length ? this._events[l] = P.length === 1 ? P[0] : P : Ir(this, l);
    }
    return this;
  };
  Se.prototype.removeAllListeners = function(t) {
    var r;
    return t ? (r = Pe ? Pe + t : t, this._events[r] && Ir(this, r)) : (this._events = new kt(), this._eventsCount = 0), this;
  };
  Se.prototype.off = Se.prototype.removeListener;
  Se.prototype.addListener = Se.prototype.on;
  Se.prefixed = Pe;
  Se.EventEmitter = Se;
  typeof Bn != "undefined" && (Bn.exports = Se);
});
var to = x((Kt) => {
  "use strict";
  o();
  var _y = Kt && Kt.__extends || function() {
    var e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, r) {
      t.__proto__ = r;
    } || function(t, r) {
      for (var n in r)
        r.hasOwnProperty(n) && (t[n] = r[n]);
    };
    return function(t, r) {
      e(t, r);
      function n() {
        this.constructor = t;
      }
      t.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
    };
  }();
  Object.defineProperty(Kt, "__esModule", { value: true });
  var Dy = function(e) {
    _y(t, e);
    function t(r, n, i) {
      var l = e.call(this, "Error #" + r + ": " + n) || this;
      return l.code = r, l.message = n, l.path = i, Object.setPrototypeOf(l, t.prototype), l;
    }
    return t.prototype.toReplyError = function() {
      return { code: this.code, message: this.message, path: this.path };
    }, t;
  }(Error);
  Kt.RPCError = Dy;
});
var ro = x((Fn) => {
  "use strict";
  o();
  Object.defineProperty(Fn, "__esModule", { value: true });
  var Ny = function() {
    function e() {
      this.lastSequentialCall = -1, this.queue = [];
    }
    return e.prototype.reset = function(t) {
      this.lastSequentialCall = t - 1, this.queue = [];
    }, e.prototype.append = function(t) {
      if (t.counter <= this.lastSequentialCall + 1) {
        var r = [t];
        return this.lastSequentialCall = t.counter, this.replayQueue(r), r;
      }
      for (var n = 0; n < this.queue.length; n++)
        if (this.queue[n].counter > t.counter)
          return this.queue.splice(n, 0, t), [];
      return this.queue.push(t), [];
    }, e.prototype.replayQueue = function(t) {
      for (; this.queue.length; ) {
        var r = this.queue[0];
        if (r.counter > this.lastSequentialCall + 1)
          return;
        t.push(this.queue.shift()), this.lastSequentialCall = r.counter;
      }
    }, e;
  }();
  Fn.Reorder = Ny;
});
var no = x((_r) => {
  "use strict";
  o();
  Object.defineProperty(_r, "__esModule", { value: true });
  function Cy(e) {
    return (e.type === "method" || e.type === "reply") && typeof e.counter == "number";
  }
  _r.isRPCMessage = Cy;
  _r.defaultRecievable = { readMessages: function(e) {
    return window.addEventListener("message", e), function() {
      return window.removeEventListener("message", e);
    };
  } };
});
var oo = x((qt) => {
  "use strict";
  o();
  var wy = qt && qt.__extends || function() {
    var e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, r) {
      t.__proto__ = r;
    } || function(t, r) {
      for (var n in r)
        r.hasOwnProperty(n) && (t[n] = r[n]);
    };
    return function(t, r) {
      e(t, r);
      function n() {
        this.constructor = t;
      }
      t.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
    };
  }();
  Object.defineProperty(qt, "__esModule", { value: true });
  var Ly = eo(), so = to(), jy = ro(), ao = no();
  function Ry(e) {
    return new so.RPCError(e.code, e.message, e.path);
  }
  var io = -1, My = function(e) {
    wy(t, e);
    function t(r) {
      var n = e.call(this) || this;
      return n.options = r, n.calls = /* @__PURE__ */ Object.create(null), n.callCounter = 0, n.reorder = new jy.Reorder(), n.listener = function(i) {
        if (!(n.options.origin && n.options.origin !== "*" && i.origin !== n.options.origin)) {
          var l;
          try {
            l = JSON.parse(i.data);
          } catch (L) {
            return;
          }
          if (!(!ao.isRPCMessage(l) || l.serviceID !== n.options.serviceId)) {
            if (n.isReadySignal(l)) {
              var y = l.type === "method" ? l.params : l.result;
              y && y.protocolVersion ? n.remoteProtocolVersion = y.protocolVersion : n.remoteProtocolVersion = n.remoteProtocolVersion, n.callCounter = 0, n.reorder.reset(l.counter), n.emit("isReady", true);
            }
            for (var S = 0, P = n.reorder.append(l); S < P.length; S++) {
              var A = P[S];
              n.emit("recvData", A), n.dispatchIncoming(A);
            }
          }
        }
      }, n.unsubscribeCallback = (r.receiver || ao.defaultRecievable).readMessages(n.listener), n.isReady = new Promise(function(i) {
        var l = { protocolVersion: r.protocolVersion || "1.0" };
        n.expose("ready", function() {
          return i(), l;
        }), n.call("ready", l).then(i).catch(i);
      }), n;
    }
    return t.prototype.create = function(r) {
      var n = new t(r);
      return n.isReady.then(function() {
        return n;
      });
    }, t.prototype.expose = function(r, n) {
      var i = this;
      return this.on(r, function(l) {
        if (l.discard) {
          n(l.params);
          return;
        }
        new Promise(function(y) {
          return y(n(l.params));
        }).then(function(y) {
          return { type: "reply", serviceID: i.options.serviceId, id: l.id, result: y };
        }).catch(function(y) {
          return { type: "reply", serviceID: i.options.serviceId, id: l.id, error: y instanceof so.RPCError ? y.toReplyError() : { code: 0, message: y.stack || y.message } };
        }).then(function(y) {
          i.emit("sendReply", y), i.post(y);
        });
      }), this;
    }, t.prototype.call = function(r, n, i) {
      var l = this;
      i === void 0 && (i = true);
      var y = r === "ready" ? io : this.callCounter, S = { type: "method", serviceID: this.options.serviceId, id: y, params: n, method: r, discard: !i };
      if (this.emit("sendMethod", S), this.post(S), !!i)
        return new Promise(function(P, A) {
          l.calls[y] = function(L, D) {
            L ? A(L) : P(D);
          };
        });
    }, t.prototype.destroy = function() {
      this.emit("destroy"), this.unsubscribeCallback();
    }, t.prototype.remoteVersion = function() {
      return this.remoteProtocolVersion;
    }, t.prototype.handleReply = function(r) {
      var n = this.calls[r.id];
      !n || (r.error ? n(Ry(r.error), null) : n(null, r.result), delete this.calls[r.id]);
    }, t.prototype.post = function(r) {
      r.counter = this.callCounter++, this.options.target.postMessage(JSON.stringify(r), this.options.origin || "*");
    }, t.prototype.isReadySignal = function(r) {
      return r.type === "method" && r.method === "ready" || r.type === "reply" && r.id === io;
    }, t.prototype.dispatchIncoming = function(r) {
      switch (r.type) {
        case "method":
          if (this.emit("recvMethod", r), this.listeners(r.method).length > 0) {
            this.emit(r.method, r);
            return;
          }
          this.post({ type: "reply", serviceID: this.options.serviceId, id: r.id, error: { code: 4003, message: 'Unknown method name "' + r.method + '"' }, result: null });
          break;
        case "reply":
          this.emit("recvReply", r), this.handleReply(r);
          break;
        default:
      }
    }, t;
  }(Ly.EventEmitter);
  qt.RPC = My;
});
var Yt = x((_F, uo) => {
  o();
  function By(e) {
    var t = typeof e;
    return e != null && (t == "object" || t == "function");
  }
  uo.exports = By;
});
var co = x((DF, lo) => {
  o();
  var Fy = typeof global == "object" && global && global.Object === Object && global;
  lo.exports = Fy;
});
var Vt = x((NF, fo) => {
  o();
  var ky = co(), Ky = typeof self == "object" && self && self.Object === Object && self, qy = ky || Ky || Function("return this")();
  fo.exports = qy;
});
var yo = x((CF, po) => {
  o();
  var Yy = Vt(), Vy = function() {
    return Yy.Date.now();
  };
  po.exports = Vy;
});
var To = x((wF, mo) => {
  o();
  var Uy = /\s/;
  function Jy(e) {
    for (var t = e.length; t-- && Uy.test(e.charAt(t)); )
      ;
    return t;
  }
  mo.exports = Jy;
});
var bo = x((LF, So) => {
  o();
  var Xy = To(), Wy = /^\s+/;
  function $y(e) {
    return e && e.slice(0, Xy(e) + 1).replace(Wy, "");
  }
  So.exports = $y;
});
var Dr = x((jF, Eo) => {
  o();
  var Gy = Vt(), zy = Gy.Symbol;
  Eo.exports = zy;
});
var go = x((RF, xo) => {
  o();
  var vo = Dr(), Po = Object.prototype, Hy = Po.hasOwnProperty, Qy = Po.toString, Ut = vo ? vo.toStringTag : void 0;
  function Zy(e) {
    var t = Hy.call(e, Ut), r = e[Ut];
    try {
      e[Ut] = void 0;
      var n = true;
    } catch (l) {
    }
    var i = Qy.call(e);
    return n && (t ? e[Ut] = r : delete e[Ut]), i;
  }
  xo.exports = Zy;
});
var Ao = x((MF, ho) => {
  o();
  var em = Object.prototype, tm = em.toString;
  function rm(e) {
    return tm.call(e);
  }
  ho.exports = rm;
});
var kn = x((BF, _o) => {
  o();
  var Oo = Dr(), nm = go(), am = Ao(), im = "[object Null]", sm = "[object Undefined]", Io = Oo ? Oo.toStringTag : void 0;
  function om(e) {
    return e == null ? e === void 0 ? sm : im : Io && Io in Object(e) ? nm(e) : am(e);
  }
  _o.exports = om;
});
var No = x((FF, Do) => {
  o();
  function um(e) {
    return e != null && typeof e == "object";
  }
  Do.exports = um;
});
var Kn = x((kF, Co) => {
  o();
  var lm = kn(), cm = No(), fm = "[object Symbol]";
  function pm(e) {
    return typeof e == "symbol" || cm(e) && lm(e) == fm;
  }
  Co.exports = pm;
});
var Ro = x((KF, jo) => {
  o();
  var dm = bo(), wo = Yt(), ym = Kn(), Lo = 0 / 0, mm = /^[-+]0x[0-9a-f]+$/i, Tm = /^0b[01]+$/i, Sm = /^0o[0-7]+$/i, bm = parseInt;
  function Em(e) {
    if (typeof e == "number")
      return e;
    if (ym(e))
      return Lo;
    if (wo(e)) {
      var t = typeof e.valueOf == "function" ? e.valueOf() : e;
      e = wo(t) ? t + "" : t;
    }
    if (typeof e != "string")
      return e === 0 ? e : +e;
    e = dm(e);
    var r = Tm.test(e);
    return r || Sm.test(e) ? bm(e.slice(2), r ? 2 : 8) : mm.test(e) ? Lo : +e;
  }
  jo.exports = Em;
});
var Fo = x((qF, Bo) => {
  o();
  var vm = Yt(), qn = yo(), Mo = Ro(), Pm = "Expected a function", xm = Math.max, gm = Math.min;
  function hm(e, t, r) {
    var n, i, l, y, S, P, A = 0, L = false, D = false, te = true;
    if (typeof e != "function")
      throw new TypeError(Pm);
    t = Mo(t) || 0, vm(r) && (L = !!r.leading, D = "maxWait" in r, l = D ? xm(Mo(r.maxWait) || 0, t) : l, te = "trailing" in r ? !!r.trailing : te);
    function X(V) {
      var se = n, _e = i;
      return n = i = void 0, A = V, y = e.apply(_e, se), y;
    }
    function ie(V) {
      return A = V, S = setTimeout(W, t), L ? X(V) : y;
    }
    function Re(V) {
      var se = V - P, _e = V - A, We = t - se;
      return D ? gm(We, l - _e) : We;
    }
    function fe(V) {
      var se = V - P, _e = V - A;
      return P === void 0 || se >= t || se < 0 || D && _e >= l;
    }
    function W() {
      var V = qn();
      if (fe(V))
        return $(V);
      S = setTimeout(W, Re(V));
    }
    function $(V) {
      return S = void 0, te && n ? X(V) : (n = i = void 0, y);
    }
    function J() {
      S !== void 0 && clearTimeout(S), A = 0, n = P = i = S = void 0;
    }
    function j() {
      return S === void 0 ? y : $(qn());
    }
    function F() {
      var V = qn(), se = fe(V);
      if (n = arguments, i = this, P = V, se) {
        if (S === void 0)
          return ie(P);
        if (D)
          return clearTimeout(S), S = setTimeout(W, t), X(P);
      }
      return S === void 0 && (S = setTimeout(W, t)), y;
    }
    return F.cancel = J, F.flush = j, F;
  }
  Bo.exports = hm;
});
var Ko = x((YF, ko) => {
  o();
  function Am(e) {
    for (var t = -1, r = e == null ? 0 : e.length, n = 0, i = []; ++t < r; ) {
      var l = e[t];
      l && (i[n++] = l);
    }
    return i;
  }
  ko.exports = Am;
});
var Yo = x((VF, qo) => {
  o();
  var Om = kn(), Im = Yt(), _m = "[object AsyncFunction]", Dm = "[object Function]", Nm = "[object GeneratorFunction]", Cm = "[object Proxy]";
  function wm(e) {
    if (!Im(e))
      return false;
    var t = Om(e);
    return t == Dm || t == Nm || t == _m || t == Cm;
  }
  qo.exports = wm;
});
var Uo = x((UF, Vo) => {
  o();
  var Lm = Vt(), jm = Lm["__core-js_shared__"];
  Vo.exports = jm;
});
var Wo = x((JF, Xo) => {
  o();
  var Yn = Uo(), Jo = function() {
    var e = /[^.]+$/.exec(Yn && Yn.keys && Yn.keys.IE_PROTO || "");
    return e ? "Symbol(src)_1." + e : "";
  }();
  function Rm(e) {
    return !!Jo && Jo in e;
  }
  Xo.exports = Rm;
});
var Go = x((XF, $o) => {
  o();
  var Mm = Function.prototype, Bm = Mm.toString;
  function Fm(e) {
    if (e != null) {
      try {
        return Bm.call(e);
      } catch (t) {
      }
      try {
        return e + "";
      } catch (t) {
      }
    }
    return "";
  }
  $o.exports = Fm;
});
var Ho = x((WF, zo) => {
  o();
  var km = Yo(), Km = Wo(), qm = Yt(), Ym = Go(), Vm = /[\\^$.*+?()[\]{}|]/g, Um = /^\[object .+?Constructor\]$/, Jm = Function.prototype, Xm = Object.prototype, Wm = Jm.toString, $m = Xm.hasOwnProperty, Gm = RegExp("^" + Wm.call($m).replace(Vm, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
  function zm(e) {
    if (!qm(e) || Km(e))
      return false;
    var t = km(e) ? Gm : Um;
    return t.test(Ym(e));
  }
  zo.exports = zm;
});
var Zo = x(($F, Qo) => {
  o();
  function Hm(e, t) {
    return e == null ? void 0 : e[t];
  }
  Qo.exports = Hm;
});
var Vn = x((GF, eu) => {
  o();
  var Qm = Ho(), Zm = Zo();
  function eT(e, t) {
    var r = Zm(e, t);
    return Qm(r) ? r : void 0;
  }
  eu.exports = eT;
});
var Jt = x((zF, tu) => {
  o();
  var tT = Vn(), rT = tT(Object, "create");
  tu.exports = rT;
});
var au = x((HF, nu) => {
  o();
  var ru = Jt();
  function nT() {
    this.__data__ = ru ? ru(null) : {}, this.size = 0;
  }
  nu.exports = nT;
});
var su = x((QF, iu) => {
  o();
  function aT(e) {
    var t = this.has(e) && delete this.__data__[e];
    return this.size -= t ? 1 : 0, t;
  }
  iu.exports = aT;
});
var uu = x((ZF, ou) => {
  o();
  var iT = Jt(), sT = "__lodash_hash_undefined__", oT = Object.prototype, uT = oT.hasOwnProperty;
  function lT(e) {
    var t = this.__data__;
    if (iT) {
      var r = t[e];
      return r === sT ? void 0 : r;
    }
    return uT.call(t, e) ? t[e] : void 0;
  }
  ou.exports = lT;
});
var cu = x((e2, lu) => {
  o();
  var cT = Jt(), fT = Object.prototype, pT = fT.hasOwnProperty;
  function dT(e) {
    var t = this.__data__;
    return cT ? t[e] !== void 0 : pT.call(t, e);
  }
  lu.exports = dT;
});
var pu = x((t2, fu) => {
  o();
  var yT = Jt(), mT = "__lodash_hash_undefined__";
  function TT(e, t) {
    var r = this.__data__;
    return this.size += this.has(e) ? 0 : 1, r[e] = yT && t === void 0 ? mT : t, this;
  }
  fu.exports = TT;
});
var yu = x((r2, du) => {
  o();
  var ST = au(), bT = su(), ET = uu(), vT = cu(), PT = pu();
  function Et(e) {
    var t = -1, r = e == null ? 0 : e.length;
    for (this.clear(); ++t < r; ) {
      var n = e[t];
      this.set(n[0], n[1]);
    }
  }
  Et.prototype.clear = ST;
  Et.prototype.delete = bT;
  Et.prototype.get = ET;
  Et.prototype.has = vT;
  Et.prototype.set = PT;
  du.exports = Et;
});
var Tu = x((n2, mu) => {
  o();
  function xT() {
    this.__data__ = [], this.size = 0;
  }
  mu.exports = xT;
});
var bu = x((a2, Su) => {
  o();
  function gT(e, t) {
    return e === t || e !== e && t !== t;
  }
  Su.exports = gT;
});
var Xt = x((i2, Eu) => {
  o();
  var hT = bu();
  function AT(e, t) {
    for (var r = e.length; r--; )
      if (hT(e[r][0], t))
        return r;
    return -1;
  }
  Eu.exports = AT;
});
var Pu = x((s2, vu) => {
  o();
  var OT = Xt(), IT = Array.prototype, _T = IT.splice;
  function DT(e) {
    var t = this.__data__, r = OT(t, e);
    if (r < 0)
      return false;
    var n = t.length - 1;
    return r == n ? t.pop() : _T.call(t, r, 1), --this.size, true;
  }
  vu.exports = DT;
});
var gu = x((o2, xu) => {
  o();
  var NT = Xt();
  function CT(e) {
    var t = this.__data__, r = NT(t, e);
    return r < 0 ? void 0 : t[r][1];
  }
  xu.exports = CT;
});
var Au = x((u2, hu) => {
  o();
  var wT = Xt();
  function LT(e) {
    return wT(this.__data__, e) > -1;
  }
  hu.exports = LT;
});
var Iu = x((l2, Ou) => {
  o();
  var jT = Xt();
  function RT(e, t) {
    var r = this.__data__, n = jT(r, e);
    return n < 0 ? (++this.size, r.push([e, t])) : r[n][1] = t, this;
  }
  Ou.exports = RT;
});
var Du = x((c2, _u) => {
  o();
  var MT = Tu(), BT = Pu(), FT = gu(), kT = Au(), KT = Iu();
  function vt(e) {
    var t = -1, r = e == null ? 0 : e.length;
    for (this.clear(); ++t < r; ) {
      var n = e[t];
      this.set(n[0], n[1]);
    }
  }
  vt.prototype.clear = MT;
  vt.prototype.delete = BT;
  vt.prototype.get = FT;
  vt.prototype.has = kT;
  vt.prototype.set = KT;
  _u.exports = vt;
});
var Cu = x((f2, Nu) => {
  o();
  var qT = Vn(), YT = Vt(), VT = qT(YT, "Map");
  Nu.exports = VT;
});
var ju = x((p2, Lu) => {
  o();
  var wu = yu(), UT = Du(), JT = Cu();
  function XT() {
    this.size = 0, this.__data__ = { hash: new wu(), map: new (JT || UT)(), string: new wu() };
  }
  Lu.exports = XT;
});
var Mu = x((d2, Ru) => {
  o();
  function WT(e) {
    var t = typeof e;
    return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? e !== "__proto__" : e === null;
  }
  Ru.exports = WT;
});
var Wt = x((y2, Bu) => {
  o();
  var $T = Mu();
  function GT(e, t) {
    var r = e.__data__;
    return $T(t) ? r[typeof t == "string" ? "string" : "hash"] : r.map;
  }
  Bu.exports = GT;
});
var ku = x((m2, Fu) => {
  o();
  var zT = Wt();
  function HT(e) {
    var t = zT(this, e).delete(e);
    return this.size -= t ? 1 : 0, t;
  }
  Fu.exports = HT;
});
var qu = x((T2, Ku) => {
  o();
  var QT = Wt();
  function ZT(e) {
    return QT(this, e).get(e);
  }
  Ku.exports = ZT;
});
var Vu = x((S2, Yu) => {
  o();
  var eS = Wt();
  function tS(e) {
    return eS(this, e).has(e);
  }
  Yu.exports = tS;
});
var Ju = x((b2, Uu) => {
  o();
  var rS = Wt();
  function nS(e, t) {
    var r = rS(this, e), n = r.size;
    return r.set(e, t), this.size += r.size == n ? 0 : 1, this;
  }
  Uu.exports = nS;
});
var Wu = x((E2, Xu) => {
  o();
  var aS = ju(), iS = ku(), sS = qu(), oS = Vu(), uS = Ju();
  function Pt(e) {
    var t = -1, r = e == null ? 0 : e.length;
    for (this.clear(); ++t < r; ) {
      var n = e[t];
      this.set(n[0], n[1]);
    }
  }
  Pt.prototype.clear = aS;
  Pt.prototype.delete = iS;
  Pt.prototype.get = sS;
  Pt.prototype.has = oS;
  Pt.prototype.set = uS;
  Xu.exports = Pt;
});
var zu = x((v2, Gu) => {
  o();
  var $u = Wu(), lS = "Expected a function";
  function Un(e, t) {
    if (typeof e != "function" || t != null && typeof t != "function")
      throw new TypeError(lS);
    var r = function() {
      var n = arguments, i = t ? t.apply(this, n) : n[0], l = r.cache;
      if (l.has(i))
        return l.get(i);
      var y = e.apply(this, n);
      return r.cache = l.set(i, y) || l, y;
    };
    return r.cache = new (Un.Cache || $u)(), r;
  }
  Un.Cache = $u;
  Gu.exports = Un;
});
var Nr = x((P2, Qu) => {
  "use strict";
  o();
  function Ke(e) {
    if (typeof e != "string")
      throw new TypeError("Path must be a string. Received " + JSON.stringify(e));
  }
  function Hu(e, t) {
    for (var r = "", n = 0, i = -1, l = 0, y, S = 0; S <= e.length; ++S) {
      if (S < e.length)
        y = e.charCodeAt(S);
      else {
        if (y === 47)
          break;
        y = 47;
      }
      if (y === 47) {
        if (!(i === S - 1 || l === 1))
          if (i !== S - 1 && l === 2) {
            if (r.length < 2 || n !== 2 || r.charCodeAt(r.length - 1) !== 46 || r.charCodeAt(r.length - 2) !== 46) {
              if (r.length > 2) {
                var P = r.lastIndexOf("/");
                if (P !== r.length - 1) {
                  P === -1 ? (r = "", n = 0) : (r = r.slice(0, P), n = r.length - 1 - r.lastIndexOf("/")), i = S, l = 0;
                  continue;
                }
              } else if (r.length === 2 || r.length === 1) {
                r = "", n = 0, i = S, l = 0;
                continue;
              }
            }
            t && (r.length > 0 ? r += "/.." : r = "..", n = 2);
          } else
            r.length > 0 ? r += "/" + e.slice(i + 1, S) : r = e.slice(i + 1, S), n = S - i - 1;
        i = S, l = 0;
      } else
        y === 46 && l !== -1 ? ++l : l = -1;
    }
    return r;
  }
  function cS(e, t) {
    var r = t.dir || t.root, n = t.base || (t.name || "") + (t.ext || "");
    return r ? r === t.root ? r + n : r + e + n : n;
  }
  var xt = { resolve: function() {
    for (var t = "", r = false, n, i = arguments.length - 1; i >= -1 && !r; i--) {
      var l;
      i >= 0 ? l = arguments[i] : (n === void 0 && (n = process.cwd()), l = n), Ke(l), l.length !== 0 && (t = l + "/" + t, r = l.charCodeAt(0) === 47);
    }
    return t = Hu(t, !r), r ? t.length > 0 ? "/" + t : "/" : t.length > 0 ? t : ".";
  }, normalize: function(t) {
    if (Ke(t), t.length === 0)
      return ".";
    var r = t.charCodeAt(0) === 47, n = t.charCodeAt(t.length - 1) === 47;
    return t = Hu(t, !r), t.length === 0 && !r && (t = "."), t.length > 0 && n && (t += "/"), r ? "/" + t : t;
  }, isAbsolute: function(t) {
    return Ke(t), t.length > 0 && t.charCodeAt(0) === 47;
  }, join: function() {
    if (arguments.length === 0)
      return ".";
    for (var t, r = 0; r < arguments.length; ++r) {
      var n = arguments[r];
      Ke(n), n.length > 0 && (t === void 0 ? t = n : t += "/" + n);
    }
    return t === void 0 ? "." : xt.normalize(t);
  }, relative: function(t, r) {
    if (Ke(t), Ke(r), t === r || (t = xt.resolve(t), r = xt.resolve(r), t === r))
      return "";
    for (var n = 1; n < t.length && t.charCodeAt(n) === 47; ++n)
      ;
    for (var i = t.length, l = i - n, y = 1; y < r.length && r.charCodeAt(y) === 47; ++y)
      ;
    for (var S = r.length, P = S - y, A = l < P ? l : P, L = -1, D = 0; D <= A; ++D) {
      if (D === A) {
        if (P > A) {
          if (r.charCodeAt(y + D) === 47)
            return r.slice(y + D + 1);
          if (D === 0)
            return r.slice(y + D);
        } else
          l > A && (t.charCodeAt(n + D) === 47 ? L = D : D === 0 && (L = 0));
        break;
      }
      var te = t.charCodeAt(n + D), X = r.charCodeAt(y + D);
      if (te !== X)
        break;
      te === 47 && (L = D);
    }
    var ie = "";
    for (D = n + L + 1; D <= i; ++D)
      (D === i || t.charCodeAt(D) === 47) && (ie.length === 0 ? ie += ".." : ie += "/..");
    return ie.length > 0 ? ie + r.slice(y + L) : (y += L, r.charCodeAt(y) === 47 && ++y, r.slice(y));
  }, _makeLong: function(t) {
    return t;
  }, dirname: function(t) {
    if (Ke(t), t.length === 0)
      return ".";
    for (var r = t.charCodeAt(0), n = r === 47, i = -1, l = true, y = t.length - 1; y >= 1; --y)
      if (r = t.charCodeAt(y), r === 47) {
        if (!l) {
          i = y;
          break;
        }
      } else
        l = false;
    return i === -1 ? n ? "/" : "." : n && i === 1 ? "//" : t.slice(0, i);
  }, basename: function(t, r) {
    if (r !== void 0 && typeof r != "string")
      throw new TypeError('"ext" argument must be a string');
    Ke(t);
    var n = 0, i = -1, l = true, y;
    if (r !== void 0 && r.length > 0 && r.length <= t.length) {
      if (r.length === t.length && r === t)
        return "";
      var S = r.length - 1, P = -1;
      for (y = t.length - 1; y >= 0; --y) {
        var A = t.charCodeAt(y);
        if (A === 47) {
          if (!l) {
            n = y + 1;
            break;
          }
        } else
          P === -1 && (l = false, P = y + 1), S >= 0 && (A === r.charCodeAt(S) ? --S === -1 && (i = y) : (S = -1, i = P));
      }
      return n === i ? i = P : i === -1 && (i = t.length), t.slice(n, i);
    } else {
      for (y = t.length - 1; y >= 0; --y)
        if (t.charCodeAt(y) === 47) {
          if (!l) {
            n = y + 1;
            break;
          }
        } else
          i === -1 && (l = false, i = y + 1);
      return i === -1 ? "" : t.slice(n, i);
    }
  }, extname: function(t) {
    Ke(t);
    for (var r = -1, n = 0, i = -1, l = true, y = 0, S = t.length - 1; S >= 0; --S) {
      var P = t.charCodeAt(S);
      if (P === 47) {
        if (!l) {
          n = S + 1;
          break;
        }
        continue;
      }
      i === -1 && (l = false, i = S + 1), P === 46 ? r === -1 ? r = S : y !== 1 && (y = 1) : r !== -1 && (y = -1);
    }
    return r === -1 || i === -1 || y === 0 || y === 1 && r === i - 1 && r === n + 1 ? "" : t.slice(r, i);
  }, format: function(t) {
    if (t === null || typeof t != "object")
      throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof t);
    return cS("/", t);
  }, parse: function(t) {
    Ke(t);
    var r = { root: "", dir: "", base: "", ext: "", name: "" };
    if (t.length === 0)
      return r;
    var n = t.charCodeAt(0), i = n === 47, l;
    i ? (r.root = "/", l = 1) : l = 0;
    for (var y = -1, S = 0, P = -1, A = true, L = t.length - 1, D = 0; L >= l; --L) {
      if (n = t.charCodeAt(L), n === 47) {
        if (!A) {
          S = L + 1;
          break;
        }
        continue;
      }
      P === -1 && (A = false, P = L + 1), n === 46 ? y === -1 ? y = L : D !== 1 && (D = 1) : y !== -1 && (D = -1);
    }
    return y === -1 || P === -1 || D === 0 || D === 1 && y === P - 1 && y === S + 1 ? P !== -1 && (S === 0 && i ? r.base = r.name = t.slice(1, P) : r.base = r.name = t.slice(S, P)) : (S === 0 && i ? (r.name = t.slice(1, y), r.base = t.slice(1, P)) : (r.name = t.slice(S, y), r.base = t.slice(S, P)), r.ext = t.slice(y, P)), S > 0 ? r.dir = t.slice(0, S - 1) : i && (r.dir = "/"), r;
  }, sep: "/", delimiter: ":", win32: null, posix: null };
  xt.posix = xt;
  Qu.exports = xt;
});
var wr = x((Jn) => {
  "use strict";
  o();
  Object.defineProperty(Jn, "__esModule", { value: true });
  Jn.default = fS;
  function fS(e, t) {
    let r = Object.keys(t);
    for (let n of r)
      if (e[n] !== t[n])
        return false;
    return true;
  }
});
var $t = x((Xn) => {
  "use strict";
  o();
  Object.defineProperty(Xn, "__esModule", { value: true });
  Xn.default = pS;
  var el = /* @__PURE__ */ new Set();
  function pS(e, t, r = "") {
    if (el.has(e))
      return;
    el.add(e);
    let { internal: n, trace: i } = dS(1, 2);
    n || console.warn(`${r}\`${e}\` has been deprecated, please migrate to \`${t}\`
${i}`);
  }
  function dS(e, t) {
    let { stackTraceLimit: r, prepareStackTrace: n } = Error, i;
    if (Error.stackTraceLimit = 1 + e + t, Error.prepareStackTrace = function(y, S) {
      i = S;
    }, new Error().stack, Error.stackTraceLimit = r, Error.prepareStackTrace = n, !i)
      return { internal: false, trace: "" };
    let l = i.slice(1 + e, 1 + e + t);
    return { internal: /[\\/]@babel[\\/]/.test(l[1].getFileName()), trace: l.map((y) => `    at ${y}`).join(`
`) };
  }
});
var pe = x((c) => {
  "use strict";
  o();
  Object.defineProperty(c, "__esModule", { value: true });
  c.isAccessor = IP;
  c.isAnyTypeAnnotation = $0;
  c.isArgumentPlaceholder = gE;
  c.isArrayExpression = yS;
  c.isArrayPattern = p0;
  c.isArrayTypeAnnotation = G0;
  c.isArrowFunctionExpression = d0;
  c.isAssignmentExpression = mS;
  c.isAssignmentPattern = f0;
  c.isAwaitExpression = M0;
  c.isBigIntLiteral = F0;
  c.isBinary = zv;
  c.isBinaryExpression = TS;
  c.isBindExpression = hE;
  c.isBlock = Zv;
  c.isBlockParent = Qv;
  c.isBlockStatement = vS;
  c.isBooleanLiteral = qS;
  c.isBooleanLiteralTypeAnnotation = H0;
  c.isBooleanTypeAnnotation = z0;
  c.isBreakStatement = PS;
  c.isCallExpression = xS;
  c.isCatchClause = gS;
  c.isClass = hP;
  c.isClassAccessorProperty = V0;
  c.isClassBody = y0;
  c.isClassDeclaration = T0;
  c.isClassExpression = m0;
  c.isClassImplements = Z0;
  c.isClassMethod = _0;
  c.isClassPrivateMethod = J0;
  c.isClassPrivateProperty = U0;
  c.isClassProperty = Y0;
  c.isCompletionStatement = rP;
  c.isConditional = nP;
  c.isConditionalExpression = hS;
  c.isContinueStatement = AS;
  c.isDebuggerStatement = OS;
  c.isDecimalLiteral = CE;
  c.isDeclaration = pP;
  c.isDeclareClass = eb;
  c.isDeclareExportAllDeclaration = lb;
  c.isDeclareExportDeclaration = ub;
  c.isDeclareFunction = tb;
  c.isDeclareInterface = rb;
  c.isDeclareModule = nb;
  c.isDeclareModuleExports = ab;
  c.isDeclareOpaqueType = sb;
  c.isDeclareTypeAlias = ib;
  c.isDeclareVariable = ob;
  c.isDeclaredPredicate = cb;
  c.isDecorator = OE;
  c.isDirective = bS;
  c.isDirectiveLiteral = ES;
  c.isDoExpression = IE;
  c.isDoWhileStatement = IS;
  c.isEmptyStatement = _S;
  c.isEmptyTypeAnnotation = Pb;
  c.isEnumBody = jP;
  c.isEnumBooleanBody = Gb;
  c.isEnumBooleanMember = Zb;
  c.isEnumDeclaration = $b;
  c.isEnumDefaultedMember = rE;
  c.isEnumMember = RP;
  c.isEnumNumberBody = zb;
  c.isEnumNumberMember = eE;
  c.isEnumStringBody = Hb;
  c.isEnumStringMember = tE;
  c.isEnumSymbolBody = Qb;
  c.isExistsTypeAnnotation = fb;
  c.isExportAllDeclaration = S0;
  c.isExportDeclaration = AP;
  c.isExportDefaultDeclaration = b0;
  c.isExportDefaultSpecifier = _E;
  c.isExportNamedDeclaration = E0;
  c.isExportNamespaceSpecifier = k0;
  c.isExportSpecifier = v0;
  c.isExpression = Gv;
  c.isExpressionStatement = DS;
  c.isExpressionWrapper = sP;
  c.isFile = NS;
  c.isFlow = DP;
  c.isFlowBaseAnnotation = CP;
  c.isFlowDeclaration = wP;
  c.isFlowPredicate = LP;
  c.isFlowType = NP;
  c.isFor = oP;
  c.isForInStatement = CS;
  c.isForOfStatement = P0;
  c.isForStatement = wS;
  c.isForXStatement = uP;
  c.isFunction = lP;
  c.isFunctionDeclaration = LS;
  c.isFunctionExpression = jS;
  c.isFunctionParent = cP;
  c.isFunctionTypeAnnotation = pb;
  c.isFunctionTypeParam = db;
  c.isGenericTypeAnnotation = yb;
  c.isIdentifier = RS;
  c.isIfStatement = MS;
  c.isImmutable = SP;
  c.isImport = B0;
  c.isImportAttribute = AE;
  c.isImportDeclaration = x0;
  c.isImportDefaultSpecifier = g0;
  c.isImportExpression = O0;
  c.isImportNamespaceSpecifier = h0;
  c.isImportOrExportDeclaration = tl;
  c.isImportSpecifier = A0;
  c.isIndexedAccessType = nE;
  c.isInferredPredicate = mb;
  c.isInterfaceDeclaration = Sb;
  c.isInterfaceExtends = Tb;
  c.isInterfaceTypeAnnotation = bb;
  c.isInterpreterDirective = SS;
  c.isIntersectionTypeAnnotation = Eb;
  c.isJSX = MP;
  c.isJSXAttribute = iE;
  c.isJSXClosingElement = sE;
  c.isJSXClosingFragment = EE;
  c.isJSXElement = oE;
  c.isJSXEmptyExpression = uE;
  c.isJSXExpressionContainer = lE;
  c.isJSXFragment = SE;
  c.isJSXIdentifier = fE;
  c.isJSXMemberExpression = pE;
  c.isJSXNamespacedName = dE;
  c.isJSXOpeningElement = yE;
  c.isJSXOpeningFragment = bE;
  c.isJSXSpreadAttribute = mE;
  c.isJSXSpreadChild = cE;
  c.isJSXText = TE;
  c.isLVal = yP;
  c.isLabeledStatement = BS;
  c.isLiteral = TP;
  c.isLogicalExpression = VS;
  c.isLoop = aP;
  c.isMemberExpression = US;
  c.isMetaProperty = I0;
  c.isMethod = EP;
  c.isMiscellaneous = BP;
  c.isMixedTypeAnnotation = vb;
  c.isModuleDeclaration = XP;
  c.isModuleExpression = wE;
  c.isModuleSpecifier = OP;
  c.isNewExpression = JS;
  c.isNoop = vE;
  c.isNullLiteral = KS;
  c.isNullLiteralTypeAnnotation = Q0;
  c.isNullableTypeAnnotation = xb;
  c.isNumberLiteral = YP;
  c.isNumberLiteralTypeAnnotation = gb;
  c.isNumberTypeAnnotation = hb;
  c.isNumericLiteral = kS;
  c.isObjectExpression = WS;
  c.isObjectMember = vP;
  c.isObjectMethod = $S;
  c.isObjectPattern = D0;
  c.isObjectProperty = GS;
  c.isObjectTypeAnnotation = Ab;
  c.isObjectTypeCallProperty = Ib;
  c.isObjectTypeIndexer = _b;
  c.isObjectTypeInternalSlot = Ob;
  c.isObjectTypeProperty = Db;
  c.isObjectTypeSpreadProperty = Nb;
  c.isOpaqueType = Cb;
  c.isOptionalCallExpression = q0;
  c.isOptionalIndexedAccessType = aE;
  c.isOptionalMemberExpression = K0;
  c.isParenthesizedExpression = ZS;
  c.isPattern = gP;
  c.isPatternLike = dP;
  c.isPipelineBareFunction = RE;
  c.isPipelinePrimaryTopicReference = ME;
  c.isPipelineTopicExpression = jE;
  c.isPlaceholder = PE;
  c.isPrivate = _P;
  c.isPrivateName = X0;
  c.isProgram = XS;
  c.isProperty = PP;
  c.isPureish = fP;
  c.isQualifiedTypeIdentifier = wb;
  c.isRecordExpression = DE;
  c.isRegExpLiteral = YS;
  c.isRegexLiteral = VP;
  c.isRestElement = zS;
  c.isRestProperty = UP;
  c.isReturnStatement = HS;
  c.isScopable = Hv;
  c.isSequenceExpression = QS;
  c.isSpreadElement = N0;
  c.isSpreadProperty = JP;
  c.isStandardized = $v;
  c.isStatement = eP;
  c.isStaticBlock = W0;
  c.isStringLiteral = FS;
  c.isStringLiteralTypeAnnotation = Lb;
  c.isStringTypeAnnotation = jb;
  c.isSuper = C0;
  c.isSwitchCase = e0;
  c.isSwitchStatement = t0;
  c.isSymbolTypeAnnotation = Rb;
  c.isTSAnyKeyword = XE;
  c.isTSArrayType = pv;
  c.isTSAsExpression = Cv;
  c.isTSBaseType = qP;
  c.isTSBigIntKeyword = $E;
  c.isTSBooleanKeyword = WE;
  c.isTSCallSignatureDeclaration = qE;
  c.isTSConditionalType = Ev;
  c.isTSConstructSignatureDeclaration = YE;
  c.isTSConstructorType = ov;
  c.isTSDeclareFunction = FE;
  c.isTSDeclareMethod = kE;
  c.isTSEntityName = mP;
  c.isTSEnumDeclaration = jv;
  c.isTSEnumMember = Rv;
  c.isTSExportAssignment = Yv;
  c.isTSExpressionWithTypeArguments = Ov;
  c.isTSExternalModuleReference = Kv;
  c.isTSFunctionType = sv;
  c.isTSImportEqualsDeclaration = kv;
  c.isTSImportType = Fv;
  c.isTSIndexSignature = JE;
  c.isTSIndexedAccessType = gv;
  c.isTSInferType = vv;
  c.isTSInstantiationExpression = Nv;
  c.isTSInterfaceBody = _v;
  c.isTSInterfaceDeclaration = Iv;
  c.isTSIntersectionType = bv;
  c.isTSIntrinsicKeyword = GE;
  c.isTSLiteralType = Av;
  c.isTSMappedType = hv;
  c.isTSMethodSignature = UE;
  c.isTSModuleBlock = Bv;
  c.isTSModuleDeclaration = Mv;
  c.isTSNamedTupleMember = Tv;
  c.isTSNamespaceExportDeclaration = Vv;
  c.isTSNeverKeyword = zE;
  c.isTSNonNullExpression = qv;
  c.isTSNullKeyword = HE;
  c.isTSNumberKeyword = QE;
  c.isTSObjectKeyword = ZE;
  c.isTSOptionalType = yv;
  c.isTSParameterProperty = BE;
  c.isTSParenthesizedType = Pv;
  c.isTSPropertySignature = VE;
  c.isTSQualifiedName = KE;
  c.isTSRestType = mv;
  c.isTSSatisfiesExpression = wv;
  c.isTSStringKeyword = ev;
  c.isTSSymbolKeyword = tv;
  c.isTSThisType = iv;
  c.isTSTupleType = dv;
  c.isTSType = KP;
  c.isTSTypeAliasDeclaration = Dv;
  c.isTSTypeAnnotation = Uv;
  c.isTSTypeAssertion = Lv;
  c.isTSTypeElement = kP;
  c.isTSTypeLiteral = fv;
  c.isTSTypeOperator = xv;
  c.isTSTypeParameter = Wv;
  c.isTSTypeParameterDeclaration = Xv;
  c.isTSTypeParameterInstantiation = Jv;
  c.isTSTypePredicate = lv;
  c.isTSTypeQuery = cv;
  c.isTSTypeReference = uv;
  c.isTSUndefinedKeyword = rv;
  c.isTSUnionType = Sv;
  c.isTSUnknownKeyword = nv;
  c.isTSVoidKeyword = av;
  c.isTaggedTemplateExpression = w0;
  c.isTemplateElement = L0;
  c.isTemplateLiteral = j0;
  c.isTerminatorless = tP;
  c.isThisExpression = r0;
  c.isThisTypeAnnotation = Mb;
  c.isThrowStatement = n0;
  c.isTopicReference = LE;
  c.isTryStatement = a0;
  c.isTupleExpression = NE;
  c.isTupleTypeAnnotation = Bb;
  c.isTypeAlias = kb;
  c.isTypeAnnotation = Kb;
  c.isTypeCastExpression = qb;
  c.isTypeParameter = Yb;
  c.isTypeParameterDeclaration = Vb;
  c.isTypeParameterInstantiation = Ub;
  c.isTypeScript = FP;
  c.isTypeofTypeAnnotation = Fb;
  c.isUnaryExpression = i0;
  c.isUnaryLike = xP;
  c.isUnionTypeAnnotation = Jb;
  c.isUpdateExpression = s0;
  c.isUserWhitespacable = bP;
  c.isV8IntrinsicIdentifier = xE;
  c.isVariableDeclaration = o0;
  c.isVariableDeclarator = u0;
  c.isVariance = Xb;
  c.isVoidTypeAnnotation = Wb;
  c.isWhile = iP;
  c.isWhileStatement = l0;
  c.isWithStatement = c0;
  c.isYieldExpression = R0;
  var d = wr(), Gt = $t();
  function yS(e, t) {
    return !e || e.type !== "ArrayExpression" ? false : t == null || (0, d.default)(e, t);
  }
  function mS(e, t) {
    return !e || e.type !== "AssignmentExpression" ? false : t == null || (0, d.default)(e, t);
  }
  function TS(e, t) {
    return !e || e.type !== "BinaryExpression" ? false : t == null || (0, d.default)(e, t);
  }
  function SS(e, t) {
    return !e || e.type !== "InterpreterDirective" ? false : t == null || (0, d.default)(e, t);
  }
  function bS(e, t) {
    return !e || e.type !== "Directive" ? false : t == null || (0, d.default)(e, t);
  }
  function ES(e, t) {
    return !e || e.type !== "DirectiveLiteral" ? false : t == null || (0, d.default)(e, t);
  }
  function vS(e, t) {
    return !e || e.type !== "BlockStatement" ? false : t == null || (0, d.default)(e, t);
  }
  function PS(e, t) {
    return !e || e.type !== "BreakStatement" ? false : t == null || (0, d.default)(e, t);
  }
  function xS(e, t) {
    return !e || e.type !== "CallExpression" ? false : t == null || (0, d.default)(e, t);
  }
  function gS(e, t) {
    return !e || e.type !== "CatchClause" ? false : t == null || (0, d.default)(e, t);
  }
  function hS(e, t) {
    return !e || e.type !== "ConditionalExpression" ? false : t == null || (0, d.default)(e, t);
  }
  function AS(e, t) {
    return !e || e.type !== "ContinueStatement" ? false : t == null || (0, d.default)(e, t);
  }
  function OS(e, t) {
    return !e || e.type !== "DebuggerStatement" ? false : t == null || (0, d.default)(e, t);
  }
  function IS(e, t) {
    return !e || e.type !== "DoWhileStatement" ? false : t == null || (0, d.default)(e, t);
  }
  function _S(e, t) {
    return !e || e.type !== "EmptyStatement" ? false : t == null || (0, d.default)(e, t);
  }
  function DS(e, t) {
    return !e || e.type !== "ExpressionStatement" ? false : t == null || (0, d.default)(e, t);
  }
  function NS(e, t) {
    return !e || e.type !== "File" ? false : t == null || (0, d.default)(e, t);
  }
  function CS(e, t) {
    return !e || e.type !== "ForInStatement" ? false : t == null || (0, d.default)(e, t);
  }
  function wS(e, t) {
    return !e || e.type !== "ForStatement" ? false : t == null || (0, d.default)(e, t);
  }
  function LS(e, t) {
    return !e || e.type !== "FunctionDeclaration" ? false : t == null || (0, d.default)(e, t);
  }
  function jS(e, t) {
    return !e || e.type !== "FunctionExpression" ? false : t == null || (0, d.default)(e, t);
  }
  function RS(e, t) {
    return !e || e.type !== "Identifier" ? false : t == null || (0, d.default)(e, t);
  }
  function MS(e, t) {
    return !e || e.type !== "IfStatement" ? false : t == null || (0, d.default)(e, t);
  }
  function BS(e, t) {
    return !e || e.type !== "LabeledStatement" ? false : t == null || (0, d.default)(e, t);
  }
  function FS(e, t) {
    return !e || e.type !== "StringLiteral" ? false : t == null || (0, d.default)(e, t);
  }
  function kS(e, t) {
    return !e || e.type !== "NumericLiteral" ? false : t == null || (0, d.default)(e, t);
  }
  function KS(e, t) {
    return !e || e.type !== "NullLiteral" ? false : t == null || (0, d.default)(e, t);
  }
  function qS(e, t) {
    return !e || e.type !== "BooleanLiteral" ? false : t == null || (0, d.default)(e, t);
  }
  function YS(e, t) {
    return !e || e.type !== "RegExpLiteral" ? false : t == null || (0, d.default)(e, t);
  }
  function VS(e, t) {
    return !e || e.type !== "LogicalExpression" ? false : t == null || (0, d.default)(e, t);
  }
  function US(e, t) {
    return !e || e.type !== "MemberExpression" ? false : t == null || (0, d.default)(e, t);
  }
  function JS(e, t) {
    return !e || e.type !== "NewExpression" ? false : t == null || (0, d.default)(e, t);
  }
  function XS(e, t) {
    return !e || e.type !== "Program" ? false : t == null || (0, d.default)(e, t);
  }
  function WS(e, t) {
    return !e || e.type !== "ObjectExpression" ? false : t == null || (0, d.default)(e, t);
  }
  function $S(e, t) {
    return !e || e.type !== "ObjectMethod" ? false : t == null || (0, d.default)(e, t);
  }
  function GS(e, t) {
    return !e || e.type !== "ObjectProperty" ? false : t == null || (0, d.default)(e, t);
  }
  function zS(e, t) {
    return !e || e.type !== "RestElement" ? false : t == null || (0, d.default)(e, t);
  }
  function HS(e, t) {
    return !e || e.type !== "ReturnStatement" ? false : t == null || (0, d.default)(e, t);
  }
  function QS(e, t) {
    return !e || e.type !== "SequenceExpression" ? false : t == null || (0, d.default)(e, t);
  }
  function ZS(e, t) {
    return !e || e.type !== "ParenthesizedExpression" ? false : t == null || (0, d.default)(e, t);
  }
  function e0(e, t) {
    return !e || e.type !== "SwitchCase" ? false : t == null || (0, d.default)(e, t);
  }
  function t0(e, t) {
    return !e || e.type !== "SwitchStatement" ? false : t == null || (0, d.default)(e, t);
  }
  function r0(e, t) {
    return !e || e.type !== "ThisExpression" ? false : t == null || (0, d.default)(e, t);
  }
  function n0(e, t) {
    return !e || e.type !== "ThrowStatement" ? false : t == null || (0, d.default)(e, t);
  }
  function a0(e, t) {
    return !e || e.type !== "TryStatement" ? false : t == null || (0, d.default)(e, t);
  }
  function i0(e, t) {
    return !e || e.type !== "UnaryExpression" ? false : t == null || (0, d.default)(e, t);
  }
  function s0(e, t) {
    return !e || e.type !== "UpdateExpression" ? false : t == null || (0, d.default)(e, t);
  }
  function o0(e, t) {
    return !e || e.type !== "VariableDeclaration" ? false : t == null || (0, d.default)(e, t);
  }
  function u0(e, t) {
    return !e || e.type !== "VariableDeclarator" ? false : t == null || (0, d.default)(e, t);
  }
  function l0(e, t) {
    return !e || e.type !== "WhileStatement" ? false : t == null || (0, d.default)(e, t);
  }
  function c0(e, t) {
    return !e || e.type !== "WithStatement" ? false : t == null || (0, d.default)(e, t);
  }
  function f0(e, t) {
    return !e || e.type !== "AssignmentPattern" ? false : t == null || (0, d.default)(e, t);
  }
  function p0(e, t) {
    return !e || e.type !== "ArrayPattern" ? false : t == null || (0, d.default)(e, t);
  }
  function d0(e, t) {
    return !e || e.type !== "ArrowFunctionExpression" ? false : t == null || (0, d.default)(e, t);
  }
  function y0(e, t) {
    return !e || e.type !== "ClassBody" ? false : t == null || (0, d.default)(e, t);
  }
  function m0(e, t) {
    return !e || e.type !== "ClassExpression" ? false : t == null || (0, d.default)(e, t);
  }
  function T0(e, t) {
    return !e || e.type !== "ClassDeclaration" ? false : t == null || (0, d.default)(e, t);
  }
  function S0(e, t) {
    return !e || e.type !== "ExportAllDeclaration" ? false : t == null || (0, d.default)(e, t);
  }
  function b0(e, t) {
    return !e || e.type !== "ExportDefaultDeclaration" ? false : t == null || (0, d.default)(e, t);
  }
  function E0(e, t) {
    return !e || e.type !== "ExportNamedDeclaration" ? false : t == null || (0, d.default)(e, t);
  }
  function v0(e, t) {
    return !e || e.type !== "ExportSpecifier" ? false : t == null || (0, d.default)(e, t);
  }
  function P0(e, t) {
    return !e || e.type !== "ForOfStatement" ? false : t == null || (0, d.default)(e, t);
  }
  function x0(e, t) {
    return !e || e.type !== "ImportDeclaration" ? false : t == null || (0, d.default)(e, t);
  }
  function g0(e, t) {
    return !e || e.type !== "ImportDefaultSpecifier" ? false : t == null || (0, d.default)(e, t);
  }
  function h0(e, t) {
    return !e || e.type !== "ImportNamespaceSpecifier" ? false : t == null || (0, d.default)(e, t);
  }
  function A0(e, t) {
    return !e || e.type !== "ImportSpecifier" ? false : t == null || (0, d.default)(e, t);
  }
  function O0(e, t) {
    return !e || e.type !== "ImportExpression" ? false : t == null || (0, d.default)(e, t);
  }
  function I0(e, t) {
    return !e || e.type !== "MetaProperty" ? false : t == null || (0, d.default)(e, t);
  }
  function _0(e, t) {
    return !e || e.type !== "ClassMethod" ? false : t == null || (0, d.default)(e, t);
  }
  function D0(e, t) {
    return !e || e.type !== "ObjectPattern" ? false : t == null || (0, d.default)(e, t);
  }
  function N0(e, t) {
    return !e || e.type !== "SpreadElement" ? false : t == null || (0, d.default)(e, t);
  }
  function C0(e, t) {
    return !e || e.type !== "Super" ? false : t == null || (0, d.default)(e, t);
  }
  function w0(e, t) {
    return !e || e.type !== "TaggedTemplateExpression" ? false : t == null || (0, d.default)(e, t);
  }
  function L0(e, t) {
    return !e || e.type !== "TemplateElement" ? false : t == null || (0, d.default)(e, t);
  }
  function j0(e, t) {
    return !e || e.type !== "TemplateLiteral" ? false : t == null || (0, d.default)(e, t);
  }
  function R0(e, t) {
    return !e || e.type !== "YieldExpression" ? false : t == null || (0, d.default)(e, t);
  }
  function M0(e, t) {
    return !e || e.type !== "AwaitExpression" ? false : t == null || (0, d.default)(e, t);
  }
  function B0(e, t) {
    return !e || e.type !== "Import" ? false : t == null || (0, d.default)(e, t);
  }
  function F0(e, t) {
    return !e || e.type !== "BigIntLiteral" ? false : t == null || (0, d.default)(e, t);
  }
  function k0(e, t) {
    return !e || e.type !== "ExportNamespaceSpecifier" ? false : t == null || (0, d.default)(e, t);
  }
  function K0(e, t) {
    return !e || e.type !== "OptionalMemberExpression" ? false : t == null || (0, d.default)(e, t);
  }
  function q0(e, t) {
    return !e || e.type !== "OptionalCallExpression" ? false : t == null || (0, d.default)(e, t);
  }
  function Y0(e, t) {
    return !e || e.type !== "ClassProperty" ? false : t == null || (0, d.default)(e, t);
  }
  function V0(e, t) {
    return !e || e.type !== "ClassAccessorProperty" ? false : t == null || (0, d.default)(e, t);
  }
  function U0(e, t) {
    return !e || e.type !== "ClassPrivateProperty" ? false : t == null || (0, d.default)(e, t);
  }
  function J0(e, t) {
    return !e || e.type !== "ClassPrivateMethod" ? false : t == null || (0, d.default)(e, t);
  }
  function X0(e, t) {
    return !e || e.type !== "PrivateName" ? false : t == null || (0, d.default)(e, t);
  }
  function W0(e, t) {
    return !e || e.type !== "StaticBlock" ? false : t == null || (0, d.default)(e, t);
  }
  function $0(e, t) {
    return !e || e.type !== "AnyTypeAnnotation" ? false : t == null || (0, d.default)(e, t);
  }
  function G0(e, t) {
    return !e || e.type !== "ArrayTypeAnnotation" ? false : t == null || (0, d.default)(e, t);
  }
  function z0(e, t) {
    return !e || e.type !== "BooleanTypeAnnotation" ? false : t == null || (0, d.default)(e, t);
  }
  function H0(e, t) {
    return !e || e.type !== "BooleanLiteralTypeAnnotation" ? false : t == null || (0, d.default)(e, t);
  }
  function Q0(e, t) {
    return !e || e.type !== "NullLiteralTypeAnnotation" ? false : t == null || (0, d.default)(e, t);
  }
  function Z0(e, t) {
    return !e || e.type !== "ClassImplements" ? false : t == null || (0, d.default)(e, t);
  }
  function eb(e, t) {
    return !e || e.type !== "DeclareClass" ? false : t == null || (0, d.default)(e, t);
  }
  function tb(e, t) {
    return !e || e.type !== "DeclareFunction" ? false : t == null || (0, d.default)(e, t);
  }
  function rb(e, t) {
    return !e || e.type !== "DeclareInterface" ? false : t == null || (0, d.default)(e, t);
  }
  function nb(e, t) {
    return !e || e.type !== "DeclareModule" ? false : t == null || (0, d.default)(e, t);
  }
  function ab(e, t) {
    return !e || e.type !== "DeclareModuleExports" ? false : t == null || (0, d.default)(e, t);
  }
  function ib(e, t) {
    return !e || e.type !== "DeclareTypeAlias" ? false : t == null || (0, d.default)(e, t);
  }
  function sb(e, t) {
    return !e || e.type !== "DeclareOpaqueType" ? false : t == null || (0, d.default)(e, t);
  }
  function ob(e, t) {
    return !e || e.type !== "DeclareVariable" ? false : t == null || (0, d.default)(e, t);
  }
  function ub(e, t) {
    return !e || e.type !== "DeclareExportDeclaration" ? false : t == null || (0, d.default)(e, t);
  }
  function lb(e, t) {
    return !e || e.type !== "DeclareExportAllDeclaration" ? false : t == null || (0, d.default)(e, t);
  }
  function cb(e, t) {
    return !e || e.type !== "DeclaredPredicate" ? false : t == null || (0, d.default)(e, t);
  }
  function fb(e, t) {
    return !e || e.type !== "ExistsTypeAnnotation" ? false : t == null || (0, d.default)(e, t);
  }
  function pb(e, t) {
    return !e || e.type !== "FunctionTypeAnnotation" ? false : t == null || (0, d.default)(e, t);
  }
  function db(e, t) {
    return !e || e.type !== "FunctionTypeParam" ? false : t == null || (0, d.default)(e, t);
  }
  function yb(e, t) {
    return !e || e.type !== "GenericTypeAnnotation" ? false : t == null || (0, d.default)(e, t);
  }
  function mb(e, t) {
    return !e || e.type !== "InferredPredicate" ? false : t == null || (0, d.default)(e, t);
  }
  function Tb(e, t) {
    return !e || e.type !== "InterfaceExtends" ? false : t == null || (0, d.default)(e, t);
  }
  function Sb(e, t) {
    return !e || e.type !== "InterfaceDeclaration" ? false : t == null || (0, d.default)(e, t);
  }
  function bb(e, t) {
    return !e || e.type !== "InterfaceTypeAnnotation" ? false : t == null || (0, d.default)(e, t);
  }
  function Eb(e, t) {
    return !e || e.type !== "IntersectionTypeAnnotation" ? false : t == null || (0, d.default)(e, t);
  }
  function vb(e, t) {
    return !e || e.type !== "MixedTypeAnnotation" ? false : t == null || (0, d.default)(e, t);
  }
  function Pb(e, t) {
    return !e || e.type !== "EmptyTypeAnnotation" ? false : t == null || (0, d.default)(e, t);
  }
  function xb(e, t) {
    return !e || e.type !== "NullableTypeAnnotation" ? false : t == null || (0, d.default)(e, t);
  }
  function gb(e, t) {
    return !e || e.type !== "NumberLiteralTypeAnnotation" ? false : t == null || (0, d.default)(e, t);
  }
  function hb(e, t) {
    return !e || e.type !== "NumberTypeAnnotation" ? false : t == null || (0, d.default)(e, t);
  }
  function Ab(e, t) {
    return !e || e.type !== "ObjectTypeAnnotation" ? false : t == null || (0, d.default)(e, t);
  }
  function Ob(e, t) {
    return !e || e.type !== "ObjectTypeInternalSlot" ? false : t == null || (0, d.default)(e, t);
  }
  function Ib(e, t) {
    return !e || e.type !== "ObjectTypeCallProperty" ? false : t == null || (0, d.default)(e, t);
  }
  function _b(e, t) {
    return !e || e.type !== "ObjectTypeIndexer" ? false : t == null || (0, d.default)(e, t);
  }
  function Db(e, t) {
    return !e || e.type !== "ObjectTypeProperty" ? false : t == null || (0, d.default)(e, t);
  }
  function Nb(e, t) {
    return !e || e.type !== "ObjectTypeSpreadProperty" ? false : t == null || (0, d.default)(e, t);
  }
  function Cb(e, t) {
    return !e || e.type !== "OpaqueType" ? false : t == null || (0, d.default)(e, t);
  }
  function wb(e, t) {
    return !e || e.type !== "QualifiedTypeIdentifier" ? false : t == null || (0, d.default)(e, t);
  }
  function Lb(e, t) {
    return !e || e.type !== "StringLiteralTypeAnnotation" ? false : t == null || (0, d.default)(e, t);
  }
  function jb(e, t) {
    return !e || e.type !== "StringTypeAnnotation" ? false : t == null || (0, d.default)(e, t);
  }
  function Rb(e, t) {
    return !e || e.type !== "SymbolTypeAnnotation" ? false : t == null || (0, d.default)(e, t);
  }
  function Mb(e, t) {
    return !e || e.type !== "ThisTypeAnnotation" ? false : t == null || (0, d.default)(e, t);
  }
  function Bb(e, t) {
    return !e || e.type !== "TupleTypeAnnotation" ? false : t == null || (0, d.default)(e, t);
  }
  function Fb(e, t) {
    return !e || e.type !== "TypeofTypeAnnotation" ? false : t == null || (0, d.default)(e, t);
  }
  function kb(e, t) {
    return !e || e.type !== "TypeAlias" ? false : t == null || (0, d.default)(e, t);
  }
  function Kb(e, t) {
    return !e || e.type !== "TypeAnnotation" ? false : t == null || (0, d.default)(e, t);
  }
  function qb(e, t) {
    return !e || e.type !== "TypeCastExpression" ? false : t == null || (0, d.default)(e, t);
  }
  function Yb(e, t) {
    return !e || e.type !== "TypeParameter" ? false : t == null || (0, d.default)(e, t);
  }
  function Vb(e, t) {
    return !e || e.type !== "TypeParameterDeclaration" ? false : t == null || (0, d.default)(e, t);
  }
  function Ub(e, t) {
    return !e || e.type !== "TypeParameterInstantiation" ? false : t == null || (0, d.default)(e, t);
  }
  function Jb(e, t) {
    return !e || e.type !== "UnionTypeAnnotation" ? false : t == null || (0, d.default)(e, t);
  }
  function Xb(e, t) {
    return !e || e.type !== "Variance" ? false : t == null || (0, d.default)(e, t);
  }
  function Wb(e, t) {
    return !e || e.type !== "VoidTypeAnnotation" ? false : t == null || (0, d.default)(e, t);
  }
  function $b(e, t) {
    return !e || e.type !== "EnumDeclaration" ? false : t == null || (0, d.default)(e, t);
  }
  function Gb(e, t) {
    return !e || e.type !== "EnumBooleanBody" ? false : t == null || (0, d.default)(e, t);
  }
  function zb(e, t) {
    return !e || e.type !== "EnumNumberBody" ? false : t == null || (0, d.default)(e, t);
  }
  function Hb(e, t) {
    return !e || e.type !== "EnumStringBody" ? false : t == null || (0, d.default)(e, t);
  }
  function Qb(e, t) {
    return !e || e.type !== "EnumSymbolBody" ? false : t == null || (0, d.default)(e, t);
  }
  function Zb(e, t) {
    return !e || e.type !== "EnumBooleanMember" ? false : t == null || (0, d.default)(e, t);
  }
  function eE(e, t) {
    return !e || e.type !== "EnumNumberMember" ? false : t == null || (0, d.default)(e, t);
  }
  function tE(e, t) {
    return !e || e.type !== "EnumStringMember" ? false : t == null || (0, d.default)(e, t);
  }
  function rE(e, t) {
    return !e || e.type !== "EnumDefaultedMember" ? false : t == null || (0, d.default)(e, t);
  }
  function nE(e, t) {
    return !e || e.type !== "IndexedAccessType" ? false : t == null || (0, d.default)(e, t);
  }
  function aE(e, t) {
    return !e || e.type !== "OptionalIndexedAccessType" ? false : t == null || (0, d.default)(e, t);
  }
  function iE(e, t) {
    return !e || e.type !== "JSXAttribute" ? false : t == null || (0, d.default)(e, t);
  }
  function sE(e, t) {
    return !e || e.type !== "JSXClosingElement" ? false : t == null || (0, d.default)(e, t);
  }
  function oE(e, t) {
    return !e || e.type !== "JSXElement" ? false : t == null || (0, d.default)(e, t);
  }
  function uE(e, t) {
    return !e || e.type !== "JSXEmptyExpression" ? false : t == null || (0, d.default)(e, t);
  }
  function lE(e, t) {
    return !e || e.type !== "JSXExpressionContainer" ? false : t == null || (0, d.default)(e, t);
  }
  function cE(e, t) {
    return !e || e.type !== "JSXSpreadChild" ? false : t == null || (0, d.default)(e, t);
  }
  function fE(e, t) {
    return !e || e.type !== "JSXIdentifier" ? false : t == null || (0, d.default)(e, t);
  }
  function pE(e, t) {
    return !e || e.type !== "JSXMemberExpression" ? false : t == null || (0, d.default)(e, t);
  }
  function dE(e, t) {
    return !e || e.type !== "JSXNamespacedName" ? false : t == null || (0, d.default)(e, t);
  }
  function yE(e, t) {
    return !e || e.type !== "JSXOpeningElement" ? false : t == null || (0, d.default)(e, t);
  }
  function mE(e, t) {
    return !e || e.type !== "JSXSpreadAttribute" ? false : t == null || (0, d.default)(e, t);
  }
  function TE(e, t) {
    return !e || e.type !== "JSXText" ? false : t == null || (0, d.default)(e, t);
  }
  function SE(e, t) {
    return !e || e.type !== "JSXFragment" ? false : t == null || (0, d.default)(e, t);
  }
  function bE(e, t) {
    return !e || e.type !== "JSXOpeningFragment" ? false : t == null || (0, d.default)(e, t);
  }
  function EE(e, t) {
    return !e || e.type !== "JSXClosingFragment" ? false : t == null || (0, d.default)(e, t);
  }
  function vE(e, t) {
    return !e || e.type !== "Noop" ? false : t == null || (0, d.default)(e, t);
  }
  function PE(e, t) {
    return !e || e.type !== "Placeholder" ? false : t == null || (0, d.default)(e, t);
  }
  function xE(e, t) {
    return !e || e.type !== "V8IntrinsicIdentifier" ? false : t == null || (0, d.default)(e, t);
  }
  function gE(e, t) {
    return !e || e.type !== "ArgumentPlaceholder" ? false : t == null || (0, d.default)(e, t);
  }
  function hE(e, t) {
    return !e || e.type !== "BindExpression" ? false : t == null || (0, d.default)(e, t);
  }
  function AE(e, t) {
    return !e || e.type !== "ImportAttribute" ? false : t == null || (0, d.default)(e, t);
  }
  function OE(e, t) {
    return !e || e.type !== "Decorator" ? false : t == null || (0, d.default)(e, t);
  }
  function IE(e, t) {
    return !e || e.type !== "DoExpression" ? false : t == null || (0, d.default)(e, t);
  }
  function _E(e, t) {
    return !e || e.type !== "ExportDefaultSpecifier" ? false : t == null || (0, d.default)(e, t);
  }
  function DE(e, t) {
    return !e || e.type !== "RecordExpression" ? false : t == null || (0, d.default)(e, t);
  }
  function NE(e, t) {
    return !e || e.type !== "TupleExpression" ? false : t == null || (0, d.default)(e, t);
  }
  function CE(e, t) {
    return !e || e.type !== "DecimalLiteral" ? false : t == null || (0, d.default)(e, t);
  }
  function wE(e, t) {
    return !e || e.type !== "ModuleExpression" ? false : t == null || (0, d.default)(e, t);
  }
  function LE(e, t) {
    return !e || e.type !== "TopicReference" ? false : t == null || (0, d.default)(e, t);
  }
  function jE(e, t) {
    return !e || e.type !== "PipelineTopicExpression" ? false : t == null || (0, d.default)(e, t);
  }
  function RE(e, t) {
    return !e || e.type !== "PipelineBareFunction" ? false : t == null || (0, d.default)(e, t);
  }
  function ME(e, t) {
    return !e || e.type !== "PipelinePrimaryTopicReference" ? false : t == null || (0, d.default)(e, t);
  }
  function BE(e, t) {
    return !e || e.type !== "TSParameterProperty" ? false : t == null || (0, d.default)(e, t);
  }
  function FE(e, t) {
    return !e || e.type !== "TSDeclareFunction" ? false : t == null || (0, d.default)(e, t);
  }
  function kE(e, t) {
    return !e || e.type !== "TSDeclareMethod" ? false : t == null || (0, d.default)(e, t);
  }
  function KE(e, t) {
    return !e || e.type !== "TSQualifiedName" ? false : t == null || (0, d.default)(e, t);
  }
  function qE(e, t) {
    return !e || e.type !== "TSCallSignatureDeclaration" ? false : t == null || (0, d.default)(e, t);
  }
  function YE(e, t) {
    return !e || e.type !== "TSConstructSignatureDeclaration" ? false : t == null || (0, d.default)(e, t);
  }
  function VE(e, t) {
    return !e || e.type !== "TSPropertySignature" ? false : t == null || (0, d.default)(e, t);
  }
  function UE(e, t) {
    return !e || e.type !== "TSMethodSignature" ? false : t == null || (0, d.default)(e, t);
  }
  function JE(e, t) {
    return !e || e.type !== "TSIndexSignature" ? false : t == null || (0, d.default)(e, t);
  }
  function XE(e, t) {
    return !e || e.type !== "TSAnyKeyword" ? false : t == null || (0, d.default)(e, t);
  }
  function WE(e, t) {
    return !e || e.type !== "TSBooleanKeyword" ? false : t == null || (0, d.default)(e, t);
  }
  function $E(e, t) {
    return !e || e.type !== "TSBigIntKeyword" ? false : t == null || (0, d.default)(e, t);
  }
  function GE(e, t) {
    return !e || e.type !== "TSIntrinsicKeyword" ? false : t == null || (0, d.default)(e, t);
  }
  function zE(e, t) {
    return !e || e.type !== "TSNeverKeyword" ? false : t == null || (0, d.default)(e, t);
  }
  function HE(e, t) {
    return !e || e.type !== "TSNullKeyword" ? false : t == null || (0, d.default)(e, t);
  }
  function QE(e, t) {
    return !e || e.type !== "TSNumberKeyword" ? false : t == null || (0, d.default)(e, t);
  }
  function ZE(e, t) {
    return !e || e.type !== "TSObjectKeyword" ? false : t == null || (0, d.default)(e, t);
  }
  function ev(e, t) {
    return !e || e.type !== "TSStringKeyword" ? false : t == null || (0, d.default)(e, t);
  }
  function tv(e, t) {
    return !e || e.type !== "TSSymbolKeyword" ? false : t == null || (0, d.default)(e, t);
  }
  function rv(e, t) {
    return !e || e.type !== "TSUndefinedKeyword" ? false : t == null || (0, d.default)(e, t);
  }
  function nv(e, t) {
    return !e || e.type !== "TSUnknownKeyword" ? false : t == null || (0, d.default)(e, t);
  }
  function av(e, t) {
    return !e || e.type !== "TSVoidKeyword" ? false : t == null || (0, d.default)(e, t);
  }
  function iv(e, t) {
    return !e || e.type !== "TSThisType" ? false : t == null || (0, d.default)(e, t);
  }
  function sv(e, t) {
    return !e || e.type !== "TSFunctionType" ? false : t == null || (0, d.default)(e, t);
  }
  function ov(e, t) {
    return !e || e.type !== "TSConstructorType" ? false : t == null || (0, d.default)(e, t);
  }
  function uv(e, t) {
    return !e || e.type !== "TSTypeReference" ? false : t == null || (0, d.default)(e, t);
  }
  function lv(e, t) {
    return !e || e.type !== "TSTypePredicate" ? false : t == null || (0, d.default)(e, t);
  }
  function cv(e, t) {
    return !e || e.type !== "TSTypeQuery" ? false : t == null || (0, d.default)(e, t);
  }
  function fv(e, t) {
    return !e || e.type !== "TSTypeLiteral" ? false : t == null || (0, d.default)(e, t);
  }
  function pv(e, t) {
    return !e || e.type !== "TSArrayType" ? false : t == null || (0, d.default)(e, t);
  }
  function dv(e, t) {
    return !e || e.type !== "TSTupleType" ? false : t == null || (0, d.default)(e, t);
  }
  function yv(e, t) {
    return !e || e.type !== "TSOptionalType" ? false : t == null || (0, d.default)(e, t);
  }
  function mv(e, t) {
    return !e || e.type !== "TSRestType" ? false : t == null || (0, d.default)(e, t);
  }
  function Tv(e, t) {
    return !e || e.type !== "TSNamedTupleMember" ? false : t == null || (0, d.default)(e, t);
  }
  function Sv(e, t) {
    return !e || e.type !== "TSUnionType" ? false : t == null || (0, d.default)(e, t);
  }
  function bv(e, t) {
    return !e || e.type !== "TSIntersectionType" ? false : t == null || (0, d.default)(e, t);
  }
  function Ev(e, t) {
    return !e || e.type !== "TSConditionalType" ? false : t == null || (0, d.default)(e, t);
  }
  function vv(e, t) {
    return !e || e.type !== "TSInferType" ? false : t == null || (0, d.default)(e, t);
  }
  function Pv(e, t) {
    return !e || e.type !== "TSParenthesizedType" ? false : t == null || (0, d.default)(e, t);
  }
  function xv(e, t) {
    return !e || e.type !== "TSTypeOperator" ? false : t == null || (0, d.default)(e, t);
  }
  function gv(e, t) {
    return !e || e.type !== "TSIndexedAccessType" ? false : t == null || (0, d.default)(e, t);
  }
  function hv(e, t) {
    return !e || e.type !== "TSMappedType" ? false : t == null || (0, d.default)(e, t);
  }
  function Av(e, t) {
    return !e || e.type !== "TSLiteralType" ? false : t == null || (0, d.default)(e, t);
  }
  function Ov(e, t) {
    return !e || e.type !== "TSExpressionWithTypeArguments" ? false : t == null || (0, d.default)(e, t);
  }
  function Iv(e, t) {
    return !e || e.type !== "TSInterfaceDeclaration" ? false : t == null || (0, d.default)(e, t);
  }
  function _v(e, t) {
    return !e || e.type !== "TSInterfaceBody" ? false : t == null || (0, d.default)(e, t);
  }
  function Dv(e, t) {
    return !e || e.type !== "TSTypeAliasDeclaration" ? false : t == null || (0, d.default)(e, t);
  }
  function Nv(e, t) {
    return !e || e.type !== "TSInstantiationExpression" ? false : t == null || (0, d.default)(e, t);
  }
  function Cv(e, t) {
    return !e || e.type !== "TSAsExpression" ? false : t == null || (0, d.default)(e, t);
  }
  function wv(e, t) {
    return !e || e.type !== "TSSatisfiesExpression" ? false : t == null || (0, d.default)(e, t);
  }
  function Lv(e, t) {
    return !e || e.type !== "TSTypeAssertion" ? false : t == null || (0, d.default)(e, t);
  }
  function jv(e, t) {
    return !e || e.type !== "TSEnumDeclaration" ? false : t == null || (0, d.default)(e, t);
  }
  function Rv(e, t) {
    return !e || e.type !== "TSEnumMember" ? false : t == null || (0, d.default)(e, t);
  }
  function Mv(e, t) {
    return !e || e.type !== "TSModuleDeclaration" ? false : t == null || (0, d.default)(e, t);
  }
  function Bv(e, t) {
    return !e || e.type !== "TSModuleBlock" ? false : t == null || (0, d.default)(e, t);
  }
  function Fv(e, t) {
    return !e || e.type !== "TSImportType" ? false : t == null || (0, d.default)(e, t);
  }
  function kv(e, t) {
    return !e || e.type !== "TSImportEqualsDeclaration" ? false : t == null || (0, d.default)(e, t);
  }
  function Kv(e, t) {
    return !e || e.type !== "TSExternalModuleReference" ? false : t == null || (0, d.default)(e, t);
  }
  function qv(e, t) {
    return !e || e.type !== "TSNonNullExpression" ? false : t == null || (0, d.default)(e, t);
  }
  function Yv(e, t) {
    return !e || e.type !== "TSExportAssignment" ? false : t == null || (0, d.default)(e, t);
  }
  function Vv(e, t) {
    return !e || e.type !== "TSNamespaceExportDeclaration" ? false : t == null || (0, d.default)(e, t);
  }
  function Uv(e, t) {
    return !e || e.type !== "TSTypeAnnotation" ? false : t == null || (0, d.default)(e, t);
  }
  function Jv(e, t) {
    return !e || e.type !== "TSTypeParameterInstantiation" ? false : t == null || (0, d.default)(e, t);
  }
  function Xv(e, t) {
    return !e || e.type !== "TSTypeParameterDeclaration" ? false : t == null || (0, d.default)(e, t);
  }
  function Wv(e, t) {
    return !e || e.type !== "TSTypeParameter" ? false : t == null || (0, d.default)(e, t);
  }
  function $v(e, t) {
    if (!e)
      return false;
    switch (e.type) {
      case "ArrayExpression":
      case "AssignmentExpression":
      case "BinaryExpression":
      case "InterpreterDirective":
      case "Directive":
      case "DirectiveLiteral":
      case "BlockStatement":
      case "BreakStatement":
      case "CallExpression":
      case "CatchClause":
      case "ConditionalExpression":
      case "ContinueStatement":
      case "DebuggerStatement":
      case "DoWhileStatement":
      case "EmptyStatement":
      case "ExpressionStatement":
      case "File":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Identifier":
      case "IfStatement":
      case "LabeledStatement":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "LogicalExpression":
      case "MemberExpression":
      case "NewExpression":
      case "Program":
      case "ObjectExpression":
      case "ObjectMethod":
      case "ObjectProperty":
      case "RestElement":
      case "ReturnStatement":
      case "SequenceExpression":
      case "ParenthesizedExpression":
      case "SwitchCase":
      case "SwitchStatement":
      case "ThisExpression":
      case "ThrowStatement":
      case "TryStatement":
      case "UnaryExpression":
      case "UpdateExpression":
      case "VariableDeclaration":
      case "VariableDeclarator":
      case "WhileStatement":
      case "WithStatement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ArrowFunctionExpression":
      case "ClassBody":
      case "ClassExpression":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ExportSpecifier":
      case "ForOfStatement":
      case "ImportDeclaration":
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
      case "ImportExpression":
      case "MetaProperty":
      case "ClassMethod":
      case "ObjectPattern":
      case "SpreadElement":
      case "Super":
      case "TaggedTemplateExpression":
      case "TemplateElement":
      case "TemplateLiteral":
      case "YieldExpression":
      case "AwaitExpression":
      case "Import":
      case "BigIntLiteral":
      case "ExportNamespaceSpecifier":
      case "OptionalMemberExpression":
      case "OptionalCallExpression":
      case "ClassProperty":
      case "ClassAccessorProperty":
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
      case "PrivateName":
      case "StaticBlock":
        break;
      case "Placeholder":
        switch (e.expectedNode) {
          case "Identifier":
          case "StringLiteral":
          case "BlockStatement":
          case "ClassBody":
            break;
          default:
            return false;
        }
        break;
      default:
        return false;
    }
    return t == null || (0, d.default)(e, t);
  }
  function Gv(e, t) {
    if (!e)
      return false;
    switch (e.type) {
      case "ArrayExpression":
      case "AssignmentExpression":
      case "BinaryExpression":
      case "CallExpression":
      case "ConditionalExpression":
      case "FunctionExpression":
      case "Identifier":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "LogicalExpression":
      case "MemberExpression":
      case "NewExpression":
      case "ObjectExpression":
      case "SequenceExpression":
      case "ParenthesizedExpression":
      case "ThisExpression":
      case "UnaryExpression":
      case "UpdateExpression":
      case "ArrowFunctionExpression":
      case "ClassExpression":
      case "ImportExpression":
      case "MetaProperty":
      case "Super":
      case "TaggedTemplateExpression":
      case "TemplateLiteral":
      case "YieldExpression":
      case "AwaitExpression":
      case "Import":
      case "BigIntLiteral":
      case "OptionalMemberExpression":
      case "OptionalCallExpression":
      case "TypeCastExpression":
      case "JSXElement":
      case "JSXFragment":
      case "BindExpression":
      case "DoExpression":
      case "RecordExpression":
      case "TupleExpression":
      case "DecimalLiteral":
      case "ModuleExpression":
      case "TopicReference":
      case "PipelineTopicExpression":
      case "PipelineBareFunction":
      case "PipelinePrimaryTopicReference":
      case "TSInstantiationExpression":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (e.expectedNode) {
          case "Expression":
          case "Identifier":
          case "StringLiteral":
            break;
          default:
            return false;
        }
        break;
      default:
        return false;
    }
    return t == null || (0, d.default)(e, t);
  }
  function zv(e, t) {
    if (!e)
      return false;
    switch (e.type) {
      case "BinaryExpression":
      case "LogicalExpression":
        break;
      default:
        return false;
    }
    return t == null || (0, d.default)(e, t);
  }
  function Hv(e, t) {
    if (!e)
      return false;
    switch (e.type) {
      case "BlockStatement":
      case "CatchClause":
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Program":
      case "ObjectMethod":
      case "SwitchStatement":
      case "WhileStatement":
      case "ArrowFunctionExpression":
      case "ClassExpression":
      case "ClassDeclaration":
      case "ForOfStatement":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if (e.expectedNode === "BlockStatement")
          break;
      default:
        return false;
    }
    return t == null || (0, d.default)(e, t);
  }
  function Qv(e, t) {
    if (!e)
      return false;
    switch (e.type) {
      case "BlockStatement":
      case "CatchClause":
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Program":
      case "ObjectMethod":
      case "SwitchStatement":
      case "WhileStatement":
      case "ArrowFunctionExpression":
      case "ForOfStatement":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if (e.expectedNode === "BlockStatement")
          break;
      default:
        return false;
    }
    return t == null || (0, d.default)(e, t);
  }
  function Zv(e, t) {
    if (!e)
      return false;
    switch (e.type) {
      case "BlockStatement":
      case "Program":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if (e.expectedNode === "BlockStatement")
          break;
      default:
        return false;
    }
    return t == null || (0, d.default)(e, t);
  }
  function eP(e, t) {
    if (!e)
      return false;
    switch (e.type) {
      case "BlockStatement":
      case "BreakStatement":
      case "ContinueStatement":
      case "DebuggerStatement":
      case "DoWhileStatement":
      case "EmptyStatement":
      case "ExpressionStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "IfStatement":
      case "LabeledStatement":
      case "ReturnStatement":
      case "SwitchStatement":
      case "ThrowStatement":
      case "TryStatement":
      case "VariableDeclaration":
      case "WhileStatement":
      case "WithStatement":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ForOfStatement":
      case "ImportDeclaration":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
      case "EnumDeclaration":
      case "TSDeclareFunction":
      case "TSInterfaceDeclaration":
      case "TSTypeAliasDeclaration":
      case "TSEnumDeclaration":
      case "TSModuleDeclaration":
      case "TSImportEqualsDeclaration":
      case "TSExportAssignment":
      case "TSNamespaceExportDeclaration":
        break;
      case "Placeholder":
        switch (e.expectedNode) {
          case "Statement":
          case "Declaration":
          case "BlockStatement":
            break;
          default:
            return false;
        }
        break;
      default:
        return false;
    }
    return t == null || (0, d.default)(e, t);
  }
  function tP(e, t) {
    if (!e)
      return false;
    switch (e.type) {
      case "BreakStatement":
      case "ContinueStatement":
      case "ReturnStatement":
      case "ThrowStatement":
      case "YieldExpression":
      case "AwaitExpression":
        break;
      default:
        return false;
    }
    return t == null || (0, d.default)(e, t);
  }
  function rP(e, t) {
    if (!e)
      return false;
    switch (e.type) {
      case "BreakStatement":
      case "ContinueStatement":
      case "ReturnStatement":
      case "ThrowStatement":
        break;
      default:
        return false;
    }
    return t == null || (0, d.default)(e, t);
  }
  function nP(e, t) {
    if (!e)
      return false;
    switch (e.type) {
      case "ConditionalExpression":
      case "IfStatement":
        break;
      default:
        return false;
    }
    return t == null || (0, d.default)(e, t);
  }
  function aP(e, t) {
    if (!e)
      return false;
    switch (e.type) {
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "WhileStatement":
      case "ForOfStatement":
        break;
      default:
        return false;
    }
    return t == null || (0, d.default)(e, t);
  }
  function iP(e, t) {
    if (!e)
      return false;
    switch (e.type) {
      case "DoWhileStatement":
      case "WhileStatement":
        break;
      default:
        return false;
    }
    return t == null || (0, d.default)(e, t);
  }
  function sP(e, t) {
    if (!e)
      return false;
    switch (e.type) {
      case "ExpressionStatement":
      case "ParenthesizedExpression":
      case "TypeCastExpression":
        break;
      default:
        return false;
    }
    return t == null || (0, d.default)(e, t);
  }
  function oP(e, t) {
    if (!e)
      return false;
    switch (e.type) {
      case "ForInStatement":
      case "ForStatement":
      case "ForOfStatement":
        break;
      default:
        return false;
    }
    return t == null || (0, d.default)(e, t);
  }
  function uP(e, t) {
    if (!e)
      return false;
    switch (e.type) {
      case "ForInStatement":
      case "ForOfStatement":
        break;
      default:
        return false;
    }
    return t == null || (0, d.default)(e, t);
  }
  function lP(e, t) {
    if (!e)
      return false;
    switch (e.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "ObjectMethod":
      case "ArrowFunctionExpression":
      case "ClassMethod":
      case "ClassPrivateMethod":
        break;
      default:
        return false;
    }
    return t == null || (0, d.default)(e, t);
  }
  function cP(e, t) {
    if (!e)
      return false;
    switch (e.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "ObjectMethod":
      case "ArrowFunctionExpression":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      default:
        return false;
    }
    return t == null || (0, d.default)(e, t);
  }
  function fP(e, t) {
    if (!e)
      return false;
    switch (e.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "ArrowFunctionExpression":
      case "BigIntLiteral":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if (e.expectedNode === "StringLiteral")
          break;
      default:
        return false;
    }
    return t == null || (0, d.default)(e, t);
  }
  function pP(e, t) {
    if (!e)
      return false;
    switch (e.type) {
      case "FunctionDeclaration":
      case "VariableDeclaration":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ImportDeclaration":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
      case "EnumDeclaration":
      case "TSDeclareFunction":
      case "TSInterfaceDeclaration":
      case "TSTypeAliasDeclaration":
      case "TSEnumDeclaration":
      case "TSModuleDeclaration":
        break;
      case "Placeholder":
        if (e.expectedNode === "Declaration")
          break;
      default:
        return false;
    }
    return t == null || (0, d.default)(e, t);
  }
  function dP(e, t) {
    if (!e)
      return false;
    switch (e.type) {
      case "Identifier":
      case "RestElement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (e.expectedNode) {
          case "Pattern":
          case "Identifier":
            break;
          default:
            return false;
        }
        break;
      default:
        return false;
    }
    return t == null || (0, d.default)(e, t);
  }
  function yP(e, t) {
    if (!e)
      return false;
    switch (e.type) {
      case "Identifier":
      case "MemberExpression":
      case "RestElement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
      case "TSParameterProperty":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (e.expectedNode) {
          case "Pattern":
          case "Identifier":
            break;
          default:
            return false;
        }
        break;
      default:
        return false;
    }
    return t == null || (0, d.default)(e, t);
  }
  function mP(e, t) {
    if (!e)
      return false;
    switch (e.type) {
      case "Identifier":
      case "TSQualifiedName":
        break;
      case "Placeholder":
        if (e.expectedNode === "Identifier")
          break;
      default:
        return false;
    }
    return t == null || (0, d.default)(e, t);
  }
  function TP(e, t) {
    if (!e)
      return false;
    switch (e.type) {
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "TemplateLiteral":
      case "BigIntLiteral":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if (e.expectedNode === "StringLiteral")
          break;
      default:
        return false;
    }
    return t == null || (0, d.default)(e, t);
  }
  function SP(e, t) {
    if (!e)
      return false;
    switch (e.type) {
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "BigIntLiteral":
      case "JSXAttribute":
      case "JSXClosingElement":
      case "JSXElement":
      case "JSXExpressionContainer":
      case "JSXSpreadChild":
      case "JSXOpeningElement":
      case "JSXText":
      case "JSXFragment":
      case "JSXOpeningFragment":
      case "JSXClosingFragment":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if (e.expectedNode === "StringLiteral")
          break;
      default:
        return false;
    }
    return t == null || (0, d.default)(e, t);
  }
  function bP(e, t) {
    if (!e)
      return false;
    switch (e.type) {
      case "ObjectMethod":
      case "ObjectProperty":
      case "ObjectTypeInternalSlot":
      case "ObjectTypeCallProperty":
      case "ObjectTypeIndexer":
      case "ObjectTypeProperty":
      case "ObjectTypeSpreadProperty":
        break;
      default:
        return false;
    }
    return t == null || (0, d.default)(e, t);
  }
  function EP(e, t) {
    if (!e)
      return false;
    switch (e.type) {
      case "ObjectMethod":
      case "ClassMethod":
      case "ClassPrivateMethod":
        break;
      default:
        return false;
    }
    return t == null || (0, d.default)(e, t);
  }
  function vP(e, t) {
    if (!e)
      return false;
    switch (e.type) {
      case "ObjectMethod":
      case "ObjectProperty":
        break;
      default:
        return false;
    }
    return t == null || (0, d.default)(e, t);
  }
  function PP(e, t) {
    if (!e)
      return false;
    switch (e.type) {
      case "ObjectProperty":
      case "ClassProperty":
      case "ClassAccessorProperty":
      case "ClassPrivateProperty":
        break;
      default:
        return false;
    }
    return t == null || (0, d.default)(e, t);
  }
  function xP(e, t) {
    if (!e)
      return false;
    switch (e.type) {
      case "UnaryExpression":
      case "SpreadElement":
        break;
      default:
        return false;
    }
    return t == null || (0, d.default)(e, t);
  }
  function gP(e, t) {
    if (!e)
      return false;
    switch (e.type) {
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
        break;
      case "Placeholder":
        if (e.expectedNode === "Pattern")
          break;
      default:
        return false;
    }
    return t == null || (0, d.default)(e, t);
  }
  function hP(e, t) {
    if (!e)
      return false;
    switch (e.type) {
      case "ClassExpression":
      case "ClassDeclaration":
        break;
      default:
        return false;
    }
    return t == null || (0, d.default)(e, t);
  }
  function tl(e, t) {
    if (!e)
      return false;
    switch (e.type) {
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ImportDeclaration":
        break;
      default:
        return false;
    }
    return t == null || (0, d.default)(e, t);
  }
  function AP(e, t) {
    if (!e)
      return false;
    switch (e.type) {
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
        break;
      default:
        return false;
    }
    return t == null || (0, d.default)(e, t);
  }
  function OP(e, t) {
    if (!e)
      return false;
    switch (e.type) {
      case "ExportSpecifier":
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
      case "ExportNamespaceSpecifier":
      case "ExportDefaultSpecifier":
        break;
      default:
        return false;
    }
    return t == null || (0, d.default)(e, t);
  }
  function IP(e, t) {
    if (!e)
      return false;
    switch (e.type) {
      case "ClassAccessorProperty":
        break;
      default:
        return false;
    }
    return t == null || (0, d.default)(e, t);
  }
  function _P(e, t) {
    if (!e)
      return false;
    switch (e.type) {
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
      case "PrivateName":
        break;
      default:
        return false;
    }
    return t == null || (0, d.default)(e, t);
  }
  function DP(e, t) {
    if (!e)
      return false;
    switch (e.type) {
      case "AnyTypeAnnotation":
      case "ArrayTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "BooleanLiteralTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "ClassImplements":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "DeclaredPredicate":
      case "ExistsTypeAnnotation":
      case "FunctionTypeAnnotation":
      case "FunctionTypeParam":
      case "GenericTypeAnnotation":
      case "InferredPredicate":
      case "InterfaceExtends":
      case "InterfaceDeclaration":
      case "InterfaceTypeAnnotation":
      case "IntersectionTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NullableTypeAnnotation":
      case "NumberLiteralTypeAnnotation":
      case "NumberTypeAnnotation":
      case "ObjectTypeAnnotation":
      case "ObjectTypeInternalSlot":
      case "ObjectTypeCallProperty":
      case "ObjectTypeIndexer":
      case "ObjectTypeProperty":
      case "ObjectTypeSpreadProperty":
      case "OpaqueType":
      case "QualifiedTypeIdentifier":
      case "StringLiteralTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "TupleTypeAnnotation":
      case "TypeofTypeAnnotation":
      case "TypeAlias":
      case "TypeAnnotation":
      case "TypeCastExpression":
      case "TypeParameter":
      case "TypeParameterDeclaration":
      case "TypeParameterInstantiation":
      case "UnionTypeAnnotation":
      case "Variance":
      case "VoidTypeAnnotation":
      case "EnumDeclaration":
      case "EnumBooleanBody":
      case "EnumNumberBody":
      case "EnumStringBody":
      case "EnumSymbolBody":
      case "EnumBooleanMember":
      case "EnumNumberMember":
      case "EnumStringMember":
      case "EnumDefaultedMember":
      case "IndexedAccessType":
      case "OptionalIndexedAccessType":
        break;
      default:
        return false;
    }
    return t == null || (0, d.default)(e, t);
  }
  function NP(e, t) {
    if (!e)
      return false;
    switch (e.type) {
      case "AnyTypeAnnotation":
      case "ArrayTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "BooleanLiteralTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "ExistsTypeAnnotation":
      case "FunctionTypeAnnotation":
      case "GenericTypeAnnotation":
      case "InterfaceTypeAnnotation":
      case "IntersectionTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NullableTypeAnnotation":
      case "NumberLiteralTypeAnnotation":
      case "NumberTypeAnnotation":
      case "ObjectTypeAnnotation":
      case "StringLiteralTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "TupleTypeAnnotation":
      case "TypeofTypeAnnotation":
      case "UnionTypeAnnotation":
      case "VoidTypeAnnotation":
      case "IndexedAccessType":
      case "OptionalIndexedAccessType":
        break;
      default:
        return false;
    }
    return t == null || (0, d.default)(e, t);
  }
  function CP(e, t) {
    if (!e)
      return false;
    switch (e.type) {
      case "AnyTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NumberTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "VoidTypeAnnotation":
        break;
      default:
        return false;
    }
    return t == null || (0, d.default)(e, t);
  }
  function wP(e, t) {
    if (!e)
      return false;
    switch (e.type) {
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
        break;
      default:
        return false;
    }
    return t == null || (0, d.default)(e, t);
  }
  function LP(e, t) {
    if (!e)
      return false;
    switch (e.type) {
      case "DeclaredPredicate":
      case "InferredPredicate":
        break;
      default:
        return false;
    }
    return t == null || (0, d.default)(e, t);
  }
  function jP(e, t) {
    if (!e)
      return false;
    switch (e.type) {
      case "EnumBooleanBody":
      case "EnumNumberBody":
      case "EnumStringBody":
      case "EnumSymbolBody":
        break;
      default:
        return false;
    }
    return t == null || (0, d.default)(e, t);
  }
  function RP(e, t) {
    if (!e)
      return false;
    switch (e.type) {
      case "EnumBooleanMember":
      case "EnumNumberMember":
      case "EnumStringMember":
      case "EnumDefaultedMember":
        break;
      default:
        return false;
    }
    return t == null || (0, d.default)(e, t);
  }
  function MP(e, t) {
    if (!e)
      return false;
    switch (e.type) {
      case "JSXAttribute":
      case "JSXClosingElement":
      case "JSXElement":
      case "JSXEmptyExpression":
      case "JSXExpressionContainer":
      case "JSXSpreadChild":
      case "JSXIdentifier":
      case "JSXMemberExpression":
      case "JSXNamespacedName":
      case "JSXOpeningElement":
      case "JSXSpreadAttribute":
      case "JSXText":
      case "JSXFragment":
      case "JSXOpeningFragment":
      case "JSXClosingFragment":
        break;
      default:
        return false;
    }
    return t == null || (0, d.default)(e, t);
  }
  function BP(e, t) {
    if (!e)
      return false;
    switch (e.type) {
      case "Noop":
      case "Placeholder":
      case "V8IntrinsicIdentifier":
        break;
      default:
        return false;
    }
    return t == null || (0, d.default)(e, t);
  }
  function FP(e, t) {
    if (!e)
      return false;
    switch (e.type) {
      case "TSParameterProperty":
      case "TSDeclareFunction":
      case "TSDeclareMethod":
      case "TSQualifiedName":
      case "TSCallSignatureDeclaration":
      case "TSConstructSignatureDeclaration":
      case "TSPropertySignature":
      case "TSMethodSignature":
      case "TSIndexSignature":
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSFunctionType":
      case "TSConstructorType":
      case "TSTypeReference":
      case "TSTypePredicate":
      case "TSTypeQuery":
      case "TSTypeLiteral":
      case "TSArrayType":
      case "TSTupleType":
      case "TSOptionalType":
      case "TSRestType":
      case "TSNamedTupleMember":
      case "TSUnionType":
      case "TSIntersectionType":
      case "TSConditionalType":
      case "TSInferType":
      case "TSParenthesizedType":
      case "TSTypeOperator":
      case "TSIndexedAccessType":
      case "TSMappedType":
      case "TSLiteralType":
      case "TSExpressionWithTypeArguments":
      case "TSInterfaceDeclaration":
      case "TSInterfaceBody":
      case "TSTypeAliasDeclaration":
      case "TSInstantiationExpression":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSEnumDeclaration":
      case "TSEnumMember":
      case "TSModuleDeclaration":
      case "TSModuleBlock":
      case "TSImportType":
      case "TSImportEqualsDeclaration":
      case "TSExternalModuleReference":
      case "TSNonNullExpression":
      case "TSExportAssignment":
      case "TSNamespaceExportDeclaration":
      case "TSTypeAnnotation":
      case "TSTypeParameterInstantiation":
      case "TSTypeParameterDeclaration":
      case "TSTypeParameter":
        break;
      default:
        return false;
    }
    return t == null || (0, d.default)(e, t);
  }
  function kP(e, t) {
    if (!e)
      return false;
    switch (e.type) {
      case "TSCallSignatureDeclaration":
      case "TSConstructSignatureDeclaration":
      case "TSPropertySignature":
      case "TSMethodSignature":
      case "TSIndexSignature":
        break;
      default:
        return false;
    }
    return t == null || (0, d.default)(e, t);
  }
  function KP(e, t) {
    if (!e)
      return false;
    switch (e.type) {
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSFunctionType":
      case "TSConstructorType":
      case "TSTypeReference":
      case "TSTypePredicate":
      case "TSTypeQuery":
      case "TSTypeLiteral":
      case "TSArrayType":
      case "TSTupleType":
      case "TSOptionalType":
      case "TSRestType":
      case "TSUnionType":
      case "TSIntersectionType":
      case "TSConditionalType":
      case "TSInferType":
      case "TSParenthesizedType":
      case "TSTypeOperator":
      case "TSIndexedAccessType":
      case "TSMappedType":
      case "TSLiteralType":
      case "TSExpressionWithTypeArguments":
      case "TSImportType":
        break;
      default:
        return false;
    }
    return t == null || (0, d.default)(e, t);
  }
  function qP(e, t) {
    if (!e)
      return false;
    switch (e.type) {
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSLiteralType":
        break;
      default:
        return false;
    }
    return t == null || (0, d.default)(e, t);
  }
  function YP(e, t) {
    return (0, Gt.default)("isNumberLiteral", "isNumericLiteral"), !e || e.type !== "NumberLiteral" ? false : t == null || (0, d.default)(e, t);
  }
  function VP(e, t) {
    return (0, Gt.default)("isRegexLiteral", "isRegExpLiteral"), !e || e.type !== "RegexLiteral" ? false : t == null || (0, d.default)(e, t);
  }
  function UP(e, t) {
    return (0, Gt.default)("isRestProperty", "isRestElement"), !e || e.type !== "RestProperty" ? false : t == null || (0, d.default)(e, t);
  }
  function JP(e, t) {
    return (0, Gt.default)("isSpreadProperty", "isSpreadElement"), !e || e.type !== "SpreadProperty" ? false : t == null || (0, d.default)(e, t);
  }
  function XP(e, t) {
    return (0, Gt.default)("isModuleDeclaration", "isImportOrExportDeclaration"), tl(e, t);
  }
});
var $n = x((Wn) => {
  "use strict";
  o();
  Object.defineProperty(Wn, "__esModule", { value: true });
  Wn.default = WP;
  var zt = pe();
  function WP(e, t, r) {
    if (!(0, zt.isMemberExpression)(e))
      return false;
    let n = Array.isArray(t) ? t : t.split("."), i = [], l;
    for (l = e; (0, zt.isMemberExpression)(l); l = l.object)
      i.push(l.property);
    if (i.push(l), i.length < n.length || !r && i.length > n.length)
      return false;
    for (let y = 0, S = i.length - 1; y < n.length; y++, S--) {
      let P = i[S], A;
      if ((0, zt.isIdentifier)(P))
        A = P.name;
      else if ((0, zt.isStringLiteral)(P))
        A = P.value;
      else if ((0, zt.isThisExpression)(P))
        A = "this";
      else
        return false;
      if (n[y] !== A)
        return false;
    }
    return true;
  }
});
var zn = x((Gn) => {
  "use strict";
  o();
  Object.defineProperty(Gn, "__esModule", { value: true });
  Gn.default = GP;
  var $P = $n();
  function GP(e, t) {
    let r = e.split(".");
    return (n) => (0, $P.default)(n, r, t);
  }
});
var rl = x((Lr) => {
  "use strict";
  o();
  Object.defineProperty(Lr, "__esModule", { value: true });
  Lr.default = void 0;
  var zP = zn(), HP = (0, zP.default)("React.Component"), _2 = Lr.default = HP;
});
var nl = x((Hn) => {
  "use strict";
  o();
  Object.defineProperty(Hn, "__esModule", { value: true });
  Hn.default = QP;
  function QP(e) {
    return !!e && /^[a-z]/.test(e);
  }
});
var il = x((C2, al) => {
  "use strict";
  o();
  var Ht = null;
  function Qt(e) {
    if (Ht !== null && typeof Ht.property) {
      let t = Ht;
      return Ht = Qt.prototype = null, t;
    }
    return Ht = Qt.prototype = e == null ? /* @__PURE__ */ Object.create(null) : e, new Qt();
  }
  Qt();
  al.exports = function(t) {
    return Qt(t);
  };
});
var jr = x((Qn) => {
  "use strict";
  o();
  Object.defineProperty(Qn, "__esModule", { value: true });
  Qn.default = ZP;
  var sl = je();
  function ZP(e, t) {
    if (e === t)
      return true;
    if (e == null || sl.ALIAS_KEYS[t])
      return false;
    let r = sl.FLIPPED_ALIAS_KEYS[t];
    if (r) {
      if (r[0] === e)
        return true;
      for (let n of r)
        if (e === n)
          return true;
    }
    return false;
  }
});
var ea = x((Zn) => {
  "use strict";
  o();
  Object.defineProperty(Zn, "__esModule", { value: true });
  Zn.default = tx;
  var ex = je();
  function tx(e, t) {
    if (e === t)
      return true;
    let r = ex.PLACEHOLDERS_ALIAS[e];
    if (r) {
      for (let n of r)
        if (t === n)
          return true;
    }
    return false;
  }
});
var gt = x((ta) => {
  "use strict";
  o();
  Object.defineProperty(ta, "__esModule", { value: true });
  ta.default = sx;
  var rx = wr(), nx = jr(), ax = ea(), ix = je();
  function sx(e, t, r) {
    return t ? (0, nx.default)(t.type, e) ? typeof r == "undefined" ? true : (0, rx.default)(t, r) : !r && t.type === "Placeholder" && e in ix.FLIPPED_ALIAS_KEYS ? (0, ax.default)(t.expectedNode, e) : false : false;
  }
});
var fl = x((Zt) => {
  "use strict";
  o();
  Object.defineProperty(Zt, "__esModule", { value: true });
  Zt.isIdentifierChar = cl;
  Zt.isIdentifierName = cx;
  Zt.isIdentifierStart = ll;
  var na = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟊꟐꟑꟓꟕ-ꟙꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ", ol = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࢘-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‌‍‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯・꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿･", ox = new RegExp("[" + na + "]"), ux = new RegExp("[" + na + ol + "]");
  na = ol = null;
  var ul = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], lx = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  function ra(e, t) {
    let r = 65536;
    for (let n = 0, i = t.length; n < i; n += 2) {
      if (r += t[n], r > e)
        return false;
      if (r += t[n + 1], r >= e)
        return true;
    }
    return false;
  }
  function ll(e) {
    return e < 65 ? e === 36 : e <= 90 ? true : e < 97 ? e === 95 : e <= 122 ? true : e <= 65535 ? e >= 170 && ox.test(String.fromCharCode(e)) : ra(e, ul);
  }
  function cl(e) {
    return e < 48 ? e === 36 : e < 58 ? true : e < 65 ? false : e <= 90 ? true : e < 97 ? e === 95 : e <= 122 ? true : e <= 65535 ? e >= 170 && ux.test(String.fromCharCode(e)) : ra(e, ul) || ra(e, lx);
  }
  function cx(e) {
    let t = true;
    for (let r = 0; r < e.length; r++) {
      let n = e.charCodeAt(r);
      if ((n & 64512) === 55296 && r + 1 < e.length) {
        let i = e.charCodeAt(++r);
        (i & 64512) === 56320 && (n = 65536 + ((n & 1023) << 10) + (i & 1023));
      }
      if (t) {
        if (t = false, !ll(n))
          return false;
      } else if (!cl(n))
        return false;
    }
    return !t;
  }
});
var ml = x((it) => {
  "use strict";
  o();
  Object.defineProperty(it, "__esModule", { value: true });
  it.isKeyword = mx;
  it.isReservedWord = pl;
  it.isStrictBindOnlyReservedWord = yl;
  it.isStrictBindReservedWord = yx;
  it.isStrictReservedWord = dl;
  var aa = { keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"], strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"], strictBind: ["eval", "arguments"] }, fx = new Set(aa.keyword), px = new Set(aa.strict), dx = new Set(aa.strictBind);
  function pl(e, t) {
    return t && e === "await" || e === "enum";
  }
  function dl(e, t) {
    return pl(e, t) || px.has(e);
  }
  function yl(e) {
    return dx.has(e);
  }
  function yx(e, t) {
    return dl(e, t) || yl(e);
  }
  function mx(e) {
    return fx.has(e);
  }
});
var Rr = x((qe) => {
  "use strict";
  o();
  Object.defineProperty(qe, "__esModule", { value: true });
  Object.defineProperty(qe, "isIdentifierChar", { enumerable: true, get: function() {
    return ia.isIdentifierChar;
  } });
  Object.defineProperty(qe, "isIdentifierName", { enumerable: true, get: function() {
    return ia.isIdentifierName;
  } });
  Object.defineProperty(qe, "isIdentifierStart", { enumerable: true, get: function() {
    return ia.isIdentifierStart;
  } });
  Object.defineProperty(qe, "isKeyword", { enumerable: true, get: function() {
    return er.isKeyword;
  } });
  Object.defineProperty(qe, "isReservedWord", { enumerable: true, get: function() {
    return er.isReservedWord;
  } });
  Object.defineProperty(qe, "isStrictBindOnlyReservedWord", { enumerable: true, get: function() {
    return er.isStrictBindOnlyReservedWord;
  } });
  Object.defineProperty(qe, "isStrictBindReservedWord", { enumerable: true, get: function() {
    return er.isStrictBindReservedWord;
  } });
  Object.defineProperty(qe, "isStrictReservedWord", { enumerable: true, get: function() {
    return er.isStrictReservedWord;
  } });
  var ia = fl(), er = ml();
});
var ht = x((oa) => {
  "use strict";
  o();
  Object.defineProperty(oa, "__esModule", { value: true });
  oa.default = Tx;
  var sa = Rr();
  function Tx(e, t = true) {
    return typeof e != "string" || t && ((0, sa.isKeyword)(e) || (0, sa.isStrictReservedWord)(e, true)) ? false : (0, sa.isIdentifierName)(e);
  }
});
var El = x((tr) => {
  "use strict";
  o();
  Object.defineProperty(tr, "__esModule", { value: true });
  tr.readCodePoint = bl;
  tr.readInt = Sl;
  tr.readStringContents = bx;
  var Sx = function(t) {
    return t >= 48 && t <= 57;
  }, Tl = { decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]), hex: /* @__PURE__ */ new Set([46, 88, 95, 120]) }, Mr = { bin: (e) => e === 48 || e === 49, oct: (e) => e >= 48 && e <= 55, dec: (e) => e >= 48 && e <= 57, hex: (e) => e >= 48 && e <= 57 || e >= 65 && e <= 70 || e >= 97 && e <= 102 };
  function bx(e, t, r, n, i, l) {
    let y = r, S = n, P = i, A = "", L = null, D = r, { length: te } = t;
    for (; ; ) {
      if (r >= te) {
        l.unterminated(y, S, P), A += t.slice(D, r);
        break;
      }
      let X = t.charCodeAt(r);
      if (Ex(e, X, t, r)) {
        A += t.slice(D, r);
        break;
      }
      if (X === 92) {
        A += t.slice(D, r);
        let ie = vx(t, r, n, i, e === "template", l);
        ie.ch === null && !L ? L = { pos: r, lineStart: n, curLine: i } : A += ie.ch, { pos: r, lineStart: n, curLine: i } = ie, D = r;
      } else
        X === 8232 || X === 8233 ? (++r, ++i, n = r) : X === 10 || X === 13 ? e === "template" ? (A += t.slice(D, r) + `
`, ++r, X === 13 && t.charCodeAt(r) === 10 && ++r, ++i, D = n = r) : l.unterminated(y, S, P) : ++r;
    }
    return { pos: r, str: A, firstInvalidLoc: L, lineStart: n, curLine: i, containsInvalid: !!L };
  }
  function Ex(e, t, r, n) {
    return e === "template" ? t === 96 || t === 36 && r.charCodeAt(n + 1) === 123 : t === (e === "double" ? 34 : 39);
  }
  function vx(e, t, r, n, i, l) {
    let y = !i;
    t++;
    let S = (A) => ({ pos: t, ch: A, lineStart: r, curLine: n }), P = e.charCodeAt(t++);
    switch (P) {
      case 110:
        return S(`
`);
      case 114:
        return S("\r");
      case 120: {
        let A;
        return { code: A, pos: t } = ua(e, t, r, n, 2, false, y, l), S(A === null ? null : String.fromCharCode(A));
      }
      case 117: {
        let A;
        return { code: A, pos: t } = bl(e, t, r, n, y, l), S(A === null ? null : String.fromCodePoint(A));
      }
      case 116:
        return S("	");
      case 98:
        return S("\b");
      case 118:
        return S("\v");
      case 102:
        return S("\f");
      case 13:
        e.charCodeAt(t) === 10 && ++t;
      case 10:
        r = t, ++n;
      case 8232:
      case 8233:
        return S("");
      case 56:
      case 57:
        if (i)
          return S(null);
        l.strictNumericEscape(t - 1, r, n);
      default:
        if (P >= 48 && P <= 55) {
          let A = t - 1, D = e.slice(A, t + 2).match(/^[0-7]+/)[0], te = parseInt(D, 8);
          te > 255 && (D = D.slice(0, -1), te = parseInt(D, 8)), t += D.length - 1;
          let X = e.charCodeAt(t);
          if (D !== "0" || X === 56 || X === 57) {
            if (i)
              return S(null);
            l.strictNumericEscape(A, r, n);
          }
          return S(String.fromCharCode(te));
        }
        return S(String.fromCharCode(P));
    }
  }
  function ua(e, t, r, n, i, l, y, S) {
    let P = t, A;
    return { n: A, pos: t } = Sl(e, t, r, n, 16, i, l, false, S, !y), A === null && (y ? S.invalidEscapeSequence(P, r, n) : t = P - 1), { code: A, pos: t };
  }
  function Sl(e, t, r, n, i, l, y, S, P, A) {
    let L = t, D = i === 16 ? Tl.hex : Tl.decBinOct, te = i === 16 ? Mr.hex : i === 10 ? Mr.dec : i === 8 ? Mr.oct : Mr.bin, X = false, ie = 0;
    for (let Re = 0, fe = l == null ? 1 / 0 : l; Re < fe; ++Re) {
      let W = e.charCodeAt(t), $;
      if (W === 95 && S !== "bail") {
        let J = e.charCodeAt(t - 1), j = e.charCodeAt(t + 1);
        if (S) {
          if (Number.isNaN(j) || !te(j) || D.has(J) || D.has(j)) {
            if (A)
              return { n: null, pos: t };
            P.unexpectedNumericSeparator(t, r, n);
          }
        } else {
          if (A)
            return { n: null, pos: t };
          P.numericSeparatorInEscapeSequence(t, r, n);
        }
        ++t;
        continue;
      }
      if (W >= 97 ? $ = W - 97 + 10 : W >= 65 ? $ = W - 65 + 10 : Sx(W) ? $ = W - 48 : $ = 1 / 0, $ >= i) {
        if ($ <= 9 && A)
          return { n: null, pos: t };
        if ($ <= 9 && P.invalidDigit(t, r, n, i))
          $ = 0;
        else if (y)
          $ = 0, X = true;
        else
          break;
      }
      ++t, ie = ie * i + $;
    }
    return t === L || l != null && t - L !== l || X ? { n: null, pos: t } : { n: ie, pos: t };
  }
  function bl(e, t, r, n, i, l) {
    let y = e.charCodeAt(t), S;
    if (y === 123) {
      if (++t, { code: S, pos: t } = ua(e, t, r, n, e.indexOf("}", t) - t, true, i, l), ++t, S !== null && S > 1114111)
        if (i)
          l.invalidCodePoint(t, r, n);
        else
          return { code: null, pos: t };
    } else
      ({ code: S, pos: t } = ua(e, t, r, n, 4, false, i, l));
    return { code: S, pos: t };
  }
});
var Ge = x((U) => {
  "use strict";
  o();
  Object.defineProperty(U, "__esModule", { value: true });
  U.UPDATE_OPERATORS = U.UNARY_OPERATORS = U.STRING_UNARY_OPERATORS = U.STATEMENT_OR_BLOCK_KEYS = U.NUMBER_UNARY_OPERATORS = U.NUMBER_BINARY_OPERATORS = U.NOT_LOCAL_BINDING = U.LOGICAL_OPERATORS = U.INHERIT_KEYS = U.FOR_INIT_KEYS = U.FLATTENABLE_KEYS = U.EQUALITY_BINARY_OPERATORS = U.COMPARISON_BINARY_OPERATORS = U.COMMENT_KEYS = U.BOOLEAN_UNARY_OPERATORS = U.BOOLEAN_NUMBER_BINARY_OPERATORS = U.BOOLEAN_BINARY_OPERATORS = U.BLOCK_SCOPED_SYMBOL = U.BINARY_OPERATORS = U.ASSIGNMENT_OPERATORS = void 0;
  var K2 = U.STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"], q2 = U.FLATTENABLE_KEYS = ["body", "expressions"], Y2 = U.FOR_INIT_KEYS = ["left", "init"], V2 = U.COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"], Px = U.LOGICAL_OPERATORS = ["||", "&&", "??"], U2 = U.UPDATE_OPERATORS = ["++", "--"], xx = U.BOOLEAN_NUMBER_BINARY_OPERATORS = [">", "<", ">=", "<="], gx = U.EQUALITY_BINARY_OPERATORS = ["==", "===", "!=", "!=="], hx = U.COMPARISON_BINARY_OPERATORS = [...gx, "in", "instanceof"], Ax = U.BOOLEAN_BINARY_OPERATORS = [...hx, ...xx], vl = U.NUMBER_BINARY_OPERATORS = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"], J2 = U.BINARY_OPERATORS = ["+", ...vl, ...Ax, "|>"], X2 = U.ASSIGNMENT_OPERATORS = ["=", "+=", ...vl.map((e) => e + "="), ...Px.map((e) => e + "=")], Ox = U.BOOLEAN_UNARY_OPERATORS = ["delete", "!"], Ix = U.NUMBER_UNARY_OPERATORS = ["+", "-", "~"], _x = U.STRING_UNARY_OPERATORS = ["typeof"], W2 = U.UNARY_OPERATORS = ["void", "throw", ...Ox, ...Ix, ..._x], $2 = U.INHERIT_KEYS = { optional: ["typeAnnotation", "typeParameters", "returnType"], force: ["start", "loc", "end"] }, G2 = U.BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped"), z2 = U.NOT_LOCAL_BINDING = Symbol.for("should not be considered a local binding");
});
var Ve = x((Z) => {
  "use strict";
  o();
  Object.defineProperty(Z, "__esModule", { value: true });
  Z.VISITOR_KEYS = Z.NODE_PARENT_VALIDATIONS = Z.NODE_FIELDS = Z.FLIPPED_ALIAS_KEYS = Z.DEPRECATED_KEYS = Z.BUILDER_KEYS = Z.ALIAS_KEYS = void 0;
  Z.arrayOf = xl;
  Z.arrayOfType = gl;
  Z.assertEach = hl;
  Z.assertNodeOrValueType = Kx;
  Z.assertNodeType = ca;
  Z.assertOneOf = kx;
  Z.assertOptionalChainStart = Yx;
  Z.assertShape = qx;
  Z.assertValueType = da;
  Z.chain = Al;
  Z.default = Ol;
  Z.defineAliasedType = Jx;
  Z.typeIs = kr;
  Z.validate = pa;
  Z.validateArrayOfType = Fx;
  Z.validateOptional = Mx;
  Z.validateOptionalType = Bx;
  Z.validateType = Rx;
  var Pl = gt(), Fr = Kr(), Dx = Z.VISITOR_KEYS = {}, Nx = Z.ALIAS_KEYS = {}, la = Z.FLIPPED_ALIAS_KEYS = {}, Cx = Z.NODE_FIELDS = {}, wx = Z.BUILDER_KEYS = {}, Lx = Z.DEPRECATED_KEYS = {}, jx = Z.NODE_PARENT_VALIDATIONS = {};
  function Br(e) {
    return Array.isArray(e) ? "array" : e === null ? "null" : typeof e;
  }
  function pa(e) {
    return { validate: e };
  }
  function kr(e) {
    return typeof e == "string" ? ca(e) : ca(...e);
  }
  function Rx(e) {
    return pa(kr(e));
  }
  function Mx(e) {
    return { validate: e, optional: true };
  }
  function Bx(e) {
    return { validate: kr(e), optional: true };
  }
  function xl(e) {
    return Al(da("array"), hl(e));
  }
  function gl(e) {
    return xl(kr(e));
  }
  function Fx(e) {
    return pa(gl(e));
  }
  function hl(e) {
    function t(r, n, i) {
      if (!!Array.isArray(i))
        for (let l = 0; l < i.length; l++) {
          let y = `${n}[${l}]`, S = i[l];
          e(r, y, S), E.BABEL_TYPES_8_BREAKING && (0, Fr.validateChild)(r, y, S);
        }
    }
    return t.each = e, t;
  }
  function kx(...e) {
    function t(r, n, i) {
      if (e.indexOf(i) < 0)
        throw new TypeError(`Property ${n} expected value to be one of ${JSON.stringify(e)} but got ${JSON.stringify(i)}`);
    }
    return t.oneOf = e, t;
  }
  function ca(...e) {
    function t(r, n, i) {
      for (let l of e)
        if ((0, Pl.default)(l, i)) {
          (0, Fr.validateChild)(r, n, i);
          return;
        }
      throw new TypeError(`Property ${n} of ${r.type} expected node to be of a type ${JSON.stringify(e)} but instead got ${JSON.stringify(i == null ? void 0 : i.type)}`);
    }
    return t.oneOfNodeTypes = e, t;
  }
  function Kx(...e) {
    function t(r, n, i) {
      for (let l of e)
        if (Br(i) === l || (0, Pl.default)(l, i)) {
          (0, Fr.validateChild)(r, n, i);
          return;
        }
      throw new TypeError(`Property ${n} of ${r.type} expected node to be of a type ${JSON.stringify(e)} but instead got ${JSON.stringify(i == null ? void 0 : i.type)}`);
    }
    return t.oneOfNodeOrValueTypes = e, t;
  }
  function da(e) {
    function t(r, n, i) {
      if (!(Br(i) === e))
        throw new TypeError(`Property ${n} expected type of ${e} but got ${Br(i)}`);
    }
    return t.type = e, t;
  }
  function qx(e) {
    function t(r, n, i) {
      let l = [];
      for (let y of Object.keys(e))
        try {
          (0, Fr.validateField)(r, y, i[y], e[y]);
        } catch (S) {
          if (S instanceof TypeError) {
            l.push(S.message);
            continue;
          }
          throw S;
        }
      if (l.length)
        throw new TypeError(`Property ${n} of ${r.type} expected to have the following:
${l.join(`
`)}`);
    }
    return t.shapeOf = e, t;
  }
  function Yx() {
    function e(t) {
      var r;
      let n = t;
      for (; t; ) {
        let { type: i } = n;
        if (i === "OptionalCallExpression") {
          if (n.optional)
            return;
          n = n.callee;
          continue;
        }
        if (i === "OptionalMemberExpression") {
          if (n.optional)
            return;
          n = n.object;
          continue;
        }
        break;
      }
      throw new TypeError(`Non-optional ${t.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${(r = n) == null ? void 0 : r.type}`);
    }
    return e;
  }
  function Al(...e) {
    function t(...r) {
      for (let n of e)
        n(...r);
    }
    if (t.chainOf = e, e.length >= 2 && "type" in e[0] && e[0].type === "array" && !("each" in e[1]))
      throw new Error('An assertValueType("array") validator can only be followed by an assertEach(...) validator.');
    return t;
  }
  var Vx = ["aliases", "builder", "deprecatedAlias", "fields", "inherits", "visitor", "validate"], Ux = ["default", "optional", "deprecated", "validate"], fa = {};
  function Jx(...e) {
    return (t, r = {}) => {
      let n = r.aliases;
      if (!n) {
        var i, l;
        r.inherits && (n = (i = fa[r.inherits].aliases) == null ? void 0 : i.slice()), (l = n) != null || (n = []), r.aliases = n;
      }
      let y = e.filter((S) => !n.includes(S));
      n.unshift(...y), Ol(t, r);
    };
  }
  function Ol(e, t = {}) {
    let r = t.inherits && fa[t.inherits] || {}, n = t.fields;
    if (!n && (n = {}, r.fields)) {
      let S = Object.getOwnPropertyNames(r.fields);
      for (let P of S) {
        let A = r.fields[P], L = A.default;
        if (Array.isArray(L) ? L.length > 0 : L && typeof L == "object")
          throw new Error("field defaults can only be primitives or empty arrays currently");
        n[P] = { default: Array.isArray(L) ? [] : L, optional: A.optional, deprecated: A.deprecated, validate: A.validate };
      }
    }
    let i = t.visitor || r.visitor || [], l = t.aliases || r.aliases || [], y = t.builder || r.builder || t.visitor || [];
    for (let S of Object.keys(t))
      if (Vx.indexOf(S) === -1)
        throw new Error(`Unknown type option "${S}" on ${e}`);
    t.deprecatedAlias && (Lx[t.deprecatedAlias] = e);
    for (let S of i.concat(y))
      n[S] = n[S] || {};
    for (let S of Object.keys(n)) {
      let P = n[S];
      P.default !== void 0 && y.indexOf(S) === -1 && (P.optional = true), P.default === void 0 ? P.default = null : !P.validate && P.default != null && (P.validate = da(Br(P.default)));
      for (let A of Object.keys(P))
        if (Ux.indexOf(A) === -1)
          throw new Error(`Unknown field key "${A}" on ${e}.${S}`);
    }
    Dx[e] = t.visitor = i, wx[e] = t.builder = y, Cx[e] = t.fields = n, Nx[e] = t.aliases = l, l.forEach((S) => {
      la[S] = la[S] || [], la[S].push(e);
    }), t.validate && (jx[e] = t.validate), fa[e] = t;
  }
});
var ma = x((De) => {
  "use strict";
  o();
  Object.defineProperty(De, "__esModule", { value: true });
  De.patternLikeCommon = De.functionTypeAnnotationCommon = De.functionDeclarationCommon = De.functionCommon = De.classMethodOrPropertyCommon = De.classMethodOrDeclareMethodCommon = void 0;
  var xe = gt(), Xx = ht(), Il = Rr(), Wx = El(), rr = Ge(), s = Ve(), N = (0, s.defineAliasedType)("Standardized");
  N("ArrayExpression", { fields: { elements: { validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeOrValueType)("null", "Expression", "SpreadElement"))), default: E.BABEL_TYPES_8_BREAKING ? void 0 : [] } }, visitor: ["elements"], aliases: ["Expression"] });
  N("AssignmentExpression", { fields: { operator: { validate: function() {
    if (!E.BABEL_TYPES_8_BREAKING)
      return (0, s.assertValueType)("string");
    let e = (0, s.assertOneOf)(...rr.ASSIGNMENT_OPERATORS), t = (0, s.assertOneOf)("=");
    return function(r, n, i) {
      ((0, xe.default)("Pattern", r.left) ? t : e)(r, n, i);
    };
  }() }, left: { validate: E.BABEL_TYPES_8_BREAKING ? (0, s.assertNodeType)("Identifier", "MemberExpression", "OptionalMemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, s.assertNodeType)("LVal", "OptionalMemberExpression") }, right: { validate: (0, s.assertNodeType)("Expression") } }, builder: ["operator", "left", "right"], visitor: ["left", "right"], aliases: ["Expression"] });
  N("BinaryExpression", { builder: ["operator", "left", "right"], fields: { operator: { validate: (0, s.assertOneOf)(...rr.BINARY_OPERATORS) }, left: { validate: function() {
    let e = (0, s.assertNodeType)("Expression"), t = (0, s.assertNodeType)("Expression", "PrivateName");
    return Object.assign(function(n, i, l) {
      (n.operator === "in" ? t : e)(n, i, l);
    }, { oneOfNodeTypes: ["Expression", "PrivateName"] });
  }() }, right: { validate: (0, s.assertNodeType)("Expression") } }, visitor: ["left", "right"], aliases: ["Binary", "Expression"] });
  N("InterpreterDirective", { builder: ["value"], fields: { value: { validate: (0, s.assertValueType)("string") } } });
  N("Directive", { visitor: ["value"], fields: { value: { validate: (0, s.assertNodeType)("DirectiveLiteral") } } });
  N("DirectiveLiteral", { builder: ["value"], fields: { value: { validate: (0, s.assertValueType)("string") } } });
  N("BlockStatement", { builder: ["body", "directives"], visitor: ["directives", "body"], fields: { directives: { validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("Directive"))), default: [] }, body: { validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("Statement"))) } }, aliases: ["Scopable", "BlockParent", "Block", "Statement"] });
  N("BreakStatement", { visitor: ["label"], fields: { label: { validate: (0, s.assertNodeType)("Identifier"), optional: true } }, aliases: ["Statement", "Terminatorless", "CompletionStatement"] });
  N("CallExpression", { visitor: ["callee", "arguments", "typeParameters", "typeArguments"], builder: ["callee", "arguments"], aliases: ["Expression"], fields: Object.assign({ callee: { validate: (0, s.assertNodeType)("Expression", "Super", "V8IntrinsicIdentifier") }, arguments: { validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder"))) } }, E.BABEL_TYPES_8_BREAKING ? {} : { optional: { validate: (0, s.assertOneOf)(true, false), optional: true } }, { typeArguments: { validate: (0, s.assertNodeType)("TypeParameterInstantiation"), optional: true }, typeParameters: { validate: (0, s.assertNodeType)("TSTypeParameterInstantiation"), optional: true } }) });
  N("CatchClause", { visitor: ["param", "body"], fields: { param: { validate: (0, s.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"), optional: true }, body: { validate: (0, s.assertNodeType)("BlockStatement") } }, aliases: ["Scopable", "BlockParent"] });
  N("ConditionalExpression", { visitor: ["test", "consequent", "alternate"], fields: { test: { validate: (0, s.assertNodeType)("Expression") }, consequent: { validate: (0, s.assertNodeType)("Expression") }, alternate: { validate: (0, s.assertNodeType)("Expression") } }, aliases: ["Expression", "Conditional"] });
  N("ContinueStatement", { visitor: ["label"], fields: { label: { validate: (0, s.assertNodeType)("Identifier"), optional: true } }, aliases: ["Statement", "Terminatorless", "CompletionStatement"] });
  N("DebuggerStatement", { aliases: ["Statement"] });
  N("DoWhileStatement", { visitor: ["test", "body"], fields: { test: { validate: (0, s.assertNodeType)("Expression") }, body: { validate: (0, s.assertNodeType)("Statement") } }, aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"] });
  N("EmptyStatement", { aliases: ["Statement"] });
  N("ExpressionStatement", { visitor: ["expression"], fields: { expression: { validate: (0, s.assertNodeType)("Expression") } }, aliases: ["Statement", "ExpressionWrapper"] });
  N("File", { builder: ["program", "comments", "tokens"], visitor: ["program"], fields: { program: { validate: (0, s.assertNodeType)("Program") }, comments: { validate: E.BABEL_TYPES_8_BREAKING ? (0, s.assertEach)((0, s.assertNodeType)("CommentBlock", "CommentLine")) : Object.assign(() => {
  }, { each: { oneOfNodeTypes: ["CommentBlock", "CommentLine"] } }), optional: true }, tokens: { validate: (0, s.assertEach)(Object.assign(() => {
  }, { type: "any" })), optional: true } } });
  N("ForInStatement", { visitor: ["left", "right", "body"], aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"], fields: { left: { validate: E.BABEL_TYPES_8_BREAKING ? (0, s.assertNodeType)("VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, s.assertNodeType)("VariableDeclaration", "LVal") }, right: { validate: (0, s.assertNodeType)("Expression") }, body: { validate: (0, s.assertNodeType)("Statement") } } });
  N("ForStatement", { visitor: ["init", "test", "update", "body"], aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"], fields: { init: { validate: (0, s.assertNodeType)("VariableDeclaration", "Expression"), optional: true }, test: { validate: (0, s.assertNodeType)("Expression"), optional: true }, update: { validate: (0, s.assertNodeType)("Expression"), optional: true }, body: { validate: (0, s.assertNodeType)("Statement") } } });
  var At = () => ({ params: { validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("Identifier", "Pattern", "RestElement"))) }, generator: { default: false }, async: { default: false } });
  De.functionCommon = At;
  var st = () => ({ returnType: { validate: (0, s.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"), optional: true }, typeParameters: { validate: (0, s.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"), optional: true } });
  De.functionTypeAnnotationCommon = st;
  var _l = () => Object.assign({}, At(), { declare: { validate: (0, s.assertValueType)("boolean"), optional: true }, id: { validate: (0, s.assertNodeType)("Identifier"), optional: true } });
  De.functionDeclarationCommon = _l;
  N("FunctionDeclaration", { builder: ["id", "params", "body", "generator", "async"], visitor: ["id", "params", "body", "returnType", "typeParameters"], fields: Object.assign({}, _l(), st(), { body: { validate: (0, s.assertNodeType)("BlockStatement") }, predicate: { validate: (0, s.assertNodeType)("DeclaredPredicate", "InferredPredicate"), optional: true } }), aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"], validate: function() {
    if (!E.BABEL_TYPES_8_BREAKING)
      return () => {
      };
    let e = (0, s.assertNodeType)("Identifier");
    return function(t, r, n) {
      (0, xe.default)("ExportDefaultDeclaration", t) || e(n, "id", n.id);
    };
  }() });
  N("FunctionExpression", { inherits: "FunctionDeclaration", aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"], fields: Object.assign({}, At(), st(), { id: { validate: (0, s.assertNodeType)("Identifier"), optional: true }, body: { validate: (0, s.assertNodeType)("BlockStatement") }, predicate: { validate: (0, s.assertNodeType)("DeclaredPredicate", "InferredPredicate"), optional: true } }) });
  var Ot = () => ({ typeAnnotation: { validate: (0, s.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"), optional: true }, optional: { validate: (0, s.assertValueType)("boolean"), optional: true }, decorators: { validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("Decorator"))), optional: true } });
  De.patternLikeCommon = Ot;
  N("Identifier", { builder: ["name"], visitor: ["typeAnnotation", "decorators"], aliases: ["Expression", "PatternLike", "LVal", "TSEntityName"], fields: Object.assign({}, Ot(), { name: { validate: (0, s.chain)((0, s.assertValueType)("string"), Object.assign(function(e, t, r) {
    if (!!E.BABEL_TYPES_8_BREAKING && !(0, Xx.default)(r, false))
      throw new TypeError(`"${r}" is not a valid identifier name`);
  }, { type: "string" })) } }), validate(e, t, r) {
    if (!E.BABEL_TYPES_8_BREAKING)
      return;
    let n = /\.(\w+)$/.exec(t);
    if (!n)
      return;
    let [, i] = n, l = { computed: false };
    if (i === "property") {
      if ((0, xe.default)("MemberExpression", e, l) || (0, xe.default)("OptionalMemberExpression", e, l))
        return;
    } else if (i === "key") {
      if ((0, xe.default)("Property", e, l) || (0, xe.default)("Method", e, l))
        return;
    } else if (i === "exported") {
      if ((0, xe.default)("ExportSpecifier", e))
        return;
    } else if (i === "imported") {
      if ((0, xe.default)("ImportSpecifier", e, { imported: r }))
        return;
    } else if (i === "meta" && (0, xe.default)("MetaProperty", e, { meta: r }))
      return;
    if (((0, Il.isKeyword)(r.name) || (0, Il.isReservedWord)(r.name, false)) && r.name !== "this")
      throw new TypeError(`"${r.name}" is not a valid identifier`);
  } });
  N("IfStatement", { visitor: ["test", "consequent", "alternate"], aliases: ["Statement", "Conditional"], fields: { test: { validate: (0, s.assertNodeType)("Expression") }, consequent: { validate: (0, s.assertNodeType)("Statement") }, alternate: { optional: true, validate: (0, s.assertNodeType)("Statement") } } });
  N("LabeledStatement", { visitor: ["label", "body"], aliases: ["Statement"], fields: { label: { validate: (0, s.assertNodeType)("Identifier") }, body: { validate: (0, s.assertNodeType)("Statement") } } });
  N("StringLiteral", { builder: ["value"], fields: { value: { validate: (0, s.assertValueType)("string") } }, aliases: ["Expression", "Pureish", "Literal", "Immutable"] });
  N("NumericLiteral", { builder: ["value"], deprecatedAlias: "NumberLiteral", fields: { value: { validate: (0, s.chain)((0, s.assertValueType)("number"), Object.assign(function(e, t, r) {
    if (1 / r < 0 || !Number.isFinite(r)) {
      let n = new Error(`NumericLiterals must be non-negative finite numbers. You can use t.valueToNode(${r}) instead.`);
    }
  }, { type: "number" })) } }, aliases: ["Expression", "Pureish", "Literal", "Immutable"] });
  N("NullLiteral", { aliases: ["Expression", "Pureish", "Literal", "Immutable"] });
  N("BooleanLiteral", { builder: ["value"], fields: { value: { validate: (0, s.assertValueType)("boolean") } }, aliases: ["Expression", "Pureish", "Literal", "Immutable"] });
  N("RegExpLiteral", { builder: ["pattern", "flags"], deprecatedAlias: "RegexLiteral", aliases: ["Expression", "Pureish", "Literal"], fields: { pattern: { validate: (0, s.assertValueType)("string") }, flags: { validate: (0, s.chain)((0, s.assertValueType)("string"), Object.assign(function(e, t, r) {
    if (!E.BABEL_TYPES_8_BREAKING)
      return;
    let n = /[^gimsuy]/.exec(r);
    if (n)
      throw new TypeError(`"${n[0]}" is not a valid RegExp flag`);
  }, { type: "string" })), default: "" } } });
  N("LogicalExpression", { builder: ["operator", "left", "right"], visitor: ["left", "right"], aliases: ["Binary", "Expression"], fields: { operator: { validate: (0, s.assertOneOf)(...rr.LOGICAL_OPERATORS) }, left: { validate: (0, s.assertNodeType)("Expression") }, right: { validate: (0, s.assertNodeType)("Expression") } } });
  N("MemberExpression", { builder: ["object", "property", "computed", ...E.BABEL_TYPES_8_BREAKING ? [] : ["optional"]], visitor: ["object", "property"], aliases: ["Expression", "LVal"], fields: Object.assign({ object: { validate: (0, s.assertNodeType)("Expression", "Super") }, property: { validate: function() {
    let e = (0, s.assertNodeType)("Identifier", "PrivateName"), t = (0, s.assertNodeType)("Expression"), r = function(n, i, l) {
      (n.computed ? t : e)(n, i, l);
    };
    return r.oneOfNodeTypes = ["Expression", "Identifier", "PrivateName"], r;
  }() }, computed: { default: false } }, E.BABEL_TYPES_8_BREAKING ? {} : { optional: { validate: (0, s.assertOneOf)(true, false), optional: true } }) });
  N("NewExpression", { inherits: "CallExpression" });
  N("Program", { visitor: ["directives", "body"], builder: ["body", "directives", "sourceType", "interpreter"], fields: { sourceFile: { validate: (0, s.assertValueType)("string") }, sourceType: { validate: (0, s.assertOneOf)("script", "module"), default: "script" }, interpreter: { validate: (0, s.assertNodeType)("InterpreterDirective"), default: null, optional: true }, directives: { validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("Directive"))), default: [] }, body: { validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("Statement"))) } }, aliases: ["Scopable", "BlockParent", "Block"] });
  N("ObjectExpression", { visitor: ["properties"], aliases: ["Expression"], fields: { properties: { validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("ObjectMethod", "ObjectProperty", "SpreadElement"))) } } });
  N("ObjectMethod", { builder: ["kind", "key", "params", "body", "computed", "generator", "async"], fields: Object.assign({}, At(), st(), { kind: Object.assign({ validate: (0, s.assertOneOf)("method", "get", "set") }, E.BABEL_TYPES_8_BREAKING ? {} : { default: "method" }), computed: { default: false }, key: { validate: function() {
    let e = (0, s.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"), t = (0, s.assertNodeType)("Expression"), r = function(n, i, l) {
      (n.computed ? t : e)(n, i, l);
    };
    return r.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"], r;
  }() }, decorators: { validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("Decorator"))), optional: true }, body: { validate: (0, s.assertNodeType)("BlockStatement") } }), visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"], aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"] });
  N("ObjectProperty", { builder: ["key", "value", "computed", "shorthand", ...E.BABEL_TYPES_8_BREAKING ? [] : ["decorators"]], fields: { computed: { default: false }, key: { validate: function() {
    let e = (0, s.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"), t = (0, s.assertNodeType)("Expression");
    return Object.assign(function(n, i, l) {
      (n.computed ? t : e)(n, i, l);
    }, { oneOfNodeTypes: ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"] });
  }() }, value: { validate: (0, s.assertNodeType)("Expression", "PatternLike") }, shorthand: { validate: (0, s.chain)((0, s.assertValueType)("boolean"), Object.assign(function(e, t, r) {
    if (!!E.BABEL_TYPES_8_BREAKING && r && e.computed)
      throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true");
  }, { type: "boolean" }), function(e, t, r) {
    if (!!E.BABEL_TYPES_8_BREAKING && r && !(0, xe.default)("Identifier", e.key))
      throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier");
  }), default: false }, decorators: { validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("Decorator"))), optional: true } }, visitor: ["key", "value", "decorators"], aliases: ["UserWhitespacable", "Property", "ObjectMember"], validate: function() {
    let e = (0, s.assertNodeType)("Identifier", "Pattern", "TSAsExpression", "TSSatisfiesExpression", "TSNonNullExpression", "TSTypeAssertion"), t = (0, s.assertNodeType)("Expression");
    return function(r, n, i) {
      if (!E.BABEL_TYPES_8_BREAKING)
        return;
      ((0, xe.default)("ObjectPattern", r) ? e : t)(i, "value", i.value);
    };
  }() });
  N("RestElement", { visitor: ["argument", "typeAnnotation"], builder: ["argument"], aliases: ["LVal", "PatternLike"], deprecatedAlias: "RestProperty", fields: Object.assign({}, Ot(), { argument: { validate: E.BABEL_TYPES_8_BREAKING ? (0, s.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, s.assertNodeType)("LVal") } }), validate(e, t) {
    if (!E.BABEL_TYPES_8_BREAKING)
      return;
    let r = /(\w+)\[(\d+)\]/.exec(t);
    if (!r)
      throw new Error("Internal Babel error: malformed key.");
    let [, n, i] = r;
    if (e[n].length > +i + 1)
      throw new TypeError(`RestElement must be last element of ${n}`);
  } });
  N("ReturnStatement", { visitor: ["argument"], aliases: ["Statement", "Terminatorless", "CompletionStatement"], fields: { argument: { validate: (0, s.assertNodeType)("Expression"), optional: true } } });
  N("SequenceExpression", { visitor: ["expressions"], fields: { expressions: { validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("Expression"))) } }, aliases: ["Expression"] });
  N("ParenthesizedExpression", { visitor: ["expression"], aliases: ["Expression", "ExpressionWrapper"], fields: { expression: { validate: (0, s.assertNodeType)("Expression") } } });
  N("SwitchCase", { visitor: ["test", "consequent"], fields: { test: { validate: (0, s.assertNodeType)("Expression"), optional: true }, consequent: { validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("Statement"))) } } });
  N("SwitchStatement", { visitor: ["discriminant", "cases"], aliases: ["Statement", "BlockParent", "Scopable"], fields: { discriminant: { validate: (0, s.assertNodeType)("Expression") }, cases: { validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("SwitchCase"))) } } });
  N("ThisExpression", { aliases: ["Expression"] });
  N("ThrowStatement", { visitor: ["argument"], aliases: ["Statement", "Terminatorless", "CompletionStatement"], fields: { argument: { validate: (0, s.assertNodeType)("Expression") } } });
  N("TryStatement", { visitor: ["block", "handler", "finalizer"], aliases: ["Statement"], fields: { block: { validate: (0, s.chain)((0, s.assertNodeType)("BlockStatement"), Object.assign(function(e) {
    if (!!E.BABEL_TYPES_8_BREAKING && !e.handler && !e.finalizer)
      throw new TypeError("TryStatement expects either a handler or finalizer, or both");
  }, { oneOfNodeTypes: ["BlockStatement"] })) }, handler: { optional: true, validate: (0, s.assertNodeType)("CatchClause") }, finalizer: { optional: true, validate: (0, s.assertNodeType)("BlockStatement") } } });
  N("UnaryExpression", { builder: ["operator", "argument", "prefix"], fields: { prefix: { default: true }, argument: { validate: (0, s.assertNodeType)("Expression") }, operator: { validate: (0, s.assertOneOf)(...rr.UNARY_OPERATORS) } }, visitor: ["argument"], aliases: ["UnaryLike", "Expression"] });
  N("UpdateExpression", { builder: ["operator", "argument", "prefix"], fields: { prefix: { default: false }, argument: { validate: E.BABEL_TYPES_8_BREAKING ? (0, s.assertNodeType)("Identifier", "MemberExpression") : (0, s.assertNodeType)("Expression") }, operator: { validate: (0, s.assertOneOf)(...rr.UPDATE_OPERATORS) } }, visitor: ["argument"], aliases: ["Expression"] });
  N("VariableDeclaration", { builder: ["kind", "declarations"], visitor: ["declarations"], aliases: ["Statement", "Declaration"], fields: { declare: { validate: (0, s.assertValueType)("boolean"), optional: true }, kind: { validate: (0, s.assertOneOf)("var", "let", "const", "using", "await using") }, declarations: { validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("VariableDeclarator"))) } }, validate(e, t, r) {
    if (!!E.BABEL_TYPES_8_BREAKING && !!(0, xe.default)("ForXStatement", e, { left: r }) && r.declarations.length !== 1)
      throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${e.type}`);
  } });
  N("VariableDeclarator", { visitor: ["id", "init"], fields: { id: { validate: function() {
    if (!E.BABEL_TYPES_8_BREAKING)
      return (0, s.assertNodeType)("LVal");
    let e = (0, s.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"), t = (0, s.assertNodeType)("Identifier");
    return function(r, n, i) {
      (r.init ? e : t)(r, n, i);
    };
  }() }, definite: { optional: true, validate: (0, s.assertValueType)("boolean") }, init: { optional: true, validate: (0, s.assertNodeType)("Expression") } } });
  N("WhileStatement", { visitor: ["test", "body"], aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"], fields: { test: { validate: (0, s.assertNodeType)("Expression") }, body: { validate: (0, s.assertNodeType)("Statement") } } });
  N("WithStatement", { visitor: ["object", "body"], aliases: ["Statement"], fields: { object: { validate: (0, s.assertNodeType)("Expression") }, body: { validate: (0, s.assertNodeType)("Statement") } } });
  N("AssignmentPattern", { visitor: ["left", "right", "decorators"], builder: ["left", "right"], aliases: ["Pattern", "PatternLike", "LVal"], fields: Object.assign({}, Ot(), { left: { validate: (0, s.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") }, right: { validate: (0, s.assertNodeType)("Expression") }, decorators: { validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("Decorator"))), optional: true } }) });
  N("ArrayPattern", { visitor: ["elements", "typeAnnotation"], builder: ["elements"], aliases: ["Pattern", "PatternLike", "LVal"], fields: Object.assign({}, Ot(), { elements: { validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeOrValueType)("null", "PatternLike", "LVal"))) } }) });
  N("ArrowFunctionExpression", { builder: ["params", "body", "async"], visitor: ["params", "body", "returnType", "typeParameters"], aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"], fields: Object.assign({}, At(), st(), { expression: { validate: (0, s.assertValueType)("boolean") }, body: { validate: (0, s.assertNodeType)("BlockStatement", "Expression") }, predicate: { validate: (0, s.assertNodeType)("DeclaredPredicate", "InferredPredicate"), optional: true } }) });
  N("ClassBody", { visitor: ["body"], fields: { body: { validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassPrivateProperty", "ClassAccessorProperty", "TSDeclareMethod", "TSIndexSignature", "StaticBlock"))) } } });
  N("ClassExpression", { builder: ["id", "superClass", "body", "decorators"], visitor: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators"], aliases: ["Scopable", "Class", "Expression"], fields: { id: { validate: (0, s.assertNodeType)("Identifier"), optional: true }, typeParameters: { validate: (0, s.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"), optional: true }, body: { validate: (0, s.assertNodeType)("ClassBody") }, superClass: { optional: true, validate: (0, s.assertNodeType)("Expression") }, superTypeParameters: { validate: (0, s.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"), optional: true }, implements: { validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))), optional: true }, decorators: { validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("Decorator"))), optional: true }, mixins: { validate: (0, s.assertNodeType)("InterfaceExtends"), optional: true } } });
  N("ClassDeclaration", { inherits: "ClassExpression", aliases: ["Scopable", "Class", "Statement", "Declaration"], fields: { id: { validate: (0, s.assertNodeType)("Identifier"), optional: true }, typeParameters: { validate: (0, s.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"), optional: true }, body: { validate: (0, s.assertNodeType)("ClassBody") }, superClass: { optional: true, validate: (0, s.assertNodeType)("Expression") }, superTypeParameters: { validate: (0, s.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"), optional: true }, implements: { validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))), optional: true }, decorators: { validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("Decorator"))), optional: true }, mixins: { validate: (0, s.assertNodeType)("InterfaceExtends"), optional: true }, declare: { validate: (0, s.assertValueType)("boolean"), optional: true }, abstract: { validate: (0, s.assertValueType)("boolean"), optional: true } }, validate: function() {
    let e = (0, s.assertNodeType)("Identifier");
    return function(t, r, n) {
      !E.BABEL_TYPES_8_BREAKING || (0, xe.default)("ExportDefaultDeclaration", t) || e(n, "id", n.id);
    };
  }() });
  N("ExportAllDeclaration", { builder: ["source"], visitor: ["source", "attributes", "assertions"], aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"], fields: { source: { validate: (0, s.assertNodeType)("StringLiteral") }, exportKind: (0, s.validateOptional)((0, s.assertOneOf)("type", "value")), attributes: { optional: true, validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("ImportAttribute"))) }, assertions: { optional: true, validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("ImportAttribute"))) } } });
  N("ExportDefaultDeclaration", { visitor: ["declaration"], aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"], fields: { declaration: { validate: (0, s.assertNodeType)("TSDeclareFunction", "FunctionDeclaration", "ClassDeclaration", "Expression") }, exportKind: (0, s.validateOptional)((0, s.assertOneOf)("value")) } });
  N("ExportNamedDeclaration", { builder: ["declaration", "specifiers", "source"], visitor: ["declaration", "specifiers", "source", "attributes", "assertions"], aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"], fields: { declaration: { optional: true, validate: (0, s.chain)((0, s.assertNodeType)("Declaration"), Object.assign(function(e, t, r) {
    if (!!E.BABEL_TYPES_8_BREAKING && r && e.specifiers.length)
      throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration");
  }, { oneOfNodeTypes: ["Declaration"] }), function(e, t, r) {
    if (!!E.BABEL_TYPES_8_BREAKING && r && e.source)
      throw new TypeError("Cannot export a declaration from a source");
  }) }, attributes: { optional: true, validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("ImportAttribute"))) }, assertions: { optional: true, validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("ImportAttribute"))) }, specifiers: { default: [], validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)(function() {
    let e = (0, s.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier"), t = (0, s.assertNodeType)("ExportSpecifier");
    return E.BABEL_TYPES_8_BREAKING ? function(r, n, i) {
      (r.source ? e : t)(r, n, i);
    } : e;
  }())) }, source: { validate: (0, s.assertNodeType)("StringLiteral"), optional: true }, exportKind: (0, s.validateOptional)((0, s.assertOneOf)("type", "value")) } });
  N("ExportSpecifier", { visitor: ["local", "exported"], aliases: ["ModuleSpecifier"], fields: { local: { validate: (0, s.assertNodeType)("Identifier") }, exported: { validate: (0, s.assertNodeType)("Identifier", "StringLiteral") }, exportKind: { validate: (0, s.assertOneOf)("type", "value"), optional: true } } });
  N("ForOfStatement", { visitor: ["left", "right", "body"], builder: ["left", "right", "body", "await"], aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"], fields: { left: { validate: function() {
    if (!E.BABEL_TYPES_8_BREAKING)
      return (0, s.assertNodeType)("VariableDeclaration", "LVal");
    let e = (0, s.assertNodeType)("VariableDeclaration"), t = (0, s.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression");
    return function(r, n, i) {
      (0, xe.default)("VariableDeclaration", i) ? e(r, n, i) : t(r, n, i);
    };
  }() }, right: { validate: (0, s.assertNodeType)("Expression") }, body: { validate: (0, s.assertNodeType)("Statement") }, await: { default: false } } });
  N("ImportDeclaration", { builder: ["specifiers", "source"], visitor: ["specifiers", "source", "attributes", "assertions"], aliases: ["Statement", "Declaration", "ImportOrExportDeclaration"], fields: { attributes: { optional: true, validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("ImportAttribute"))) }, assertions: { optional: true, validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("ImportAttribute"))) }, module: { optional: true, validate: (0, s.assertValueType)("boolean") }, phase: { default: null, validate: (0, s.assertOneOf)("source", "defer") }, specifiers: { validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier"))) }, source: { validate: (0, s.assertNodeType)("StringLiteral") }, importKind: { validate: (0, s.assertOneOf)("type", "typeof", "value"), optional: true } } });
  N("ImportDefaultSpecifier", { visitor: ["local"], aliases: ["ModuleSpecifier"], fields: { local: { validate: (0, s.assertNodeType)("Identifier") } } });
  N("ImportNamespaceSpecifier", { visitor: ["local"], aliases: ["ModuleSpecifier"], fields: { local: { validate: (0, s.assertNodeType)("Identifier") } } });
  N("ImportSpecifier", { visitor: ["local", "imported"], aliases: ["ModuleSpecifier"], fields: { local: { validate: (0, s.assertNodeType)("Identifier") }, imported: { validate: (0, s.assertNodeType)("Identifier", "StringLiteral") }, importKind: { validate: (0, s.assertOneOf)("type", "typeof", "value"), optional: true } } });
  N("ImportExpression", { visitor: ["source", "options"], aliases: ["Expression"], fields: { phase: { default: null, validate: (0, s.assertOneOf)("source", "defer") }, source: { validate: (0, s.assertNodeType)("Expression") }, options: { validate: (0, s.assertNodeType)("Expression"), optional: true } } });
  N("MetaProperty", { visitor: ["meta", "property"], aliases: ["Expression"], fields: { meta: { validate: (0, s.chain)((0, s.assertNodeType)("Identifier"), Object.assign(function(e, t, r) {
    if (!E.BABEL_TYPES_8_BREAKING)
      return;
    let n;
    switch (r.name) {
      case "function":
        n = "sent";
        break;
      case "new":
        n = "target";
        break;
      case "import":
        n = "meta";
        break;
    }
    if (!(0, xe.default)("Identifier", e.property, { name: n }))
      throw new TypeError("Unrecognised MetaProperty");
  }, { oneOfNodeTypes: ["Identifier"] })) }, property: { validate: (0, s.assertNodeType)("Identifier") } } });
  var qr = () => ({ abstract: { validate: (0, s.assertValueType)("boolean"), optional: true }, accessibility: { validate: (0, s.assertOneOf)("public", "private", "protected"), optional: true }, static: { default: false }, override: { default: false }, computed: { default: false }, optional: { validate: (0, s.assertValueType)("boolean"), optional: true }, key: { validate: (0, s.chain)(function() {
    let e = (0, s.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"), t = (0, s.assertNodeType)("Expression");
    return function(r, n, i) {
      (r.computed ? t : e)(r, n, i);
    };
  }(), (0, s.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression")) } });
  De.classMethodOrPropertyCommon = qr;
  var ya = () => Object.assign({}, At(), qr(), { params: { validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("Identifier", "Pattern", "RestElement", "TSParameterProperty"))) }, kind: { validate: (0, s.assertOneOf)("get", "set", "method", "constructor"), default: "method" }, access: { validate: (0, s.chain)((0, s.assertValueType)("string"), (0, s.assertOneOf)("public", "private", "protected")), optional: true }, decorators: { validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("Decorator"))), optional: true } });
  De.classMethodOrDeclareMethodCommon = ya;
  N("ClassMethod", { aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"], builder: ["kind", "key", "params", "body", "computed", "static", "generator", "async"], visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"], fields: Object.assign({}, ya(), st(), { body: { validate: (0, s.assertNodeType)("BlockStatement") } }) });
  N("ObjectPattern", { visitor: ["properties", "typeAnnotation", "decorators"], builder: ["properties"], aliases: ["Pattern", "PatternLike", "LVal"], fields: Object.assign({}, Ot(), { properties: { validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("RestElement", "ObjectProperty"))) } }) });
  N("SpreadElement", { visitor: ["argument"], aliases: ["UnaryLike"], deprecatedAlias: "SpreadProperty", fields: { argument: { validate: (0, s.assertNodeType)("Expression") } } });
  N("Super", { aliases: ["Expression"] });
  N("TaggedTemplateExpression", { visitor: ["tag", "quasi", "typeParameters"], builder: ["tag", "quasi"], aliases: ["Expression"], fields: { tag: { validate: (0, s.assertNodeType)("Expression") }, quasi: { validate: (0, s.assertNodeType)("TemplateLiteral") }, typeParameters: { validate: (0, s.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"), optional: true } } });
  N("TemplateElement", { builder: ["value", "tail"], fields: { value: { validate: (0, s.chain)((0, s.assertShape)({ raw: { validate: (0, s.assertValueType)("string") }, cooked: { validate: (0, s.assertValueType)("string"), optional: true } }), function(t) {
    let r = t.value.raw, n = false, i = () => {
      throw new Error("Internal @babel/types error.");
    }, { str: l, firstInvalidLoc: y } = (0, Wx.readStringContents)("template", r, 0, 0, 0, { unterminated() {
      n = true;
    }, strictNumericEscape: i, invalidEscapeSequence: i, numericSeparatorInEscapeSequence: i, unexpectedNumericSeparator: i, invalidDigit: i, invalidCodePoint: i });
    if (!n)
      throw new Error("Invalid raw");
    t.value.cooked = y ? null : l;
  }) }, tail: { default: false } } });
  N("TemplateLiteral", { visitor: ["quasis", "expressions"], aliases: ["Expression", "Literal"], fields: { quasis: { validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("TemplateElement"))) }, expressions: { validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("Expression", "TSType")), function(e, t, r) {
    if (e.quasis.length !== r.length + 1)
      throw new TypeError(`Number of ${e.type} quasis should be exactly one more than the number of expressions.
Expected ${r.length + 1} quasis but got ${e.quasis.length}`);
  }) } } });
  N("YieldExpression", { builder: ["argument", "delegate"], visitor: ["argument"], aliases: ["Expression", "Terminatorless"], fields: { delegate: { validate: (0, s.chain)((0, s.assertValueType)("boolean"), Object.assign(function(e, t, r) {
    if (!!E.BABEL_TYPES_8_BREAKING && r && !e.argument)
      throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument");
  }, { type: "boolean" })), default: false }, argument: { optional: true, validate: (0, s.assertNodeType)("Expression") } } });
  N("AwaitExpression", { builder: ["argument"], visitor: ["argument"], aliases: ["Expression", "Terminatorless"], fields: { argument: { validate: (0, s.assertNodeType)("Expression") } } });
  N("Import", { aliases: ["Expression"] });
  N("BigIntLiteral", { builder: ["value"], fields: { value: { validate: (0, s.assertValueType)("string") } }, aliases: ["Expression", "Pureish", "Literal", "Immutable"] });
  N("ExportNamespaceSpecifier", { visitor: ["exported"], aliases: ["ModuleSpecifier"], fields: { exported: { validate: (0, s.assertNodeType)("Identifier") } } });
  N("OptionalMemberExpression", { builder: ["object", "property", "computed", "optional"], visitor: ["object", "property"], aliases: ["Expression"], fields: { object: { validate: (0, s.assertNodeType)("Expression") }, property: { validate: function() {
    let e = (0, s.assertNodeType)("Identifier"), t = (0, s.assertNodeType)("Expression");
    return Object.assign(function(n, i, l) {
      (n.computed ? t : e)(n, i, l);
    }, { oneOfNodeTypes: ["Expression", "Identifier"] });
  }() }, computed: { default: false }, optional: { validate: E.BABEL_TYPES_8_BREAKING ? (0, s.chain)((0, s.assertValueType)("boolean"), (0, s.assertOptionalChainStart)()) : (0, s.assertValueType)("boolean") } } });
  N("OptionalCallExpression", { visitor: ["callee", "arguments", "typeParameters", "typeArguments"], builder: ["callee", "arguments", "optional"], aliases: ["Expression"], fields: { callee: { validate: (0, s.assertNodeType)("Expression") }, arguments: { validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder"))) }, optional: { validate: E.BABEL_TYPES_8_BREAKING ? (0, s.chain)((0, s.assertValueType)("boolean"), (0, s.assertOptionalChainStart)()) : (0, s.assertValueType)("boolean") }, typeArguments: { validate: (0, s.assertNodeType)("TypeParameterInstantiation"), optional: true }, typeParameters: { validate: (0, s.assertNodeType)("TSTypeParameterInstantiation"), optional: true } } });
  N("ClassProperty", { visitor: ["key", "value", "typeAnnotation", "decorators"], builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"], aliases: ["Property"], fields: Object.assign({}, qr(), { value: { validate: (0, s.assertNodeType)("Expression"), optional: true }, definite: { validate: (0, s.assertValueType)("boolean"), optional: true }, typeAnnotation: { validate: (0, s.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"), optional: true }, decorators: { validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("Decorator"))), optional: true }, readonly: { validate: (0, s.assertValueType)("boolean"), optional: true }, declare: { validate: (0, s.assertValueType)("boolean"), optional: true }, variance: { validate: (0, s.assertNodeType)("Variance"), optional: true } }) });
  N("ClassAccessorProperty", { visitor: ["key", "value", "typeAnnotation", "decorators"], builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"], aliases: ["Property", "Accessor"], fields: Object.assign({}, qr(), { key: { validate: (0, s.chain)(function() {
    let e = (0, s.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "PrivateName"), t = (0, s.assertNodeType)("Expression");
    return function(r, n, i) {
      (r.computed ? t : e)(r, n, i);
    };
  }(), (0, s.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression", "PrivateName")) }, value: { validate: (0, s.assertNodeType)("Expression"), optional: true }, definite: { validate: (0, s.assertValueType)("boolean"), optional: true }, typeAnnotation: { validate: (0, s.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"), optional: true }, decorators: { validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("Decorator"))), optional: true }, readonly: { validate: (0, s.assertValueType)("boolean"), optional: true }, declare: { validate: (0, s.assertValueType)("boolean"), optional: true }, variance: { validate: (0, s.assertNodeType)("Variance"), optional: true } }) });
  N("ClassPrivateProperty", { visitor: ["key", "value", "decorators", "typeAnnotation"], builder: ["key", "value", "decorators", "static"], aliases: ["Property", "Private"], fields: { key: { validate: (0, s.assertNodeType)("PrivateName") }, value: { validate: (0, s.assertNodeType)("Expression"), optional: true }, typeAnnotation: { validate: (0, s.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"), optional: true }, decorators: { validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("Decorator"))), optional: true }, static: { validate: (0, s.assertValueType)("boolean"), default: false }, readonly: { validate: (0, s.assertValueType)("boolean"), optional: true }, definite: { validate: (0, s.assertValueType)("boolean"), optional: true }, variance: { validate: (0, s.assertNodeType)("Variance"), optional: true } } });
  N("ClassPrivateMethod", { builder: ["kind", "key", "params", "body", "static"], visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"], aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method", "Private"], fields: Object.assign({}, ya(), st(), { kind: { validate: (0, s.assertOneOf)("get", "set", "method"), default: "method" }, key: { validate: (0, s.assertNodeType)("PrivateName") }, body: { validate: (0, s.assertNodeType)("BlockStatement") } }) });
  N("PrivateName", { visitor: ["id"], aliases: ["Private"], fields: { id: { validate: (0, s.assertNodeType)("Identifier") } } });
  N("StaticBlock", { visitor: ["body"], fields: { body: { validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("Statement"))) } }, aliases: ["Scopable", "BlockParent", "FunctionParent"] });
});
var Dl = x(() => {
  "use strict";
  o();
  var g = Ve(), R = (0, g.defineAliasedType)("Flow"), Ta = (e) => {
    let t = e === "DeclareClass";
    R(e, { builder: ["id", "typeParameters", "extends", "body"], visitor: ["id", "typeParameters", "extends", ...t ? ["mixins", "implements"] : [], "body"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: Object.assign({ id: (0, g.validateType)("Identifier"), typeParameters: (0, g.validateOptionalType)("TypeParameterDeclaration"), extends: (0, g.validateOptional)((0, g.arrayOfType)("InterfaceExtends")) }, t ? { mixins: (0, g.validateOptional)((0, g.arrayOfType)("InterfaceExtends")), implements: (0, g.validateOptional)((0, g.arrayOfType)("ClassImplements")) } : {}, { body: (0, g.validateType)("ObjectTypeAnnotation") }) });
  };
  R("AnyTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] });
  R("ArrayTypeAnnotation", { visitor: ["elementType"], aliases: ["FlowType"], fields: { elementType: (0, g.validateType)("FlowType") } });
  R("BooleanTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] });
  R("BooleanLiteralTypeAnnotation", { builder: ["value"], aliases: ["FlowType"], fields: { value: (0, g.validate)((0, g.assertValueType)("boolean")) } });
  R("NullLiteralTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] });
  R("ClassImplements", { visitor: ["id", "typeParameters"], fields: { id: (0, g.validateType)("Identifier"), typeParameters: (0, g.validateOptionalType)("TypeParameterInstantiation") } });
  Ta("DeclareClass");
  R("DeclareFunction", { visitor: ["id"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, g.validateType)("Identifier"), predicate: (0, g.validateOptionalType)("DeclaredPredicate") } });
  Ta("DeclareInterface");
  R("DeclareModule", { builder: ["id", "body", "kind"], visitor: ["id", "body"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, g.validateType)(["Identifier", "StringLiteral"]), body: (0, g.validateType)("BlockStatement"), kind: (0, g.validateOptional)((0, g.assertOneOf)("CommonJS", "ES")) } });
  R("DeclareModuleExports", { visitor: ["typeAnnotation"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { typeAnnotation: (0, g.validateType)("TypeAnnotation") } });
  R("DeclareTypeAlias", { visitor: ["id", "typeParameters", "right"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, g.validateType)("Identifier"), typeParameters: (0, g.validateOptionalType)("TypeParameterDeclaration"), right: (0, g.validateType)("FlowType") } });
  R("DeclareOpaqueType", { visitor: ["id", "typeParameters", "supertype"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, g.validateType)("Identifier"), typeParameters: (0, g.validateOptionalType)("TypeParameterDeclaration"), supertype: (0, g.validateOptionalType)("FlowType"), impltype: (0, g.validateOptionalType)("FlowType") } });
  R("DeclareVariable", { visitor: ["id"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, g.validateType)("Identifier") } });
  R("DeclareExportDeclaration", { visitor: ["declaration", "specifiers", "source"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { declaration: (0, g.validateOptionalType)("Flow"), specifiers: (0, g.validateOptional)((0, g.arrayOfType)(["ExportSpecifier", "ExportNamespaceSpecifier"])), source: (0, g.validateOptionalType)("StringLiteral"), default: (0, g.validateOptional)((0, g.assertValueType)("boolean")) } });
  R("DeclareExportAllDeclaration", { visitor: ["source"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { source: (0, g.validateType)("StringLiteral"), exportKind: (0, g.validateOptional)((0, g.assertOneOf)("type", "value")) } });
  R("DeclaredPredicate", { visitor: ["value"], aliases: ["FlowPredicate"], fields: { value: (0, g.validateType)("Flow") } });
  R("ExistsTypeAnnotation", { aliases: ["FlowType"] });
  R("FunctionTypeAnnotation", { visitor: ["typeParameters", "params", "rest", "returnType"], aliases: ["FlowType"], fields: { typeParameters: (0, g.validateOptionalType)("TypeParameterDeclaration"), params: (0, g.validate)((0, g.arrayOfType)("FunctionTypeParam")), rest: (0, g.validateOptionalType)("FunctionTypeParam"), this: (0, g.validateOptionalType)("FunctionTypeParam"), returnType: (0, g.validateType)("FlowType") } });
  R("FunctionTypeParam", { visitor: ["name", "typeAnnotation"], fields: { name: (0, g.validateOptionalType)("Identifier"), typeAnnotation: (0, g.validateType)("FlowType"), optional: (0, g.validateOptional)((0, g.assertValueType)("boolean")) } });
  R("GenericTypeAnnotation", { visitor: ["id", "typeParameters"], aliases: ["FlowType"], fields: { id: (0, g.validateType)(["Identifier", "QualifiedTypeIdentifier"]), typeParameters: (0, g.validateOptionalType)("TypeParameterInstantiation") } });
  R("InferredPredicate", { aliases: ["FlowPredicate"] });
  R("InterfaceExtends", { visitor: ["id", "typeParameters"], fields: { id: (0, g.validateType)(["Identifier", "QualifiedTypeIdentifier"]), typeParameters: (0, g.validateOptionalType)("TypeParameterInstantiation") } });
  Ta("InterfaceDeclaration");
  R("InterfaceTypeAnnotation", { visitor: ["extends", "body"], aliases: ["FlowType"], fields: { extends: (0, g.validateOptional)((0, g.arrayOfType)("InterfaceExtends")), body: (0, g.validateType)("ObjectTypeAnnotation") } });
  R("IntersectionTypeAnnotation", { visitor: ["types"], aliases: ["FlowType"], fields: { types: (0, g.validate)((0, g.arrayOfType)("FlowType")) } });
  R("MixedTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] });
  R("EmptyTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] });
  R("NullableTypeAnnotation", { visitor: ["typeAnnotation"], aliases: ["FlowType"], fields: { typeAnnotation: (0, g.validateType)("FlowType") } });
  R("NumberLiteralTypeAnnotation", { builder: ["value"], aliases: ["FlowType"], fields: { value: (0, g.validate)((0, g.assertValueType)("number")) } });
  R("NumberTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] });
  R("ObjectTypeAnnotation", { visitor: ["properties", "indexers", "callProperties", "internalSlots"], aliases: ["FlowType"], builder: ["properties", "indexers", "callProperties", "internalSlots", "exact"], fields: { properties: (0, g.validate)((0, g.arrayOfType)(["ObjectTypeProperty", "ObjectTypeSpreadProperty"])), indexers: { validate: (0, g.arrayOfType)("ObjectTypeIndexer"), optional: true, default: [] }, callProperties: { validate: (0, g.arrayOfType)("ObjectTypeCallProperty"), optional: true, default: [] }, internalSlots: { validate: (0, g.arrayOfType)("ObjectTypeInternalSlot"), optional: true, default: [] }, exact: { validate: (0, g.assertValueType)("boolean"), default: false }, inexact: (0, g.validateOptional)((0, g.assertValueType)("boolean")) } });
  R("ObjectTypeInternalSlot", { visitor: ["id", "value", "optional", "static", "method"], aliases: ["UserWhitespacable"], fields: { id: (0, g.validateType)("Identifier"), value: (0, g.validateType)("FlowType"), optional: (0, g.validate)((0, g.assertValueType)("boolean")), static: (0, g.validate)((0, g.assertValueType)("boolean")), method: (0, g.validate)((0, g.assertValueType)("boolean")) } });
  R("ObjectTypeCallProperty", { visitor: ["value"], aliases: ["UserWhitespacable"], fields: { value: (0, g.validateType)("FlowType"), static: (0, g.validate)((0, g.assertValueType)("boolean")) } });
  R("ObjectTypeIndexer", { visitor: ["id", "key", "value", "variance"], aliases: ["UserWhitespacable"], fields: { id: (0, g.validateOptionalType)("Identifier"), key: (0, g.validateType)("FlowType"), value: (0, g.validateType)("FlowType"), static: (0, g.validate)((0, g.assertValueType)("boolean")), variance: (0, g.validateOptionalType)("Variance") } });
  R("ObjectTypeProperty", { visitor: ["key", "value", "variance"], aliases: ["UserWhitespacable"], fields: { key: (0, g.validateType)(["Identifier", "StringLiteral"]), value: (0, g.validateType)("FlowType"), kind: (0, g.validate)((0, g.assertOneOf)("init", "get", "set")), static: (0, g.validate)((0, g.assertValueType)("boolean")), proto: (0, g.validate)((0, g.assertValueType)("boolean")), optional: (0, g.validate)((0, g.assertValueType)("boolean")), variance: (0, g.validateOptionalType)("Variance"), method: (0, g.validate)((0, g.assertValueType)("boolean")) } });
  R("ObjectTypeSpreadProperty", { visitor: ["argument"], aliases: ["UserWhitespacable"], fields: { argument: (0, g.validateType)("FlowType") } });
  R("OpaqueType", { visitor: ["id", "typeParameters", "supertype", "impltype"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, g.validateType)("Identifier"), typeParameters: (0, g.validateOptionalType)("TypeParameterDeclaration"), supertype: (0, g.validateOptionalType)("FlowType"), impltype: (0, g.validateType)("FlowType") } });
  R("QualifiedTypeIdentifier", { visitor: ["id", "qualification"], fields: { id: (0, g.validateType)("Identifier"), qualification: (0, g.validateType)(["Identifier", "QualifiedTypeIdentifier"]) } });
  R("StringLiteralTypeAnnotation", { builder: ["value"], aliases: ["FlowType"], fields: { value: (0, g.validate)((0, g.assertValueType)("string")) } });
  R("StringTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] });
  R("SymbolTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] });
  R("ThisTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] });
  R("TupleTypeAnnotation", { visitor: ["types"], aliases: ["FlowType"], fields: { types: (0, g.validate)((0, g.arrayOfType)("FlowType")) } });
  R("TypeofTypeAnnotation", { visitor: ["argument"], aliases: ["FlowType"], fields: { argument: (0, g.validateType)("FlowType") } });
  R("TypeAlias", { visitor: ["id", "typeParameters", "right"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, g.validateType)("Identifier"), typeParameters: (0, g.validateOptionalType)("TypeParameterDeclaration"), right: (0, g.validateType)("FlowType") } });
  R("TypeAnnotation", { visitor: ["typeAnnotation"], fields: { typeAnnotation: (0, g.validateType)("FlowType") } });
  R("TypeCastExpression", { visitor: ["expression", "typeAnnotation"], aliases: ["ExpressionWrapper", "Expression"], fields: { expression: (0, g.validateType)("Expression"), typeAnnotation: (0, g.validateType)("TypeAnnotation") } });
  R("TypeParameter", { visitor: ["bound", "default", "variance"], fields: { name: (0, g.validate)((0, g.assertValueType)("string")), bound: (0, g.validateOptionalType)("TypeAnnotation"), default: (0, g.validateOptionalType)("FlowType"), variance: (0, g.validateOptionalType)("Variance") } });
  R("TypeParameterDeclaration", { visitor: ["params"], fields: { params: (0, g.validate)((0, g.arrayOfType)("TypeParameter")) } });
  R("TypeParameterInstantiation", { visitor: ["params"], fields: { params: (0, g.validate)((0, g.arrayOfType)("FlowType")) } });
  R("UnionTypeAnnotation", { visitor: ["types"], aliases: ["FlowType"], fields: { types: (0, g.validate)((0, g.arrayOfType)("FlowType")) } });
  R("Variance", { builder: ["kind"], fields: { kind: (0, g.validate)((0, g.assertOneOf)("minus", "plus")) } });
  R("VoidTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] });
  R("EnumDeclaration", { aliases: ["Statement", "Declaration"], visitor: ["id", "body"], fields: { id: (0, g.validateType)("Identifier"), body: (0, g.validateType)(["EnumBooleanBody", "EnumNumberBody", "EnumStringBody", "EnumSymbolBody"]) } });
  R("EnumBooleanBody", { aliases: ["EnumBody"], visitor: ["members"], fields: { explicitType: (0, g.validate)((0, g.assertValueType)("boolean")), members: (0, g.validateArrayOfType)("EnumBooleanMember"), hasUnknownMembers: (0, g.validate)((0, g.assertValueType)("boolean")) } });
  R("EnumNumberBody", { aliases: ["EnumBody"], visitor: ["members"], fields: { explicitType: (0, g.validate)((0, g.assertValueType)("boolean")), members: (0, g.validateArrayOfType)("EnumNumberMember"), hasUnknownMembers: (0, g.validate)((0, g.assertValueType)("boolean")) } });
  R("EnumStringBody", { aliases: ["EnumBody"], visitor: ["members"], fields: { explicitType: (0, g.validate)((0, g.assertValueType)("boolean")), members: (0, g.validateArrayOfType)(["EnumStringMember", "EnumDefaultedMember"]), hasUnknownMembers: (0, g.validate)((0, g.assertValueType)("boolean")) } });
  R("EnumSymbolBody", { aliases: ["EnumBody"], visitor: ["members"], fields: { members: (0, g.validateArrayOfType)("EnumDefaultedMember"), hasUnknownMembers: (0, g.validate)((0, g.assertValueType)("boolean")) } });
  R("EnumBooleanMember", { aliases: ["EnumMember"], visitor: ["id"], fields: { id: (0, g.validateType)("Identifier"), init: (0, g.validateType)("BooleanLiteral") } });
  R("EnumNumberMember", { aliases: ["EnumMember"], visitor: ["id", "init"], fields: { id: (0, g.validateType)("Identifier"), init: (0, g.validateType)("NumericLiteral") } });
  R("EnumStringMember", { aliases: ["EnumMember"], visitor: ["id", "init"], fields: { id: (0, g.validateType)("Identifier"), init: (0, g.validateType)("StringLiteral") } });
  R("EnumDefaultedMember", { aliases: ["EnumMember"], visitor: ["id"], fields: { id: (0, g.validateType)("Identifier") } });
  R("IndexedAccessType", { visitor: ["objectType", "indexType"], aliases: ["FlowType"], fields: { objectType: (0, g.validateType)("FlowType"), indexType: (0, g.validateType)("FlowType") } });
  R("OptionalIndexedAccessType", { visitor: ["objectType", "indexType"], aliases: ["FlowType"], fields: { objectType: (0, g.validateType)("FlowType"), indexType: (0, g.validateType)("FlowType"), optional: (0, g.validate)((0, g.assertValueType)("boolean")) } });
});
var Nl = x(() => {
  "use strict";
  o();
  var re = Ve(), ge = (0, re.defineAliasedType)("JSX");
  ge("JSXAttribute", { visitor: ["name", "value"], aliases: ["Immutable"], fields: { name: { validate: (0, re.assertNodeType)("JSXIdentifier", "JSXNamespacedName") }, value: { optional: true, validate: (0, re.assertNodeType)("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer") } } });
  ge("JSXClosingElement", { visitor: ["name"], aliases: ["Immutable"], fields: { name: { validate: (0, re.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName") } } });
  ge("JSXElement", { builder: ["openingElement", "closingElement", "children", "selfClosing"], visitor: ["openingElement", "children", "closingElement"], aliases: ["Immutable", "Expression"], fields: Object.assign({ openingElement: { validate: (0, re.assertNodeType)("JSXOpeningElement") }, closingElement: { optional: true, validate: (0, re.assertNodeType)("JSXClosingElement") }, children: { validate: (0, re.chain)((0, re.assertValueType)("array"), (0, re.assertEach)((0, re.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment"))) } }, { selfClosing: { validate: (0, re.assertValueType)("boolean"), optional: true } }) });
  ge("JSXEmptyExpression", {});
  ge("JSXExpressionContainer", { visitor: ["expression"], aliases: ["Immutable"], fields: { expression: { validate: (0, re.assertNodeType)("Expression", "JSXEmptyExpression") } } });
  ge("JSXSpreadChild", { visitor: ["expression"], aliases: ["Immutable"], fields: { expression: { validate: (0, re.assertNodeType)("Expression") } } });
  ge("JSXIdentifier", { builder: ["name"], fields: { name: { validate: (0, re.assertValueType)("string") } } });
  ge("JSXMemberExpression", { visitor: ["object", "property"], fields: { object: { validate: (0, re.assertNodeType)("JSXMemberExpression", "JSXIdentifier") }, property: { validate: (0, re.assertNodeType)("JSXIdentifier") } } });
  ge("JSXNamespacedName", { visitor: ["namespace", "name"], fields: { namespace: { validate: (0, re.assertNodeType)("JSXIdentifier") }, name: { validate: (0, re.assertNodeType)("JSXIdentifier") } } });
  ge("JSXOpeningElement", { builder: ["name", "attributes", "selfClosing"], visitor: ["name", "attributes"], aliases: ["Immutable"], fields: { name: { validate: (0, re.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName") }, selfClosing: { default: false }, attributes: { validate: (0, re.chain)((0, re.assertValueType)("array"), (0, re.assertEach)((0, re.assertNodeType)("JSXAttribute", "JSXSpreadAttribute"))) }, typeParameters: { validate: (0, re.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"), optional: true } } });
  ge("JSXSpreadAttribute", { visitor: ["argument"], fields: { argument: { validate: (0, re.assertNodeType)("Expression") } } });
  ge("JSXText", { aliases: ["Immutable"], builder: ["value"], fields: { value: { validate: (0, re.assertValueType)("string") } } });
  ge("JSXFragment", { builder: ["openingFragment", "closingFragment", "children"], visitor: ["openingFragment", "children", "closingFragment"], aliases: ["Immutable", "Expression"], fields: { openingFragment: { validate: (0, re.assertNodeType)("JSXOpeningFragment") }, closingFragment: { validate: (0, re.assertNodeType)("JSXClosingFragment") }, children: { validate: (0, re.chain)((0, re.assertValueType)("array"), (0, re.assertEach)((0, re.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment"))) } } });
  ge("JSXOpeningFragment", { aliases: ["Immutable"] });
  ge("JSXClosingFragment", { aliases: ["Immutable"] });
});
var Ea = x((ze) => {
  "use strict";
  o();
  Object.defineProperty(ze, "__esModule", { value: true });
  ze.PLACEHOLDERS_FLIPPED_ALIAS = ze.PLACEHOLDERS_ALIAS = ze.PLACEHOLDERS = void 0;
  var $x = Ve(), Gx = ze.PLACEHOLDERS = ["Identifier", "StringLiteral", "Expression", "Statement", "Declaration", "BlockStatement", "ClassBody", "Pattern"], ba = ze.PLACEHOLDERS_ALIAS = { Declaration: ["Statement"], Pattern: ["PatternLike", "LVal"] };
  for (let e of Gx) {
    let t = $x.ALIAS_KEYS[e];
    t != null && t.length && (ba[e] = t);
  }
  var Sa = ze.PLACEHOLDERS_FLIPPED_ALIAS = {};
  Object.keys(ba).forEach((e) => {
    ba[e].forEach((t) => {
      Object.hasOwnProperty.call(Sa, t) || (Sa[t] = []), Sa[t].push(e);
    });
  });
});
var Cl = x(() => {
  "use strict";
  o();
  var Yr = Ve(), zx = Ea(), va = (0, Yr.defineAliasedType)("Miscellaneous");
  va("Noop", { visitor: [] });
  va("Placeholder", { visitor: [], builder: ["expectedNode", "name"], fields: { name: { validate: (0, Yr.assertNodeType)("Identifier") }, expectedNode: { validate: (0, Yr.assertOneOf)(...zx.PLACEHOLDERS) } } });
  va("V8IntrinsicIdentifier", { builder: ["name"], fields: { name: { validate: (0, Yr.assertValueType)("string") } } });
});
var wl = x(() => {
  "use strict";
  o();
  var ee = Ve();
  (0, ee.default)("ArgumentPlaceholder", {});
  (0, ee.default)("BindExpression", { visitor: ["object", "callee"], aliases: ["Expression"], fields: E.BABEL_TYPES_8_BREAKING ? { object: { validate: (0, ee.assertNodeType)("Expression") }, callee: { validate: (0, ee.assertNodeType)("Expression") } } : { object: { validate: Object.assign(() => {
  }, { oneOfNodeTypes: ["Expression"] }) }, callee: { validate: Object.assign(() => {
  }, { oneOfNodeTypes: ["Expression"] }) } } });
  (0, ee.default)("ImportAttribute", { visitor: ["key", "value"], fields: { key: { validate: (0, ee.assertNodeType)("Identifier", "StringLiteral") }, value: { validate: (0, ee.assertNodeType)("StringLiteral") } } });
  (0, ee.default)("Decorator", { visitor: ["expression"], fields: { expression: { validate: (0, ee.assertNodeType)("Expression") } } });
  (0, ee.default)("DoExpression", { visitor: ["body"], builder: ["body", "async"], aliases: ["Expression"], fields: { body: { validate: (0, ee.assertNodeType)("BlockStatement") }, async: { validate: (0, ee.assertValueType)("boolean"), default: false } } });
  (0, ee.default)("ExportDefaultSpecifier", { visitor: ["exported"], aliases: ["ModuleSpecifier"], fields: { exported: { validate: (0, ee.assertNodeType)("Identifier") } } });
  (0, ee.default)("RecordExpression", { visitor: ["properties"], aliases: ["Expression"], fields: { properties: { validate: (0, ee.chain)((0, ee.assertValueType)("array"), (0, ee.assertEach)((0, ee.assertNodeType)("ObjectProperty", "SpreadElement"))) } } });
  (0, ee.default)("TupleExpression", { fields: { elements: { validate: (0, ee.chain)((0, ee.assertValueType)("array"), (0, ee.assertEach)((0, ee.assertNodeType)("Expression", "SpreadElement"))), default: [] } }, visitor: ["elements"], aliases: ["Expression"] });
  (0, ee.default)("DecimalLiteral", { builder: ["value"], fields: { value: { validate: (0, ee.assertValueType)("string") } }, aliases: ["Expression", "Pureish", "Literal", "Immutable"] });
  (0, ee.default)("ModuleExpression", { visitor: ["body"], fields: { body: { validate: (0, ee.assertNodeType)("Program") } }, aliases: ["Expression"] });
  (0, ee.default)("TopicReference", { aliases: ["Expression"] });
  (0, ee.default)("PipelineTopicExpression", { builder: ["expression"], visitor: ["expression"], fields: { expression: { validate: (0, ee.assertNodeType)("Expression") } }, aliases: ["Expression"] });
  (0, ee.default)("PipelineBareFunction", { builder: ["callee"], visitor: ["callee"], fields: { callee: { validate: (0, ee.assertNodeType)("Expression") } }, aliases: ["Expression"] });
  (0, ee.default)("PipelinePrimaryTopicReference", { aliases: ["Expression"] });
});
var Kl = x(() => {
  "use strict";
  o();
  var I = Ve(), Ll = ma(), Hx = gt(), k = (0, I.defineAliasedType)("TypeScript"), Ne = (0, I.assertValueType)("boolean"), jl = () => ({ returnType: { validate: (0, I.assertNodeType)("TSTypeAnnotation", "Noop"), optional: true }, typeParameters: { validate: (0, I.assertNodeType)("TSTypeParameterDeclaration", "Noop"), optional: true } });
  k("TSParameterProperty", { aliases: ["LVal"], visitor: ["parameter"], fields: { accessibility: { validate: (0, I.assertOneOf)("public", "private", "protected"), optional: true }, readonly: { validate: (0, I.assertValueType)("boolean"), optional: true }, parameter: { validate: (0, I.assertNodeType)("Identifier", "AssignmentPattern") }, override: { validate: (0, I.assertValueType)("boolean"), optional: true }, decorators: { validate: (0, I.chain)((0, I.assertValueType)("array"), (0, I.assertEach)((0, I.assertNodeType)("Decorator"))), optional: true } } });
  k("TSDeclareFunction", { aliases: ["Statement", "Declaration"], visitor: ["id", "typeParameters", "params", "returnType"], fields: Object.assign({}, (0, Ll.functionDeclarationCommon)(), jl()) });
  k("TSDeclareMethod", { visitor: ["decorators", "key", "typeParameters", "params", "returnType"], fields: Object.assign({}, (0, Ll.classMethodOrDeclareMethodCommon)(), jl()) });
  k("TSQualifiedName", { aliases: ["TSEntityName"], visitor: ["left", "right"], fields: { left: (0, I.validateType)("TSEntityName"), right: (0, I.validateType)("Identifier") } });
  var Vr = () => ({ typeParameters: (0, I.validateOptionalType)("TSTypeParameterDeclaration"), parameters: (0, I.validateArrayOfType)(["ArrayPattern", "Identifier", "ObjectPattern", "RestElement"]), typeAnnotation: (0, I.validateOptionalType)("TSTypeAnnotation") }), Rl = { aliases: ["TSTypeElement"], visitor: ["typeParameters", "parameters", "typeAnnotation"], fields: Vr() };
  k("TSCallSignatureDeclaration", Rl);
  k("TSConstructSignatureDeclaration", Rl);
  var Ml = () => ({ key: (0, I.validateType)("Expression"), computed: { default: false }, optional: (0, I.validateOptional)(Ne) });
  k("TSPropertySignature", { aliases: ["TSTypeElement"], visitor: ["key", "typeAnnotation"], fields: Object.assign({}, Ml(), { readonly: (0, I.validateOptional)(Ne), typeAnnotation: (0, I.validateOptionalType)("TSTypeAnnotation"), kind: { validate: (0, I.assertOneOf)("get", "set") } }) });
  k("TSMethodSignature", { aliases: ["TSTypeElement"], visitor: ["key", "typeParameters", "parameters", "typeAnnotation"], fields: Object.assign({}, Vr(), Ml(), { kind: { validate: (0, I.assertOneOf)("method", "get", "set") } }) });
  k("TSIndexSignature", { aliases: ["TSTypeElement"], visitor: ["parameters", "typeAnnotation"], fields: { readonly: (0, I.validateOptional)(Ne), static: (0, I.validateOptional)(Ne), parameters: (0, I.validateArrayOfType)("Identifier"), typeAnnotation: (0, I.validateOptionalType)("TSTypeAnnotation") } });
  var Qx = ["TSAnyKeyword", "TSBooleanKeyword", "TSBigIntKeyword", "TSIntrinsicKeyword", "TSNeverKeyword", "TSNullKeyword", "TSNumberKeyword", "TSObjectKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSUndefinedKeyword", "TSUnknownKeyword", "TSVoidKeyword"];
  for (let e of Qx)
    k(e, { aliases: ["TSType", "TSBaseType"], visitor: [], fields: {} });
  k("TSThisType", { aliases: ["TSType", "TSBaseType"], visitor: [], fields: {} });
  var Bl = { aliases: ["TSType"], visitor: ["typeParameters", "parameters", "typeAnnotation"] };
  k("TSFunctionType", Object.assign({}, Bl, { fields: Vr() }));
  k("TSConstructorType", Object.assign({}, Bl, { fields: Object.assign({}, Vr(), { abstract: (0, I.validateOptional)(Ne) }) }));
  k("TSTypeReference", { aliases: ["TSType"], visitor: ["typeName", "typeParameters"], fields: { typeName: (0, I.validateType)("TSEntityName"), typeParameters: (0, I.validateOptionalType)("TSTypeParameterInstantiation") } });
  k("TSTypePredicate", { aliases: ["TSType"], visitor: ["parameterName", "typeAnnotation"], builder: ["parameterName", "typeAnnotation", "asserts"], fields: { parameterName: (0, I.validateType)(["Identifier", "TSThisType"]), typeAnnotation: (0, I.validateOptionalType)("TSTypeAnnotation"), asserts: (0, I.validateOptional)(Ne) } });
  k("TSTypeQuery", { aliases: ["TSType"], visitor: ["exprName", "typeParameters"], fields: { exprName: (0, I.validateType)(["TSEntityName", "TSImportType"]), typeParameters: (0, I.validateOptionalType)("TSTypeParameterInstantiation") } });
  k("TSTypeLiteral", { aliases: ["TSType"], visitor: ["members"], fields: { members: (0, I.validateArrayOfType)("TSTypeElement") } });
  k("TSArrayType", { aliases: ["TSType"], visitor: ["elementType"], fields: { elementType: (0, I.validateType)("TSType") } });
  k("TSTupleType", { aliases: ["TSType"], visitor: ["elementTypes"], fields: { elementTypes: (0, I.validateArrayOfType)(["TSType", "TSNamedTupleMember"]) } });
  k("TSOptionalType", { aliases: ["TSType"], visitor: ["typeAnnotation"], fields: { typeAnnotation: (0, I.validateType)("TSType") } });
  k("TSRestType", { aliases: ["TSType"], visitor: ["typeAnnotation"], fields: { typeAnnotation: (0, I.validateType)("TSType") } });
  k("TSNamedTupleMember", { visitor: ["label", "elementType"], builder: ["label", "elementType", "optional"], fields: { label: (0, I.validateType)("Identifier"), optional: { validate: Ne, default: false }, elementType: (0, I.validateType)("TSType") } });
  var Fl = { aliases: ["TSType"], visitor: ["types"], fields: { types: (0, I.validateArrayOfType)("TSType") } };
  k("TSUnionType", Fl);
  k("TSIntersectionType", Fl);
  k("TSConditionalType", { aliases: ["TSType"], visitor: ["checkType", "extendsType", "trueType", "falseType"], fields: { checkType: (0, I.validateType)("TSType"), extendsType: (0, I.validateType)("TSType"), trueType: (0, I.validateType)("TSType"), falseType: (0, I.validateType)("TSType") } });
  k("TSInferType", { aliases: ["TSType"], visitor: ["typeParameter"], fields: { typeParameter: (0, I.validateType)("TSTypeParameter") } });
  k("TSParenthesizedType", { aliases: ["TSType"], visitor: ["typeAnnotation"], fields: { typeAnnotation: (0, I.validateType)("TSType") } });
  k("TSTypeOperator", { aliases: ["TSType"], visitor: ["typeAnnotation"], fields: { operator: (0, I.validate)((0, I.assertValueType)("string")), typeAnnotation: (0, I.validateType)("TSType") } });
  k("TSIndexedAccessType", { aliases: ["TSType"], visitor: ["objectType", "indexType"], fields: { objectType: (0, I.validateType)("TSType"), indexType: (0, I.validateType)("TSType") } });
  k("TSMappedType", { aliases: ["TSType"], visitor: ["typeParameter", "typeAnnotation", "nameType"], fields: { readonly: (0, I.validateOptional)((0, I.assertOneOf)(true, false, "+", "-")), typeParameter: (0, I.validateType)("TSTypeParameter"), optional: (0, I.validateOptional)((0, I.assertOneOf)(true, false, "+", "-")), typeAnnotation: (0, I.validateOptionalType)("TSType"), nameType: (0, I.validateOptionalType)("TSType") } });
  k("TSLiteralType", { aliases: ["TSType", "TSBaseType"], visitor: ["literal"], fields: { literal: { validate: function() {
    let e = (0, I.assertNodeType)("NumericLiteral", "BigIntLiteral"), t = (0, I.assertOneOf)("-"), r = (0, I.assertNodeType)("NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral");
    function n(i, l, y) {
      (0, Hx.default)("UnaryExpression", y) ? (t(y, "operator", y.operator), e(y, "argument", y.argument)) : r(i, l, y);
    }
    return n.oneOfNodeTypes = ["NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral", "UnaryExpression"], n;
  }() } } });
  k("TSExpressionWithTypeArguments", { aliases: ["TSType"], visitor: ["expression", "typeParameters"], fields: { expression: (0, I.validateType)("TSEntityName"), typeParameters: (0, I.validateOptionalType)("TSTypeParameterInstantiation") } });
  k("TSInterfaceDeclaration", { aliases: ["Statement", "Declaration"], visitor: ["id", "typeParameters", "extends", "body"], fields: { declare: (0, I.validateOptional)(Ne), id: (0, I.validateType)("Identifier"), typeParameters: (0, I.validateOptionalType)("TSTypeParameterDeclaration"), extends: (0, I.validateOptional)((0, I.arrayOfType)("TSExpressionWithTypeArguments")), body: (0, I.validateType)("TSInterfaceBody") } });
  k("TSInterfaceBody", { visitor: ["body"], fields: { body: (0, I.validateArrayOfType)("TSTypeElement") } });
  k("TSTypeAliasDeclaration", { aliases: ["Statement", "Declaration"], visitor: ["id", "typeParameters", "typeAnnotation"], fields: { declare: (0, I.validateOptional)(Ne), id: (0, I.validateType)("Identifier"), typeParameters: (0, I.validateOptionalType)("TSTypeParameterDeclaration"), typeAnnotation: (0, I.validateType)("TSType") } });
  k("TSInstantiationExpression", { aliases: ["Expression"], visitor: ["expression", "typeParameters"], fields: { expression: (0, I.validateType)("Expression"), typeParameters: (0, I.validateOptionalType)("TSTypeParameterInstantiation") } });
  var kl = { aliases: ["Expression", "LVal", "PatternLike"], visitor: ["expression", "typeAnnotation"], fields: { expression: (0, I.validateType)("Expression"), typeAnnotation: (0, I.validateType)("TSType") } };
  k("TSAsExpression", kl);
  k("TSSatisfiesExpression", kl);
  k("TSTypeAssertion", { aliases: ["Expression", "LVal", "PatternLike"], visitor: ["typeAnnotation", "expression"], fields: { typeAnnotation: (0, I.validateType)("TSType"), expression: (0, I.validateType)("Expression") } });
  k("TSEnumDeclaration", { aliases: ["Statement", "Declaration"], visitor: ["id", "members"], fields: { declare: (0, I.validateOptional)(Ne), const: (0, I.validateOptional)(Ne), id: (0, I.validateType)("Identifier"), members: (0, I.validateArrayOfType)("TSEnumMember"), initializer: (0, I.validateOptionalType)("Expression") } });
  k("TSEnumMember", { visitor: ["id", "initializer"], fields: { id: (0, I.validateType)(["Identifier", "StringLiteral"]), initializer: (0, I.validateOptionalType)("Expression") } });
  k("TSModuleDeclaration", { aliases: ["Statement", "Declaration"], visitor: ["id", "body"], fields: { declare: (0, I.validateOptional)(Ne), global: (0, I.validateOptional)(Ne), id: (0, I.validateType)(["Identifier", "StringLiteral"]), body: (0, I.validateType)(["TSModuleBlock", "TSModuleDeclaration"]) } });
  k("TSModuleBlock", { aliases: ["Scopable", "Block", "BlockParent", "FunctionParent"], visitor: ["body"], fields: { body: (0, I.validateArrayOfType)("Statement") } });
  k("TSImportType", { aliases: ["TSType"], visitor: ["argument", "qualifier", "typeParameters"], fields: { argument: (0, I.validateType)("StringLiteral"), qualifier: (0, I.validateOptionalType)("TSEntityName"), typeParameters: (0, I.validateOptionalType)("TSTypeParameterInstantiation") } });
  k("TSImportEqualsDeclaration", { aliases: ["Statement"], visitor: ["id", "moduleReference"], fields: { isExport: (0, I.validate)(Ne), id: (0, I.validateType)("Identifier"), moduleReference: (0, I.validateType)(["TSEntityName", "TSExternalModuleReference"]), importKind: { validate: (0, I.assertOneOf)("type", "value"), optional: true } } });
  k("TSExternalModuleReference", { visitor: ["expression"], fields: { expression: (0, I.validateType)("StringLiteral") } });
  k("TSNonNullExpression", { aliases: ["Expression", "LVal", "PatternLike"], visitor: ["expression"], fields: { expression: (0, I.validateType)("Expression") } });
  k("TSExportAssignment", { aliases: ["Statement"], visitor: ["expression"], fields: { expression: (0, I.validateType)("Expression") } });
  k("TSNamespaceExportDeclaration", { aliases: ["Statement"], visitor: ["id"], fields: { id: (0, I.validateType)("Identifier") } });
  k("TSTypeAnnotation", { visitor: ["typeAnnotation"], fields: { typeAnnotation: { validate: (0, I.assertNodeType)("TSType") } } });
  k("TSTypeParameterInstantiation", { visitor: ["params"], fields: { params: { validate: (0, I.chain)((0, I.assertValueType)("array"), (0, I.assertEach)((0, I.assertNodeType)("TSType"))) } } });
  k("TSTypeParameterDeclaration", { visitor: ["params"], fields: { params: { validate: (0, I.chain)((0, I.assertValueType)("array"), (0, I.assertEach)((0, I.assertNodeType)("TSTypeParameter"))) } } });
  k("TSTypeParameter", { builder: ["constraint", "default", "name"], visitor: ["constraint", "default"], fields: { name: { validate: (0, I.assertValueType)("string") }, in: { validate: (0, I.assertValueType)("boolean"), optional: true }, out: { validate: (0, I.assertValueType)("boolean"), optional: true }, const: { validate: (0, I.assertValueType)("boolean"), optional: true }, constraint: { validate: (0, I.assertNodeType)("TSType"), optional: true }, default: { validate: (0, I.assertNodeType)("TSType"), optional: true } } });
});
var ql = x((Ur) => {
  "use strict";
  o();
  Object.defineProperty(Ur, "__esModule", { value: true });
  Ur.DEPRECATED_ALIASES = void 0;
  var fk = Ur.DEPRECATED_ALIASES = { ModuleDeclaration: "ImportOrExportDeclaration" };
});
var je = x((he) => {
  "use strict";
  o();
  Object.defineProperty(he, "__esModule", { value: true });
  Object.defineProperty(he, "ALIAS_KEYS", { enumerable: true, get: function() {
    return ye.ALIAS_KEYS;
  } });
  Object.defineProperty(he, "BUILDER_KEYS", { enumerable: true, get: function() {
    return ye.BUILDER_KEYS;
  } });
  Object.defineProperty(he, "DEPRECATED_ALIASES", { enumerable: true, get: function() {
    return Pa.DEPRECATED_ALIASES;
  } });
  Object.defineProperty(he, "DEPRECATED_KEYS", { enumerable: true, get: function() {
    return ye.DEPRECATED_KEYS;
  } });
  Object.defineProperty(he, "FLIPPED_ALIAS_KEYS", { enumerable: true, get: function() {
    return ye.FLIPPED_ALIAS_KEYS;
  } });
  Object.defineProperty(he, "NODE_FIELDS", { enumerable: true, get: function() {
    return ye.NODE_FIELDS;
  } });
  Object.defineProperty(he, "NODE_PARENT_VALIDATIONS", { enumerable: true, get: function() {
    return ye.NODE_PARENT_VALIDATIONS;
  } });
  Object.defineProperty(he, "PLACEHOLDERS", { enumerable: true, get: function() {
    return nr.PLACEHOLDERS;
  } });
  Object.defineProperty(he, "PLACEHOLDERS_ALIAS", { enumerable: true, get: function() {
    return nr.PLACEHOLDERS_ALIAS;
  } });
  Object.defineProperty(he, "PLACEHOLDERS_FLIPPED_ALIAS", { enumerable: true, get: function() {
    return nr.PLACEHOLDERS_FLIPPED_ALIAS;
  } });
  he.TYPES = void 0;
  Object.defineProperty(he, "VISITOR_KEYS", { enumerable: true, get: function() {
    return ye.VISITOR_KEYS;
  } });
  var He = il();
  ma();
  Dl();
  Nl();
  Cl();
  wl();
  Kl();
  var ye = Ve(), nr = Ea(), Pa = ql();
  Object.keys(Pa.DEPRECATED_ALIASES).forEach((e) => {
    ye.FLIPPED_ALIAS_KEYS[e] = ye.FLIPPED_ALIAS_KEYS[Pa.DEPRECATED_ALIASES[e]];
  });
  He(ye.VISITOR_KEYS);
  He(ye.ALIAS_KEYS);
  He(ye.FLIPPED_ALIAS_KEYS);
  He(ye.NODE_FIELDS);
  He(ye.BUILDER_KEYS);
  He(ye.DEPRECATED_KEYS);
  He(nr.PLACEHOLDERS_ALIAS);
  He(nr.PLACEHOLDERS_FLIPPED_ALIAS);
  var dk = he.TYPES = [].concat(Object.keys(ye.VISITOR_KEYS), Object.keys(ye.FLIPPED_ALIAS_KEYS), Object.keys(ye.DEPRECATED_KEYS));
});
var Kr = x((ar) => {
  "use strict";
  o();
  Object.defineProperty(ar, "__esModule", { value: true });
  ar.default = Zx;
  ar.validateChild = Ul;
  ar.validateField = Vl;
  var Yl = je();
  function Zx(e, t, r) {
    if (!e)
      return;
    let n = Yl.NODE_FIELDS[e.type];
    if (!n)
      return;
    let i = n[t];
    Vl(e, t, r, i), Ul(e, t, r);
  }
  function Vl(e, t, r, n) {
    !(n != null && n.validate) || n.optional && r == null || n.validate(e, t, r);
  }
  function Ul(e, t, r) {
    if (r == null)
      return;
    let n = Yl.NODE_PARENT_VALIDATIONS[r.type];
    !n || n(e, t, r);
  }
});
var Jl = x((xa) => {
  "use strict";
  o();
  Object.defineProperty(xa, "__esModule", { value: true });
  xa.default = rg;
  var eg = Kr(), tg = ir();
  function rg(e) {
    let t = tg.BUILDER_KEYS[e.type];
    for (let r of t)
      (0, eg.default)(e, r, e[r]);
    return e;
  }
});
var Ae = x((u) => {
  "use strict";
  o();
  Object.defineProperty(u, "__esModule", { value: true });
  u.anyTypeAnnotation = Lh;
  u.argumentPlaceholder = uO;
  u.arrayExpression = ng;
  u.arrayPattern = Qg;
  u.arrayTypeAnnotation = jh;
  u.arrowFunctionExpression = Zg;
  u.assignmentExpression = ag;
  u.assignmentPattern = Hg;
  u.awaitExpression = Ph;
  u.bigIntLiteral = gh;
  u.binaryExpression = ig;
  u.bindExpression = lO;
  u.blockStatement = lg;
  u.booleanLiteral = Dg;
  u.booleanLiteralTypeAnnotation = Mh;
  u.booleanTypeAnnotation = Rh;
  u.breakStatement = cg;
  u.callExpression = fg;
  u.catchClause = pg;
  u.classAccessorProperty = _h;
  u.classBody = eh;
  u.classDeclaration = rh;
  u.classExpression = th;
  u.classImplements = Fh;
  u.classMethod = yh;
  u.classPrivateMethod = Nh;
  u.classPrivateProperty = Dh;
  u.classProperty = Ih;
  u.conditionalExpression = dg;
  u.continueStatement = yg;
  u.debuggerStatement = mg;
  u.decimalLiteral = TO;
  u.declareClass = kh;
  u.declareExportAllDeclaration = $h;
  u.declareExportDeclaration = Wh;
  u.declareFunction = Kh;
  u.declareInterface = qh;
  u.declareModule = Yh;
  u.declareModuleExports = Vh;
  u.declareOpaqueType = Jh;
  u.declareTypeAlias = Uh;
  u.declareVariable = Xh;
  u.declaredPredicate = Gh;
  u.decorator = fO;
  u.directive = og;
  u.directiveLiteral = ug;
  u.doExpression = pO;
  u.doWhileStatement = Tg;
  u.emptyStatement = Sg;
  u.emptyTypeAnnotation = sA;
  u.enumBooleanBody = jA;
  u.enumBooleanMember = FA;
  u.enumDeclaration = LA;
  u.enumDefaultedMember = qA;
  u.enumNumberBody = RA;
  u.enumNumberMember = kA;
  u.enumStringBody = MA;
  u.enumStringMember = KA;
  u.enumSymbolBody = BA;
  u.existsTypeAnnotation = zh;
  u.exportAllDeclaration = nh;
  u.exportDefaultDeclaration = ah;
  u.exportDefaultSpecifier = dO;
  u.exportNamedDeclaration = ih;
  u.exportNamespaceSpecifier = hh;
  u.exportSpecifier = sh;
  u.expressionStatement = bg;
  u.file = Eg;
  u.forInStatement = vg;
  u.forOfStatement = oh;
  u.forStatement = Pg;
  u.functionDeclaration = xg;
  u.functionExpression = gg;
  u.functionTypeAnnotation = Hh;
  u.functionTypeParam = Qh;
  u.genericTypeAnnotation = Zh;
  u.identifier = hg;
  u.ifStatement = Ag;
  u.import = xh;
  u.importAttribute = cO;
  u.importDeclaration = uh;
  u.importDefaultSpecifier = lh;
  u.importExpression = ph;
  u.importNamespaceSpecifier = ch;
  u.importSpecifier = fh;
  u.indexedAccessType = YA;
  u.inferredPredicate = eA;
  u.interfaceDeclaration = rA;
  u.interfaceExtends = tA;
  u.interfaceTypeAnnotation = nA;
  u.interpreterDirective = sg;
  u.intersectionTypeAnnotation = aA;
  u.jSXAttribute = u.jsxAttribute = UA;
  u.jSXClosingElement = u.jsxClosingElement = JA;
  u.jSXClosingFragment = u.jsxClosingFragment = aO;
  u.jSXElement = u.jsxElement = XA;
  u.jSXEmptyExpression = u.jsxEmptyExpression = WA;
  u.jSXExpressionContainer = u.jsxExpressionContainer = $A;
  u.jSXFragment = u.jsxFragment = rO;
  u.jSXIdentifier = u.jsxIdentifier = zA;
  u.jSXMemberExpression = u.jsxMemberExpression = HA;
  u.jSXNamespacedName = u.jsxNamespacedName = QA;
  u.jSXOpeningElement = u.jsxOpeningElement = ZA;
  u.jSXOpeningFragment = u.jsxOpeningFragment = nO;
  u.jSXSpreadAttribute = u.jsxSpreadAttribute = eO;
  u.jSXSpreadChild = u.jsxSpreadChild = GA;
  u.jSXText = u.jsxText = tO;
  u.labeledStatement = Og;
  u.logicalExpression = Ng;
  u.memberExpression = Cg;
  u.metaProperty = dh;
  u.mixedTypeAnnotation = iA;
  u.moduleExpression = SO;
  u.newExpression = wg;
  u.noop = iO;
  u.nullLiteral = _g;
  u.nullLiteralTypeAnnotation = Bh;
  u.nullableTypeAnnotation = oA;
  u.numberLiteral = LI;
  u.numberLiteralTypeAnnotation = uA;
  u.numberTypeAnnotation = lA;
  u.numericLiteral = Xl;
  u.objectExpression = jg;
  u.objectMethod = Rg;
  u.objectPattern = mh;
  u.objectProperty = Mg;
  u.objectTypeAnnotation = cA;
  u.objectTypeCallProperty = pA;
  u.objectTypeIndexer = dA;
  u.objectTypeInternalSlot = fA;
  u.objectTypeProperty = yA;
  u.objectTypeSpreadProperty = mA;
  u.opaqueType = TA;
  u.optionalCallExpression = Oh;
  u.optionalIndexedAccessType = VA;
  u.optionalMemberExpression = Ah;
  u.parenthesizedExpression = kg;
  u.pipelineBareFunction = vO;
  u.pipelinePrimaryTopicReference = PO;
  u.pipelineTopicExpression = EO;
  u.placeholder = sO;
  u.privateName = Ch;
  u.program = Lg;
  u.qualifiedTypeIdentifier = SA;
  u.recordExpression = yO;
  u.regExpLiteral = Wl;
  u.regexLiteral = jI;
  u.restElement = $l;
  u.restProperty = RI;
  u.returnStatement = Bg;
  u.sequenceExpression = Fg;
  u.spreadElement = Gl;
  u.spreadProperty = MI;
  u.staticBlock = wh;
  u.stringLiteral = Ig;
  u.stringLiteralTypeAnnotation = bA;
  u.stringTypeAnnotation = EA;
  u.super = Th;
  u.switchCase = Kg;
  u.switchStatement = qg;
  u.symbolTypeAnnotation = vA;
  u.taggedTemplateExpression = Sh;
  u.templateElement = bh;
  u.templateLiteral = Eh;
  u.thisExpression = Yg;
  u.thisTypeAnnotation = PA;
  u.throwStatement = Vg;
  u.topicReference = bO;
  u.tryStatement = Ug;
  u.tSAnyKeyword = u.tsAnyKeyword = CO;
  u.tSArrayType = u.tsArrayType = HO;
  u.tSAsExpression = u.tsAsExpression = TI;
  u.tSBigIntKeyword = u.tsBigIntKeyword = LO;
  u.tSBooleanKeyword = u.tsBooleanKeyword = wO;
  u.tSCallSignatureDeclaration = u.tsCallSignatureDeclaration = OO;
  u.tSConditionalType = u.tsConditionalType = aI;
  u.tSConstructSignatureDeclaration = u.tsConstructSignatureDeclaration = IO;
  u.tSConstructorType = u.tsConstructorType = XO;
  u.tSDeclareFunction = u.tsDeclareFunction = gO;
  u.tSDeclareMethod = u.tsDeclareMethod = hO;
  u.tSEnumDeclaration = u.tsEnumDeclaration = EI;
  u.tSEnumMember = u.tsEnumMember = vI;
  u.tSExportAssignment = u.tsExportAssignment = II;
  u.tSExpressionWithTypeArguments = u.tsExpressionWithTypeArguments = fI;
  u.tSExternalModuleReference = u.tsExternalModuleReference = AI;
  u.tSFunctionType = u.tsFunctionType = JO;
  u.tSImportEqualsDeclaration = u.tsImportEqualsDeclaration = hI;
  u.tSImportType = u.tsImportType = gI;
  u.tSIndexSignature = u.tsIndexSignature = NO;
  u.tSIndexedAccessType = u.tsIndexedAccessType = uI;
  u.tSInferType = u.tsInferType = iI;
  u.tSInstantiationExpression = u.tsInstantiationExpression = mI;
  u.tSInterfaceBody = u.tsInterfaceBody = dI;
  u.tSInterfaceDeclaration = u.tsInterfaceDeclaration = pI;
  u.tSIntersectionType = u.tsIntersectionType = nI;
  u.tSIntrinsicKeyword = u.tsIntrinsicKeyword = jO;
  u.tSLiteralType = u.tsLiteralType = cI;
  u.tSMappedType = u.tsMappedType = lI;
  u.tSMethodSignature = u.tsMethodSignature = DO;
  u.tSModuleBlock = u.tsModuleBlock = xI;
  u.tSModuleDeclaration = u.tsModuleDeclaration = PI;
  u.tSNamedTupleMember = u.tsNamedTupleMember = tI;
  u.tSNamespaceExportDeclaration = u.tsNamespaceExportDeclaration = _I;
  u.tSNeverKeyword = u.tsNeverKeyword = RO;
  u.tSNonNullExpression = u.tsNonNullExpression = OI;
  u.tSNullKeyword = u.tsNullKeyword = MO;
  u.tSNumberKeyword = u.tsNumberKeyword = BO;
  u.tSObjectKeyword = u.tsObjectKeyword = FO;
  u.tSOptionalType = u.tsOptionalType = ZO;
  u.tSParameterProperty = u.tsParameterProperty = xO;
  u.tSParenthesizedType = u.tsParenthesizedType = sI;
  u.tSPropertySignature = u.tsPropertySignature = _O;
  u.tSQualifiedName = u.tsQualifiedName = AO;
  u.tSRestType = u.tsRestType = eI;
  u.tSSatisfiesExpression = u.tsSatisfiesExpression = SI;
  u.tSStringKeyword = u.tsStringKeyword = kO;
  u.tSSymbolKeyword = u.tsSymbolKeyword = KO;
  u.tSThisType = u.tsThisType = UO;
  u.tSTupleType = u.tsTupleType = QO;
  u.tSTypeAliasDeclaration = u.tsTypeAliasDeclaration = yI;
  u.tSTypeAnnotation = u.tsTypeAnnotation = DI;
  u.tSTypeAssertion = u.tsTypeAssertion = bI;
  u.tSTypeLiteral = u.tsTypeLiteral = zO;
  u.tSTypeOperator = u.tsTypeOperator = oI;
  u.tSTypeParameter = u.tsTypeParameter = wI;
  u.tSTypeParameterDeclaration = u.tsTypeParameterDeclaration = CI;
  u.tSTypeParameterInstantiation = u.tsTypeParameterInstantiation = NI;
  u.tSTypePredicate = u.tsTypePredicate = $O;
  u.tSTypeQuery = u.tsTypeQuery = GO;
  u.tSTypeReference = u.tsTypeReference = WO;
  u.tSUndefinedKeyword = u.tsUndefinedKeyword = qO;
  u.tSUnionType = u.tsUnionType = rI;
  u.tSUnknownKeyword = u.tsUnknownKeyword = YO;
  u.tSVoidKeyword = u.tsVoidKeyword = VO;
  u.tupleExpression = mO;
  u.tupleTypeAnnotation = xA;
  u.typeAlias = hA;
  u.typeAnnotation = AA;
  u.typeCastExpression = OA;
  u.typeParameter = IA;
  u.typeParameterDeclaration = _A;
  u.typeParameterInstantiation = DA;
  u.typeofTypeAnnotation = gA;
  u.unaryExpression = Jg;
  u.unionTypeAnnotation = NA;
  u.updateExpression = Xg;
  u.v8IntrinsicIdentifier = oO;
  u.variableDeclaration = Wg;
  u.variableDeclarator = $g;
  u.variance = CA;
  u.voidTypeAnnotation = wA;
  u.whileStatement = Gg;
  u.withStatement = zg;
  u.yieldExpression = vh;
  var v = Jl(), Jr = $t();
  function ng(e = []) {
    return (0, v.default)({ type: "ArrayExpression", elements: e });
  }
  function ag(e, t, r) {
    return (0, v.default)({ type: "AssignmentExpression", operator: e, left: t, right: r });
  }
  function ig(e, t, r) {
    return (0, v.default)({ type: "BinaryExpression", operator: e, left: t, right: r });
  }
  function sg(e) {
    return (0, v.default)({ type: "InterpreterDirective", value: e });
  }
  function og(e) {
    return (0, v.default)({ type: "Directive", value: e });
  }
  function ug(e) {
    return (0, v.default)({ type: "DirectiveLiteral", value: e });
  }
  function lg(e, t = []) {
    return (0, v.default)({ type: "BlockStatement", body: e, directives: t });
  }
  function cg(e = null) {
    return (0, v.default)({ type: "BreakStatement", label: e });
  }
  function fg(e, t) {
    return (0, v.default)({ type: "CallExpression", callee: e, arguments: t });
  }
  function pg(e = null, t) {
    return (0, v.default)({ type: "CatchClause", param: e, body: t });
  }
  function dg(e, t, r) {
    return (0, v.default)({ type: "ConditionalExpression", test: e, consequent: t, alternate: r });
  }
  function yg(e = null) {
    return (0, v.default)({ type: "ContinueStatement", label: e });
  }
  function mg() {
    return { type: "DebuggerStatement" };
  }
  function Tg(e, t) {
    return (0, v.default)({ type: "DoWhileStatement", test: e, body: t });
  }
  function Sg() {
    return { type: "EmptyStatement" };
  }
  function bg(e) {
    return (0, v.default)({ type: "ExpressionStatement", expression: e });
  }
  function Eg(e, t = null, r = null) {
    return (0, v.default)({ type: "File", program: e, comments: t, tokens: r });
  }
  function vg(e, t, r) {
    return (0, v.default)({ type: "ForInStatement", left: e, right: t, body: r });
  }
  function Pg(e = null, t = null, r = null, n) {
    return (0, v.default)({ type: "ForStatement", init: e, test: t, update: r, body: n });
  }
  function xg(e = null, t, r, n = false, i = false) {
    return (0, v.default)({ type: "FunctionDeclaration", id: e, params: t, body: r, generator: n, async: i });
  }
  function gg(e = null, t, r, n = false, i = false) {
    return (0, v.default)({ type: "FunctionExpression", id: e, params: t, body: r, generator: n, async: i });
  }
  function hg(e) {
    return (0, v.default)({ type: "Identifier", name: e });
  }
  function Ag(e, t, r = null) {
    return (0, v.default)({ type: "IfStatement", test: e, consequent: t, alternate: r });
  }
  function Og(e, t) {
    return (0, v.default)({ type: "LabeledStatement", label: e, body: t });
  }
  function Ig(e) {
    return (0, v.default)({ type: "StringLiteral", value: e });
  }
  function Xl(e) {
    return (0, v.default)({ type: "NumericLiteral", value: e });
  }
  function _g() {
    return { type: "NullLiteral" };
  }
  function Dg(e) {
    return (0, v.default)({ type: "BooleanLiteral", value: e });
  }
  function Wl(e, t = "") {
    return (0, v.default)({ type: "RegExpLiteral", pattern: e, flags: t });
  }
  function Ng(e, t, r) {
    return (0, v.default)({ type: "LogicalExpression", operator: e, left: t, right: r });
  }
  function Cg(e, t, r = false, n = null) {
    return (0, v.default)({ type: "MemberExpression", object: e, property: t, computed: r, optional: n });
  }
  function wg(e, t) {
    return (0, v.default)({ type: "NewExpression", callee: e, arguments: t });
  }
  function Lg(e, t = [], r = "script", n = null) {
    return (0, v.default)({ type: "Program", body: e, directives: t, sourceType: r, interpreter: n, sourceFile: null });
  }
  function jg(e) {
    return (0, v.default)({ type: "ObjectExpression", properties: e });
  }
  function Rg(e = "method", t, r, n, i = false, l = false, y = false) {
    return (0, v.default)({ type: "ObjectMethod", kind: e, key: t, params: r, body: n, computed: i, generator: l, async: y });
  }
  function Mg(e, t, r = false, n = false, i = null) {
    return (0, v.default)({ type: "ObjectProperty", key: e, value: t, computed: r, shorthand: n, decorators: i });
  }
  function $l(e) {
    return (0, v.default)({ type: "RestElement", argument: e });
  }
  function Bg(e = null) {
    return (0, v.default)({ type: "ReturnStatement", argument: e });
  }
  function Fg(e) {
    return (0, v.default)({ type: "SequenceExpression", expressions: e });
  }
  function kg(e) {
    return (0, v.default)({ type: "ParenthesizedExpression", expression: e });
  }
  function Kg(e = null, t) {
    return (0, v.default)({ type: "SwitchCase", test: e, consequent: t });
  }
  function qg(e, t) {
    return (0, v.default)({ type: "SwitchStatement", discriminant: e, cases: t });
  }
  function Yg() {
    return { type: "ThisExpression" };
  }
  function Vg(e) {
    return (0, v.default)({ type: "ThrowStatement", argument: e });
  }
  function Ug(e, t = null, r = null) {
    return (0, v.default)({ type: "TryStatement", block: e, handler: t, finalizer: r });
  }
  function Jg(e, t, r = true) {
    return (0, v.default)({ type: "UnaryExpression", operator: e, argument: t, prefix: r });
  }
  function Xg(e, t, r = false) {
    return (0, v.default)({ type: "UpdateExpression", operator: e, argument: t, prefix: r });
  }
  function Wg(e, t) {
    return (0, v.default)({ type: "VariableDeclaration", kind: e, declarations: t });
  }
  function $g(e, t = null) {
    return (0, v.default)({ type: "VariableDeclarator", id: e, init: t });
  }
  function Gg(e, t) {
    return (0, v.default)({ type: "WhileStatement", test: e, body: t });
  }
  function zg(e, t) {
    return (0, v.default)({ type: "WithStatement", object: e, body: t });
  }
  function Hg(e, t) {
    return (0, v.default)({ type: "AssignmentPattern", left: e, right: t });
  }
  function Qg(e) {
    return (0, v.default)({ type: "ArrayPattern", elements: e });
  }
  function Zg(e, t, r = false) {
    return (0, v.default)({ type: "ArrowFunctionExpression", params: e, body: t, async: r, expression: null });
  }
  function eh(e) {
    return (0, v.default)({ type: "ClassBody", body: e });
  }
  function th(e = null, t = null, r, n = null) {
    return (0, v.default)({ type: "ClassExpression", id: e, superClass: t, body: r, decorators: n });
  }
  function rh(e = null, t = null, r, n = null) {
    return (0, v.default)({ type: "ClassDeclaration", id: e, superClass: t, body: r, decorators: n });
  }
  function nh(e) {
    return (0, v.default)({ type: "ExportAllDeclaration", source: e });
  }
  function ah(e) {
    return (0, v.default)({ type: "ExportDefaultDeclaration", declaration: e });
  }
  function ih(e = null, t = [], r = null) {
    return (0, v.default)({ type: "ExportNamedDeclaration", declaration: e, specifiers: t, source: r });
  }
  function sh(e, t) {
    return (0, v.default)({ type: "ExportSpecifier", local: e, exported: t });
  }
  function oh(e, t, r, n = false) {
    return (0, v.default)({ type: "ForOfStatement", left: e, right: t, body: r, await: n });
  }
  function uh(e, t) {
    return (0, v.default)({ type: "ImportDeclaration", specifiers: e, source: t });
  }
  function lh(e) {
    return (0, v.default)({ type: "ImportDefaultSpecifier", local: e });
  }
  function ch(e) {
    return (0, v.default)({ type: "ImportNamespaceSpecifier", local: e });
  }
  function fh(e, t) {
    return (0, v.default)({ type: "ImportSpecifier", local: e, imported: t });
  }
  function ph(e, t = null) {
    return (0, v.default)({ type: "ImportExpression", source: e, options: t });
  }
  function dh(e, t) {
    return (0, v.default)({ type: "MetaProperty", meta: e, property: t });
  }
  function yh(e = "method", t, r, n, i = false, l = false, y = false, S = false) {
    return (0, v.default)({ type: "ClassMethod", kind: e, key: t, params: r, body: n, computed: i, static: l, generator: y, async: S });
  }
  function mh(e) {
    return (0, v.default)({ type: "ObjectPattern", properties: e });
  }
  function Gl(e) {
    return (0, v.default)({ type: "SpreadElement", argument: e });
  }
  function Th() {
    return { type: "Super" };
  }
  function Sh(e, t) {
    return (0, v.default)({ type: "TaggedTemplateExpression", tag: e, quasi: t });
  }
  function bh(e, t = false) {
    return (0, v.default)({ type: "TemplateElement", value: e, tail: t });
  }
  function Eh(e, t) {
    return (0, v.default)({ type: "TemplateLiteral", quasis: e, expressions: t });
  }
  function vh(e = null, t = false) {
    return (0, v.default)({ type: "YieldExpression", argument: e, delegate: t });
  }
  function Ph(e) {
    return (0, v.default)({ type: "AwaitExpression", argument: e });
  }
  function xh() {
    return { type: "Import" };
  }
  function gh(e) {
    return (0, v.default)({ type: "BigIntLiteral", value: e });
  }
  function hh(e) {
    return (0, v.default)({ type: "ExportNamespaceSpecifier", exported: e });
  }
  function Ah(e, t, r = false, n) {
    return (0, v.default)({ type: "OptionalMemberExpression", object: e, property: t, computed: r, optional: n });
  }
  function Oh(e, t, r) {
    return (0, v.default)({ type: "OptionalCallExpression", callee: e, arguments: t, optional: r });
  }
  function Ih(e, t = null, r = null, n = null, i = false, l = false) {
    return (0, v.default)({ type: "ClassProperty", key: e, value: t, typeAnnotation: r, decorators: n, computed: i, static: l });
  }
  function _h(e, t = null, r = null, n = null, i = false, l = false) {
    return (0, v.default)({ type: "ClassAccessorProperty", key: e, value: t, typeAnnotation: r, decorators: n, computed: i, static: l });
  }
  function Dh(e, t = null, r = null, n = false) {
    return (0, v.default)({ type: "ClassPrivateProperty", key: e, value: t, decorators: r, static: n });
  }
  function Nh(e = "method", t, r, n, i = false) {
    return (0, v.default)({ type: "ClassPrivateMethod", kind: e, key: t, params: r, body: n, static: i });
  }
  function Ch(e) {
    return (0, v.default)({ type: "PrivateName", id: e });
  }
  function wh(e) {
    return (0, v.default)({ type: "StaticBlock", body: e });
  }
  function Lh() {
    return { type: "AnyTypeAnnotation" };
  }
  function jh(e) {
    return (0, v.default)({ type: "ArrayTypeAnnotation", elementType: e });
  }
  function Rh() {
    return { type: "BooleanTypeAnnotation" };
  }
  function Mh(e) {
    return (0, v.default)({ type: "BooleanLiteralTypeAnnotation", value: e });
  }
  function Bh() {
    return { type: "NullLiteralTypeAnnotation" };
  }
  function Fh(e, t = null) {
    return (0, v.default)({ type: "ClassImplements", id: e, typeParameters: t });
  }
  function kh(e, t = null, r = null, n) {
    return (0, v.default)({ type: "DeclareClass", id: e, typeParameters: t, extends: r, body: n });
  }
  function Kh(e) {
    return (0, v.default)({ type: "DeclareFunction", id: e });
  }
  function qh(e, t = null, r = null, n) {
    return (0, v.default)({ type: "DeclareInterface", id: e, typeParameters: t, extends: r, body: n });
  }
  function Yh(e, t, r = null) {
    return (0, v.default)({ type: "DeclareModule", id: e, body: t, kind: r });
  }
  function Vh(e) {
    return (0, v.default)({ type: "DeclareModuleExports", typeAnnotation: e });
  }
  function Uh(e, t = null, r) {
    return (0, v.default)({ type: "DeclareTypeAlias", id: e, typeParameters: t, right: r });
  }
  function Jh(e, t = null, r = null) {
    return (0, v.default)({ type: "DeclareOpaqueType", id: e, typeParameters: t, supertype: r });
  }
  function Xh(e) {
    return (0, v.default)({ type: "DeclareVariable", id: e });
  }
  function Wh(e = null, t = null, r = null) {
    return (0, v.default)({ type: "DeclareExportDeclaration", declaration: e, specifiers: t, source: r });
  }
  function $h(e) {
    return (0, v.default)({ type: "DeclareExportAllDeclaration", source: e });
  }
  function Gh(e) {
    return (0, v.default)({ type: "DeclaredPredicate", value: e });
  }
  function zh() {
    return { type: "ExistsTypeAnnotation" };
  }
  function Hh(e = null, t, r = null, n) {
    return (0, v.default)({ type: "FunctionTypeAnnotation", typeParameters: e, params: t, rest: r, returnType: n });
  }
  function Qh(e = null, t) {
    return (0, v.default)({ type: "FunctionTypeParam", name: e, typeAnnotation: t });
  }
  function Zh(e, t = null) {
    return (0, v.default)({ type: "GenericTypeAnnotation", id: e, typeParameters: t });
  }
  function eA() {
    return { type: "InferredPredicate" };
  }
  function tA(e, t = null) {
    return (0, v.default)({ type: "InterfaceExtends", id: e, typeParameters: t });
  }
  function rA(e, t = null, r = null, n) {
    return (0, v.default)({ type: "InterfaceDeclaration", id: e, typeParameters: t, extends: r, body: n });
  }
  function nA(e = null, t) {
    return (0, v.default)({ type: "InterfaceTypeAnnotation", extends: e, body: t });
  }
  function aA(e) {
    return (0, v.default)({ type: "IntersectionTypeAnnotation", types: e });
  }
  function iA() {
    return { type: "MixedTypeAnnotation" };
  }
  function sA() {
    return { type: "EmptyTypeAnnotation" };
  }
  function oA(e) {
    return (0, v.default)({ type: "NullableTypeAnnotation", typeAnnotation: e });
  }
  function uA(e) {
    return (0, v.default)({ type: "NumberLiteralTypeAnnotation", value: e });
  }
  function lA() {
    return { type: "NumberTypeAnnotation" };
  }
  function cA(e, t = [], r = [], n = [], i = false) {
    return (0, v.default)({ type: "ObjectTypeAnnotation", properties: e, indexers: t, callProperties: r, internalSlots: n, exact: i });
  }
  function fA(e, t, r, n, i) {
    return (0, v.default)({ type: "ObjectTypeInternalSlot", id: e, value: t, optional: r, static: n, method: i });
  }
  function pA(e) {
    return (0, v.default)({ type: "ObjectTypeCallProperty", value: e, static: null });
  }
  function dA(e = null, t, r, n = null) {
    return (0, v.default)({ type: "ObjectTypeIndexer", id: e, key: t, value: r, variance: n, static: null });
  }
  function yA(e, t, r = null) {
    return (0, v.default)({ type: "ObjectTypeProperty", key: e, value: t, variance: r, kind: null, method: null, optional: null, proto: null, static: null });
  }
  function mA(e) {
    return (0, v.default)({ type: "ObjectTypeSpreadProperty", argument: e });
  }
  function TA(e, t = null, r = null, n) {
    return (0, v.default)({ type: "OpaqueType", id: e, typeParameters: t, supertype: r, impltype: n });
  }
  function SA(e, t) {
    return (0, v.default)({ type: "QualifiedTypeIdentifier", id: e, qualification: t });
  }
  function bA(e) {
    return (0, v.default)({ type: "StringLiteralTypeAnnotation", value: e });
  }
  function EA() {
    return { type: "StringTypeAnnotation" };
  }
  function vA() {
    return { type: "SymbolTypeAnnotation" };
  }
  function PA() {
    return { type: "ThisTypeAnnotation" };
  }
  function xA(e) {
    return (0, v.default)({ type: "TupleTypeAnnotation", types: e });
  }
  function gA(e) {
    return (0, v.default)({ type: "TypeofTypeAnnotation", argument: e });
  }
  function hA(e, t = null, r) {
    return (0, v.default)({ type: "TypeAlias", id: e, typeParameters: t, right: r });
  }
  function AA(e) {
    return (0, v.default)({ type: "TypeAnnotation", typeAnnotation: e });
  }
  function OA(e, t) {
    return (0, v.default)({ type: "TypeCastExpression", expression: e, typeAnnotation: t });
  }
  function IA(e = null, t = null, r = null) {
    return (0, v.default)({ type: "TypeParameter", bound: e, default: t, variance: r, name: null });
  }
  function _A(e) {
    return (0, v.default)({ type: "TypeParameterDeclaration", params: e });
  }
  function DA(e) {
    return (0, v.default)({ type: "TypeParameterInstantiation", params: e });
  }
  function NA(e) {
    return (0, v.default)({ type: "UnionTypeAnnotation", types: e });
  }
  function CA(e) {
    return (0, v.default)({ type: "Variance", kind: e });
  }
  function wA() {
    return { type: "VoidTypeAnnotation" };
  }
  function LA(e, t) {
    return (0, v.default)({ type: "EnumDeclaration", id: e, body: t });
  }
  function jA(e) {
    return (0, v.default)({ type: "EnumBooleanBody", members: e, explicitType: null, hasUnknownMembers: null });
  }
  function RA(e) {
    return (0, v.default)({ type: "EnumNumberBody", members: e, explicitType: null, hasUnknownMembers: null });
  }
  function MA(e) {
    return (0, v.default)({ type: "EnumStringBody", members: e, explicitType: null, hasUnknownMembers: null });
  }
  function BA(e) {
    return (0, v.default)({ type: "EnumSymbolBody", members: e, hasUnknownMembers: null });
  }
  function FA(e) {
    return (0, v.default)({ type: "EnumBooleanMember", id: e, init: null });
  }
  function kA(e, t) {
    return (0, v.default)({ type: "EnumNumberMember", id: e, init: t });
  }
  function KA(e, t) {
    return (0, v.default)({ type: "EnumStringMember", id: e, init: t });
  }
  function qA(e) {
    return (0, v.default)({ type: "EnumDefaultedMember", id: e });
  }
  function YA(e, t) {
    return (0, v.default)({ type: "IndexedAccessType", objectType: e, indexType: t });
  }
  function VA(e, t) {
    return (0, v.default)({ type: "OptionalIndexedAccessType", objectType: e, indexType: t, optional: null });
  }
  function UA(e, t = null) {
    return (0, v.default)({ type: "JSXAttribute", name: e, value: t });
  }
  function JA(e) {
    return (0, v.default)({ type: "JSXClosingElement", name: e });
  }
  function XA(e, t = null, r, n = null) {
    return (0, v.default)({ type: "JSXElement", openingElement: e, closingElement: t, children: r, selfClosing: n });
  }
  function WA() {
    return { type: "JSXEmptyExpression" };
  }
  function $A(e) {
    return (0, v.default)({ type: "JSXExpressionContainer", expression: e });
  }
  function GA(e) {
    return (0, v.default)({ type: "JSXSpreadChild", expression: e });
  }
  function zA(e) {
    return (0, v.default)({ type: "JSXIdentifier", name: e });
  }
  function HA(e, t) {
    return (0, v.default)({ type: "JSXMemberExpression", object: e, property: t });
  }
  function QA(e, t) {
    return (0, v.default)({ type: "JSXNamespacedName", namespace: e, name: t });
  }
  function ZA(e, t, r = false) {
    return (0, v.default)({ type: "JSXOpeningElement", name: e, attributes: t, selfClosing: r });
  }
  function eO(e) {
    return (0, v.default)({ type: "JSXSpreadAttribute", argument: e });
  }
  function tO(e) {
    return (0, v.default)({ type: "JSXText", value: e });
  }
  function rO(e, t, r) {
    return (0, v.default)({ type: "JSXFragment", openingFragment: e, closingFragment: t, children: r });
  }
  function nO() {
    return { type: "JSXOpeningFragment" };
  }
  function aO() {
    return { type: "JSXClosingFragment" };
  }
  function iO() {
    return { type: "Noop" };
  }
  function sO(e, t) {
    return (0, v.default)({ type: "Placeholder", expectedNode: e, name: t });
  }
  function oO(e) {
    return (0, v.default)({ type: "V8IntrinsicIdentifier", name: e });
  }
  function uO() {
    return { type: "ArgumentPlaceholder" };
  }
  function lO(e, t) {
    return (0, v.default)({ type: "BindExpression", object: e, callee: t });
  }
  function cO(e, t) {
    return (0, v.default)({ type: "ImportAttribute", key: e, value: t });
  }
  function fO(e) {
    return (0, v.default)({ type: "Decorator", expression: e });
  }
  function pO(e, t = false) {
    return (0, v.default)({ type: "DoExpression", body: e, async: t });
  }
  function dO(e) {
    return (0, v.default)({ type: "ExportDefaultSpecifier", exported: e });
  }
  function yO(e) {
    return (0, v.default)({ type: "RecordExpression", properties: e });
  }
  function mO(e = []) {
    return (0, v.default)({ type: "TupleExpression", elements: e });
  }
  function TO(e) {
    return (0, v.default)({ type: "DecimalLiteral", value: e });
  }
  function SO(e) {
    return (0, v.default)({ type: "ModuleExpression", body: e });
  }
  function bO() {
    return { type: "TopicReference" };
  }
  function EO(e) {
    return (0, v.default)({ type: "PipelineTopicExpression", expression: e });
  }
  function vO(e) {
    return (0, v.default)({ type: "PipelineBareFunction", callee: e });
  }
  function PO() {
    return { type: "PipelinePrimaryTopicReference" };
  }
  function xO(e) {
    return (0, v.default)({ type: "TSParameterProperty", parameter: e });
  }
  function gO(e = null, t = null, r, n = null) {
    return (0, v.default)({ type: "TSDeclareFunction", id: e, typeParameters: t, params: r, returnType: n });
  }
  function hO(e = null, t, r = null, n, i = null) {
    return (0, v.default)({ type: "TSDeclareMethod", decorators: e, key: t, typeParameters: r, params: n, returnType: i });
  }
  function AO(e, t) {
    return (0, v.default)({ type: "TSQualifiedName", left: e, right: t });
  }
  function OO(e = null, t, r = null) {
    return (0, v.default)({ type: "TSCallSignatureDeclaration", typeParameters: e, parameters: t, typeAnnotation: r });
  }
  function IO(e = null, t, r = null) {
    return (0, v.default)({ type: "TSConstructSignatureDeclaration", typeParameters: e, parameters: t, typeAnnotation: r });
  }
  function _O(e, t = null) {
    return (0, v.default)({ type: "TSPropertySignature", key: e, typeAnnotation: t, kind: null });
  }
  function DO(e, t = null, r, n = null) {
    return (0, v.default)({ type: "TSMethodSignature", key: e, typeParameters: t, parameters: r, typeAnnotation: n, kind: null });
  }
  function NO(e, t = null) {
    return (0, v.default)({ type: "TSIndexSignature", parameters: e, typeAnnotation: t });
  }
  function CO() {
    return { type: "TSAnyKeyword" };
  }
  function wO() {
    return { type: "TSBooleanKeyword" };
  }
  function LO() {
    return { type: "TSBigIntKeyword" };
  }
  function jO() {
    return { type: "TSIntrinsicKeyword" };
  }
  function RO() {
    return { type: "TSNeverKeyword" };
  }
  function MO() {
    return { type: "TSNullKeyword" };
  }
  function BO() {
    return { type: "TSNumberKeyword" };
  }
  function FO() {
    return { type: "TSObjectKeyword" };
  }
  function kO() {
    return { type: "TSStringKeyword" };
  }
  function KO() {
    return { type: "TSSymbolKeyword" };
  }
  function qO() {
    return { type: "TSUndefinedKeyword" };
  }
  function YO() {
    return { type: "TSUnknownKeyword" };
  }
  function VO() {
    return { type: "TSVoidKeyword" };
  }
  function UO() {
    return { type: "TSThisType" };
  }
  function JO(e = null, t, r = null) {
    return (0, v.default)({ type: "TSFunctionType", typeParameters: e, parameters: t, typeAnnotation: r });
  }
  function XO(e = null, t, r = null) {
    return (0, v.default)({ type: "TSConstructorType", typeParameters: e, parameters: t, typeAnnotation: r });
  }
  function WO(e, t = null) {
    return (0, v.default)({ type: "TSTypeReference", typeName: e, typeParameters: t });
  }
  function $O(e, t = null, r = null) {
    return (0, v.default)({ type: "TSTypePredicate", parameterName: e, typeAnnotation: t, asserts: r });
  }
  function GO(e, t = null) {
    return (0, v.default)({ type: "TSTypeQuery", exprName: e, typeParameters: t });
  }
  function zO(e) {
    return (0, v.default)({ type: "TSTypeLiteral", members: e });
  }
  function HO(e) {
    return (0, v.default)({ type: "TSArrayType", elementType: e });
  }
  function QO(e) {
    return (0, v.default)({ type: "TSTupleType", elementTypes: e });
  }
  function ZO(e) {
    return (0, v.default)({ type: "TSOptionalType", typeAnnotation: e });
  }
  function eI(e) {
    return (0, v.default)({ type: "TSRestType", typeAnnotation: e });
  }
  function tI(e, t, r = false) {
    return (0, v.default)({ type: "TSNamedTupleMember", label: e, elementType: t, optional: r });
  }
  function rI(e) {
    return (0, v.default)({ type: "TSUnionType", types: e });
  }
  function nI(e) {
    return (0, v.default)({ type: "TSIntersectionType", types: e });
  }
  function aI(e, t, r, n) {
    return (0, v.default)({ type: "TSConditionalType", checkType: e, extendsType: t, trueType: r, falseType: n });
  }
  function iI(e) {
    return (0, v.default)({ type: "TSInferType", typeParameter: e });
  }
  function sI(e) {
    return (0, v.default)({ type: "TSParenthesizedType", typeAnnotation: e });
  }
  function oI(e) {
    return (0, v.default)({ type: "TSTypeOperator", typeAnnotation: e, operator: null });
  }
  function uI(e, t) {
    return (0, v.default)({ type: "TSIndexedAccessType", objectType: e, indexType: t });
  }
  function lI(e, t = null, r = null) {
    return (0, v.default)({ type: "TSMappedType", typeParameter: e, typeAnnotation: t, nameType: r });
  }
  function cI(e) {
    return (0, v.default)({ type: "TSLiteralType", literal: e });
  }
  function fI(e, t = null) {
    return (0, v.default)({ type: "TSExpressionWithTypeArguments", expression: e, typeParameters: t });
  }
  function pI(e, t = null, r = null, n) {
    return (0, v.default)({ type: "TSInterfaceDeclaration", id: e, typeParameters: t, extends: r, body: n });
  }
  function dI(e) {
    return (0, v.default)({ type: "TSInterfaceBody", body: e });
  }
  function yI(e, t = null, r) {
    return (0, v.default)({ type: "TSTypeAliasDeclaration", id: e, typeParameters: t, typeAnnotation: r });
  }
  function mI(e, t = null) {
    return (0, v.default)({ type: "TSInstantiationExpression", expression: e, typeParameters: t });
  }
  function TI(e, t) {
    return (0, v.default)({ type: "TSAsExpression", expression: e, typeAnnotation: t });
  }
  function SI(e, t) {
    return (0, v.default)({ type: "TSSatisfiesExpression", expression: e, typeAnnotation: t });
  }
  function bI(e, t) {
    return (0, v.default)({ type: "TSTypeAssertion", typeAnnotation: e, expression: t });
  }
  function EI(e, t) {
    return (0, v.default)({ type: "TSEnumDeclaration", id: e, members: t });
  }
  function vI(e, t = null) {
    return (0, v.default)({ type: "TSEnumMember", id: e, initializer: t });
  }
  function PI(e, t) {
    return (0, v.default)({ type: "TSModuleDeclaration", id: e, body: t });
  }
  function xI(e) {
    return (0, v.default)({ type: "TSModuleBlock", body: e });
  }
  function gI(e, t = null, r = null) {
    return (0, v.default)({ type: "TSImportType", argument: e, qualifier: t, typeParameters: r });
  }
  function hI(e, t) {
    return (0, v.default)({ type: "TSImportEqualsDeclaration", id: e, moduleReference: t, isExport: null });
  }
  function AI(e) {
    return (0, v.default)({ type: "TSExternalModuleReference", expression: e });
  }
  function OI(e) {
    return (0, v.default)({ type: "TSNonNullExpression", expression: e });
  }
  function II(e) {
    return (0, v.default)({ type: "TSExportAssignment", expression: e });
  }
  function _I(e) {
    return (0, v.default)({ type: "TSNamespaceExportDeclaration", id: e });
  }
  function DI(e) {
    return (0, v.default)({ type: "TSTypeAnnotation", typeAnnotation: e });
  }
  function NI(e) {
    return (0, v.default)({ type: "TSTypeParameterInstantiation", params: e });
  }
  function CI(e) {
    return (0, v.default)({ type: "TSTypeParameterDeclaration", params: e });
  }
  function wI(e = null, t = null, r) {
    return (0, v.default)({ type: "TSTypeParameter", constraint: e, default: t, name: r });
  }
  function LI(e) {
    return (0, Jr.default)("NumberLiteral", "NumericLiteral", "The node type "), Xl(e);
  }
  function jI(e, t = "") {
    return (0, Jr.default)("RegexLiteral", "RegExpLiteral", "The node type "), Wl(e, t);
  }
  function RI(e) {
    return (0, Jr.default)("RestProperty", "RestElement", "The node type "), $l(e);
  }
  function MI(e) {
    return (0, Jr.default)("SpreadProperty", "SpreadElement", "The node type "), Gl(e);
  }
});
var zl = x((ga) => {
  "use strict";
  o();
  Object.defineProperty(ga, "__esModule", { value: true });
  ga.default = kI;
  var BI = Ae(), FI = ir();
  function kI(e, t) {
    let r = e.value.split(/\r\n|\n|\r/), n = 0;
    for (let l = 0; l < r.length; l++)
      r[l].match(/[^ \t]/) && (n = l);
    let i = "";
    for (let l = 0; l < r.length; l++) {
      let y = r[l], S = l === 0, P = l === r.length - 1, A = l === n, L = y.replace(/\t/g, " ");
      S || (L = L.replace(/^[ ]+/, "")), P || (L = L.replace(/[ ]+$/, "")), L && (A || (L += " "), i += L);
    }
    i && t.push((0, FI.inherits)((0, BI.stringLiteral)(i), e));
  }
});
var Hl = x((Aa) => {
  "use strict";
  o();
  Object.defineProperty(Aa, "__esModule", { value: true });
  Aa.default = qI;
  var ha = pe(), KI = zl();
  function qI(e) {
    let t = [];
    for (let r = 0; r < e.children.length; r++) {
      let n = e.children[r];
      if ((0, ha.isJSXText)(n)) {
        (0, KI.default)(n, t);
        continue;
      }
      (0, ha.isJSXExpressionContainer)(n) && (n = n.expression), !(0, ha.isJSXEmptyExpression)(n) && t.push(n);
    }
    return t;
  }
});
var Ia = x((Oa) => {
  "use strict";
  o();
  Object.defineProperty(Oa, "__esModule", { value: true });
  Oa.default = VI;
  var YI = je();
  function VI(e) {
    return !!(e && YI.VISITOR_KEYS[e.type]);
  }
});
var Ql = x((_a) => {
  "use strict";
  o();
  Object.defineProperty(_a, "__esModule", { value: true });
  _a.default = JI;
  var UI = Ia();
  function JI(e) {
    if (!(0, UI.default)(e)) {
      var t;
      let r = (t = e == null ? void 0 : e.type) != null ? t : JSON.stringify(e);
      throw new TypeError(`Not a valid node of type "${r}"`);
    }
  }
});
var Zl = x((f) => {
  "use strict";
  o();
  Object.defineProperty(f, "__esModule", { value: true });
  f.assertAccessor = ow;
  f.assertAnyTypeAnnotation = ID;
  f.assertArgumentPlaceholder = rC;
  f.assertArrayExpression = WI;
  f.assertArrayPattern = J_;
  f.assertArrayTypeAnnotation = _D;
  f.assertArrowFunctionExpression = X_;
  f.assertAssignmentExpression = $I;
  f.assertAssignmentPattern = U_;
  f.assertAwaitExpression = mD;
  f.assertBigIntLiteral = SD;
  f.assertBinary = D1;
  f.assertBinaryExpression = GI;
  f.assertBindExpression = nC;
  f.assertBlock = w1;
  f.assertBlockParent = C1;
  f.assertBlockStatement = ZI;
  f.assertBooleanLiteral = v_;
  f.assertBooleanLiteralTypeAnnotation = ND;
  f.assertBooleanTypeAnnotation = DD;
  f.assertBreakStatement = e_;
  f.assertCallExpression = t_;
  f.assertCatchClause = r_;
  f.assertClass = nw;
  f.assertClassAccessorProperty = xD;
  f.assertClassBody = W_;
  f.assertClassDeclaration = G_;
  f.assertClassExpression = $_;
  f.assertClassImplements = wD;
  f.assertClassMethod = oD;
  f.assertClassPrivateMethod = hD;
  f.assertClassPrivateProperty = gD;
  f.assertClassProperty = PD;
  f.assertCompletionStatement = R1;
  f.assertConditional = M1;
  f.assertConditionalExpression = n_;
  f.assertContinueStatement = a_;
  f.assertDebuggerStatement = i_;
  f.assertDecimalLiteral = cC;
  f.assertDeclaration = J1;
  f.assertDeclareClass = LD;
  f.assertDeclareExportAllDeclaration = YD;
  f.assertDeclareExportDeclaration = qD;
  f.assertDeclareFunction = jD;
  f.assertDeclareInterface = RD;
  f.assertDeclareModule = MD;
  f.assertDeclareModuleExports = BD;
  f.assertDeclareOpaqueType = kD;
  f.assertDeclareTypeAlias = FD;
  f.assertDeclareVariable = KD;
  f.assertDeclaredPredicate = VD;
  f.assertDecorator = iC;
  f.assertDirective = HI;
  f.assertDirectiveLiteral = QI;
  f.assertDoExpression = sC;
  f.assertDoWhileStatement = s_;
  f.assertEmptyStatement = o_;
  f.assertEmptyTypeAnnotation = eN;
  f.assertEnumBody = yw;
  f.assertEnumBooleanBody = _N;
  f.assertEnumBooleanMember = wN;
  f.assertEnumDeclaration = IN;
  f.assertEnumDefaultedMember = RN;
  f.assertEnumMember = mw;
  f.assertEnumNumberBody = DN;
  f.assertEnumNumberMember = LN;
  f.assertEnumStringBody = NN;
  f.assertEnumStringMember = jN;
  f.assertEnumSymbolBody = CN;
  f.assertExistsTypeAnnotation = UD;
  f.assertExportAllDeclaration = z_;
  f.assertExportDeclaration = iw;
  f.assertExportDefaultDeclaration = H_;
  f.assertExportDefaultSpecifier = oC;
  f.assertExportNamedDeclaration = Q_;
  f.assertExportNamespaceSpecifier = bD;
  f.assertExportSpecifier = Z_;
  f.assertExpression = _1;
  f.assertExpressionStatement = u_;
  f.assertExpressionWrapper = k1;
  f.assertFile = l_;
  f.assertFlow = lw;
  f.assertFlowBaseAnnotation = fw;
  f.assertFlowDeclaration = pw;
  f.assertFlowPredicate = dw;
  f.assertFlowType = cw;
  f.assertFor = K1;
  f.assertForInStatement = c_;
  f.assertForOfStatement = eD;
  f.assertForStatement = f_;
  f.assertForXStatement = q1;
  f.assertFunction = Y1;
  f.assertFunctionDeclaration = p_;
  f.assertFunctionExpression = d_;
  f.assertFunctionParent = V1;
  f.assertFunctionTypeAnnotation = JD;
  f.assertFunctionTypeParam = XD;
  f.assertGenericTypeAnnotation = WD;
  f.assertIdentifier = y_;
  f.assertIfStatement = m_;
  f.assertImmutable = z1;
  f.assertImport = TD;
  f.assertImportAttribute = aC;
  f.assertImportDeclaration = tD;
  f.assertImportDefaultSpecifier = rD;
  f.assertImportExpression = iD;
  f.assertImportNamespaceSpecifier = nD;
  f.assertImportOrExportDeclaration = aw;
  f.assertImportSpecifier = aD;
  f.assertIndexedAccessType = MN;
  f.assertInferredPredicate = $D;
  f.assertInterfaceDeclaration = zD;
  f.assertInterfaceExtends = GD;
  f.assertInterfaceTypeAnnotation = HD;
  f.assertInterpreterDirective = zI;
  f.assertIntersectionTypeAnnotation = QD;
  f.assertJSX = Tw;
  f.assertJSXAttribute = FN;
  f.assertJSXClosingElement = kN;
  f.assertJSXClosingFragment = QN;
  f.assertJSXElement = KN;
  f.assertJSXEmptyExpression = qN;
  f.assertJSXExpressionContainer = YN;
  f.assertJSXFragment = zN;
  f.assertJSXIdentifier = UN;
  f.assertJSXMemberExpression = JN;
  f.assertJSXNamespacedName = XN;
  f.assertJSXOpeningElement = WN;
  f.assertJSXOpeningFragment = HN;
  f.assertJSXSpreadAttribute = $N;
  f.assertJSXSpreadChild = VN;
  f.assertJSXText = GN;
  f.assertLVal = W1;
  f.assertLabeledStatement = T_;
  f.assertLiteral = G1;
  f.assertLogicalExpression = x_;
  f.assertLoop = B1;
  f.assertMemberExpression = g_;
  f.assertMetaProperty = sD;
  f.assertMethod = Q1;
  f.assertMiscellaneous = Sw;
  f.assertMixedTypeAnnotation = ZD;
  f.assertModuleDeclaration = Ow;
  f.assertModuleExpression = fC;
  f.assertModuleSpecifier = sw;
  f.assertNewExpression = h_;
  f.assertNoop = ZN;
  f.assertNullLiteral = E_;
  f.assertNullLiteralTypeAnnotation = CD;
  f.assertNullableTypeAnnotation = tN;
  f.assertNumberLiteral = xw;
  f.assertNumberLiteralTypeAnnotation = rN;
  f.assertNumberTypeAnnotation = nN;
  f.assertNumericLiteral = b_;
  f.assertObjectExpression = O_;
  f.assertObjectMember = Z1;
  f.assertObjectMethod = I_;
  f.assertObjectPattern = uD;
  f.assertObjectProperty = __;
  f.assertObjectTypeAnnotation = aN;
  f.assertObjectTypeCallProperty = sN;
  f.assertObjectTypeIndexer = oN;
  f.assertObjectTypeInternalSlot = iN;
  f.assertObjectTypeProperty = uN;
  f.assertObjectTypeSpreadProperty = lN;
  f.assertOpaqueType = cN;
  f.assertOptionalCallExpression = vD;
  f.assertOptionalIndexedAccessType = BN;
  f.assertOptionalMemberExpression = ED;
  f.assertParenthesizedExpression = w_;
  f.assertPattern = rw;
  f.assertPatternLike = X1;
  f.assertPipelineBareFunction = yC;
  f.assertPipelinePrimaryTopicReference = mC;
  f.assertPipelineTopicExpression = dC;
  f.assertPlaceholder = eC;
  f.assertPrivate = uw;
  f.assertPrivateName = AD;
  f.assertProgram = A_;
  f.assertProperty = ew;
  f.assertPureish = U1;
  f.assertQualifiedTypeIdentifier = fN;
  f.assertRecordExpression = uC;
  f.assertRegExpLiteral = P_;
  f.assertRegexLiteral = gw;
  f.assertRestElement = D_;
  f.assertRestProperty = hw;
  f.assertReturnStatement = N_;
  f.assertScopable = N1;
  f.assertSequenceExpression = C_;
  f.assertSpreadElement = lD;
  f.assertSpreadProperty = Aw;
  f.assertStandardized = I1;
  f.assertStatement = L1;
  f.assertStaticBlock = OD;
  f.assertStringLiteral = S_;
  f.assertStringLiteralTypeAnnotation = pN;
  f.assertStringTypeAnnotation = dN;
  f.assertSuper = cD;
  f.assertSwitchCase = L_;
  f.assertSwitchStatement = j_;
  f.assertSymbolTypeAnnotation = yN;
  f.assertTSAnyKeyword = AC;
  f.assertTSArrayType = JC;
  f.assertTSAsExpression = c1;
  f.assertTSBaseType = Pw;
  f.assertTSBigIntKeyword = IC;
  f.assertTSBooleanKeyword = OC;
  f.assertTSCallSignatureDeclaration = vC;
  f.assertTSConditionalType = QC;
  f.assertTSConstructSignatureDeclaration = PC;
  f.assertTSConstructorType = KC;
  f.assertTSDeclareFunction = SC;
  f.assertTSDeclareMethod = bC;
  f.assertTSEntityName = $1;
  f.assertTSEnumDeclaration = d1;
  f.assertTSEnumMember = y1;
  f.assertTSExportAssignment = P1;
  f.assertTSExpressionWithTypeArguments = i1;
  f.assertTSExternalModuleReference = E1;
  f.assertTSFunctionType = kC;
  f.assertTSImportEqualsDeclaration = b1;
  f.assertTSImportType = S1;
  f.assertTSIndexSignature = hC;
  f.assertTSIndexedAccessType = r1;
  f.assertTSInferType = ZC;
  f.assertTSInstantiationExpression = l1;
  f.assertTSInterfaceBody = o1;
  f.assertTSInterfaceDeclaration = s1;
  f.assertTSIntersectionType = HC;
  f.assertTSIntrinsicKeyword = _C;
  f.assertTSLiteralType = a1;
  f.assertTSMappedType = n1;
  f.assertTSMethodSignature = gC;
  f.assertTSModuleBlock = T1;
  f.assertTSModuleDeclaration = m1;
  f.assertTSNamedTupleMember = GC;
  f.assertTSNamespaceExportDeclaration = x1;
  f.assertTSNeverKeyword = DC;
  f.assertTSNonNullExpression = v1;
  f.assertTSNullKeyword = NC;
  f.assertTSNumberKeyword = CC;
  f.assertTSObjectKeyword = wC;
  f.assertTSOptionalType = WC;
  f.assertTSParameterProperty = TC;
  f.assertTSParenthesizedType = e1;
  f.assertTSPropertySignature = xC;
  f.assertTSQualifiedName = EC;
  f.assertTSRestType = $C;
  f.assertTSSatisfiesExpression = f1;
  f.assertTSStringKeyword = LC;
  f.assertTSSymbolKeyword = jC;
  f.assertTSThisType = FC;
  f.assertTSTupleType = XC;
  f.assertTSType = vw;
  f.assertTSTypeAliasDeclaration = u1;
  f.assertTSTypeAnnotation = g1;
  f.assertTSTypeAssertion = p1;
  f.assertTSTypeElement = Ew;
  f.assertTSTypeLiteral = UC;
  f.assertTSTypeOperator = t1;
  f.assertTSTypeParameter = O1;
  f.assertTSTypeParameterDeclaration = A1;
  f.assertTSTypeParameterInstantiation = h1;
  f.assertTSTypePredicate = YC;
  f.assertTSTypeQuery = VC;
  f.assertTSTypeReference = qC;
  f.assertTSUndefinedKeyword = RC;
  f.assertTSUnionType = zC;
  f.assertTSUnknownKeyword = MC;
  f.assertTSVoidKeyword = BC;
  f.assertTaggedTemplateExpression = fD;
  f.assertTemplateElement = pD;
  f.assertTemplateLiteral = dD;
  f.assertTerminatorless = j1;
  f.assertThisExpression = R_;
  f.assertThisTypeAnnotation = mN;
  f.assertThrowStatement = M_;
  f.assertTopicReference = pC;
  f.assertTryStatement = B_;
  f.assertTupleExpression = lC;
  f.assertTupleTypeAnnotation = TN;
  f.assertTypeAlias = bN;
  f.assertTypeAnnotation = EN;
  f.assertTypeCastExpression = vN;
  f.assertTypeParameter = PN;
  f.assertTypeParameterDeclaration = xN;
  f.assertTypeParameterInstantiation = gN;
  f.assertTypeScript = bw;
  f.assertTypeofTypeAnnotation = SN;
  f.assertUnaryExpression = F_;
  f.assertUnaryLike = tw;
  f.assertUnionTypeAnnotation = hN;
  f.assertUpdateExpression = k_;
  f.assertUserWhitespacable = H1;
  f.assertV8IntrinsicIdentifier = tC;
  f.assertVariableDeclaration = K_;
  f.assertVariableDeclarator = q_;
  f.assertVariance = AN;
  f.assertVoidTypeAnnotation = ON;
  f.assertWhile = F1;
  f.assertWhileStatement = Y_;
  f.assertWithStatement = V_;
  f.assertYieldExpression = yD;
  var XI = gt(), sr = $t();
  function p(e, t, r) {
    if (!(0, XI.default)(e, t, r))
      throw new Error(`Expected type "${e}" with option ${JSON.stringify(r)}, but instead got "${t.type}".`);
  }
  function WI(e, t) {
    p("ArrayExpression", e, t);
  }
  function $I(e, t) {
    p("AssignmentExpression", e, t);
  }
  function GI(e, t) {
    p("BinaryExpression", e, t);
  }
  function zI(e, t) {
    p("InterpreterDirective", e, t);
  }
  function HI(e, t) {
    p("Directive", e, t);
  }
  function QI(e, t) {
    p("DirectiveLiteral", e, t);
  }
  function ZI(e, t) {
    p("BlockStatement", e, t);
  }
  function e_(e, t) {
    p("BreakStatement", e, t);
  }
  function t_(e, t) {
    p("CallExpression", e, t);
  }
  function r_(e, t) {
    p("CatchClause", e, t);
  }
  function n_(e, t) {
    p("ConditionalExpression", e, t);
  }
  function a_(e, t) {
    p("ContinueStatement", e, t);
  }
  function i_(e, t) {
    p("DebuggerStatement", e, t);
  }
  function s_(e, t) {
    p("DoWhileStatement", e, t);
  }
  function o_(e, t) {
    p("EmptyStatement", e, t);
  }
  function u_(e, t) {
    p("ExpressionStatement", e, t);
  }
  function l_(e, t) {
    p("File", e, t);
  }
  function c_(e, t) {
    p("ForInStatement", e, t);
  }
  function f_(e, t) {
    p("ForStatement", e, t);
  }
  function p_(e, t) {
    p("FunctionDeclaration", e, t);
  }
  function d_(e, t) {
    p("FunctionExpression", e, t);
  }
  function y_(e, t) {
    p("Identifier", e, t);
  }
  function m_(e, t) {
    p("IfStatement", e, t);
  }
  function T_(e, t) {
    p("LabeledStatement", e, t);
  }
  function S_(e, t) {
    p("StringLiteral", e, t);
  }
  function b_(e, t) {
    p("NumericLiteral", e, t);
  }
  function E_(e, t) {
    p("NullLiteral", e, t);
  }
  function v_(e, t) {
    p("BooleanLiteral", e, t);
  }
  function P_(e, t) {
    p("RegExpLiteral", e, t);
  }
  function x_(e, t) {
    p("LogicalExpression", e, t);
  }
  function g_(e, t) {
    p("MemberExpression", e, t);
  }
  function h_(e, t) {
    p("NewExpression", e, t);
  }
  function A_(e, t) {
    p("Program", e, t);
  }
  function O_(e, t) {
    p("ObjectExpression", e, t);
  }
  function I_(e, t) {
    p("ObjectMethod", e, t);
  }
  function __(e, t) {
    p("ObjectProperty", e, t);
  }
  function D_(e, t) {
    p("RestElement", e, t);
  }
  function N_(e, t) {
    p("ReturnStatement", e, t);
  }
  function C_(e, t) {
    p("SequenceExpression", e, t);
  }
  function w_(e, t) {
    p("ParenthesizedExpression", e, t);
  }
  function L_(e, t) {
    p("SwitchCase", e, t);
  }
  function j_(e, t) {
    p("SwitchStatement", e, t);
  }
  function R_(e, t) {
    p("ThisExpression", e, t);
  }
  function M_(e, t) {
    p("ThrowStatement", e, t);
  }
  function B_(e, t) {
    p("TryStatement", e, t);
  }
  function F_(e, t) {
    p("UnaryExpression", e, t);
  }
  function k_(e, t) {
    p("UpdateExpression", e, t);
  }
  function K_(e, t) {
    p("VariableDeclaration", e, t);
  }
  function q_(e, t) {
    p("VariableDeclarator", e, t);
  }
  function Y_(e, t) {
    p("WhileStatement", e, t);
  }
  function V_(e, t) {
    p("WithStatement", e, t);
  }
  function U_(e, t) {
    p("AssignmentPattern", e, t);
  }
  function J_(e, t) {
    p("ArrayPattern", e, t);
  }
  function X_(e, t) {
    p("ArrowFunctionExpression", e, t);
  }
  function W_(e, t) {
    p("ClassBody", e, t);
  }
  function $_(e, t) {
    p("ClassExpression", e, t);
  }
  function G_(e, t) {
    p("ClassDeclaration", e, t);
  }
  function z_(e, t) {
    p("ExportAllDeclaration", e, t);
  }
  function H_(e, t) {
    p("ExportDefaultDeclaration", e, t);
  }
  function Q_(e, t) {
    p("ExportNamedDeclaration", e, t);
  }
  function Z_(e, t) {
    p("ExportSpecifier", e, t);
  }
  function eD(e, t) {
    p("ForOfStatement", e, t);
  }
  function tD(e, t) {
    p("ImportDeclaration", e, t);
  }
  function rD(e, t) {
    p("ImportDefaultSpecifier", e, t);
  }
  function nD(e, t) {
    p("ImportNamespaceSpecifier", e, t);
  }
  function aD(e, t) {
    p("ImportSpecifier", e, t);
  }
  function iD(e, t) {
    p("ImportExpression", e, t);
  }
  function sD(e, t) {
    p("MetaProperty", e, t);
  }
  function oD(e, t) {
    p("ClassMethod", e, t);
  }
  function uD(e, t) {
    p("ObjectPattern", e, t);
  }
  function lD(e, t) {
    p("SpreadElement", e, t);
  }
  function cD(e, t) {
    p("Super", e, t);
  }
  function fD(e, t) {
    p("TaggedTemplateExpression", e, t);
  }
  function pD(e, t) {
    p("TemplateElement", e, t);
  }
  function dD(e, t) {
    p("TemplateLiteral", e, t);
  }
  function yD(e, t) {
    p("YieldExpression", e, t);
  }
  function mD(e, t) {
    p("AwaitExpression", e, t);
  }
  function TD(e, t) {
    p("Import", e, t);
  }
  function SD(e, t) {
    p("BigIntLiteral", e, t);
  }
  function bD(e, t) {
    p("ExportNamespaceSpecifier", e, t);
  }
  function ED(e, t) {
    p("OptionalMemberExpression", e, t);
  }
  function vD(e, t) {
    p("OptionalCallExpression", e, t);
  }
  function PD(e, t) {
    p("ClassProperty", e, t);
  }
  function xD(e, t) {
    p("ClassAccessorProperty", e, t);
  }
  function gD(e, t) {
    p("ClassPrivateProperty", e, t);
  }
  function hD(e, t) {
    p("ClassPrivateMethod", e, t);
  }
  function AD(e, t) {
    p("PrivateName", e, t);
  }
  function OD(e, t) {
    p("StaticBlock", e, t);
  }
  function ID(e, t) {
    p("AnyTypeAnnotation", e, t);
  }
  function _D(e, t) {
    p("ArrayTypeAnnotation", e, t);
  }
  function DD(e, t) {
    p("BooleanTypeAnnotation", e, t);
  }
  function ND(e, t) {
    p("BooleanLiteralTypeAnnotation", e, t);
  }
  function CD(e, t) {
    p("NullLiteralTypeAnnotation", e, t);
  }
  function wD(e, t) {
    p("ClassImplements", e, t);
  }
  function LD(e, t) {
    p("DeclareClass", e, t);
  }
  function jD(e, t) {
    p("DeclareFunction", e, t);
  }
  function RD(e, t) {
    p("DeclareInterface", e, t);
  }
  function MD(e, t) {
    p("DeclareModule", e, t);
  }
  function BD(e, t) {
    p("DeclareModuleExports", e, t);
  }
  function FD(e, t) {
    p("DeclareTypeAlias", e, t);
  }
  function kD(e, t) {
    p("DeclareOpaqueType", e, t);
  }
  function KD(e, t) {
    p("DeclareVariable", e, t);
  }
  function qD(e, t) {
    p("DeclareExportDeclaration", e, t);
  }
  function YD(e, t) {
    p("DeclareExportAllDeclaration", e, t);
  }
  function VD(e, t) {
    p("DeclaredPredicate", e, t);
  }
  function UD(e, t) {
    p("ExistsTypeAnnotation", e, t);
  }
  function JD(e, t) {
    p("FunctionTypeAnnotation", e, t);
  }
  function XD(e, t) {
    p("FunctionTypeParam", e, t);
  }
  function WD(e, t) {
    p("GenericTypeAnnotation", e, t);
  }
  function $D(e, t) {
    p("InferredPredicate", e, t);
  }
  function GD(e, t) {
    p("InterfaceExtends", e, t);
  }
  function zD(e, t) {
    p("InterfaceDeclaration", e, t);
  }
  function HD(e, t) {
    p("InterfaceTypeAnnotation", e, t);
  }
  function QD(e, t) {
    p("IntersectionTypeAnnotation", e, t);
  }
  function ZD(e, t) {
    p("MixedTypeAnnotation", e, t);
  }
  function eN(e, t) {
    p("EmptyTypeAnnotation", e, t);
  }
  function tN(e, t) {
    p("NullableTypeAnnotation", e, t);
  }
  function rN(e, t) {
    p("NumberLiteralTypeAnnotation", e, t);
  }
  function nN(e, t) {
    p("NumberTypeAnnotation", e, t);
  }
  function aN(e, t) {
    p("ObjectTypeAnnotation", e, t);
  }
  function iN(e, t) {
    p("ObjectTypeInternalSlot", e, t);
  }
  function sN(e, t) {
    p("ObjectTypeCallProperty", e, t);
  }
  function oN(e, t) {
    p("ObjectTypeIndexer", e, t);
  }
  function uN(e, t) {
    p("ObjectTypeProperty", e, t);
  }
  function lN(e, t) {
    p("ObjectTypeSpreadProperty", e, t);
  }
  function cN(e, t) {
    p("OpaqueType", e, t);
  }
  function fN(e, t) {
    p("QualifiedTypeIdentifier", e, t);
  }
  function pN(e, t) {
    p("StringLiteralTypeAnnotation", e, t);
  }
  function dN(e, t) {
    p("StringTypeAnnotation", e, t);
  }
  function yN(e, t) {
    p("SymbolTypeAnnotation", e, t);
  }
  function mN(e, t) {
    p("ThisTypeAnnotation", e, t);
  }
  function TN(e, t) {
    p("TupleTypeAnnotation", e, t);
  }
  function SN(e, t) {
    p("TypeofTypeAnnotation", e, t);
  }
  function bN(e, t) {
    p("TypeAlias", e, t);
  }
  function EN(e, t) {
    p("TypeAnnotation", e, t);
  }
  function vN(e, t) {
    p("TypeCastExpression", e, t);
  }
  function PN(e, t) {
    p("TypeParameter", e, t);
  }
  function xN(e, t) {
    p("TypeParameterDeclaration", e, t);
  }
  function gN(e, t) {
    p("TypeParameterInstantiation", e, t);
  }
  function hN(e, t) {
    p("UnionTypeAnnotation", e, t);
  }
  function AN(e, t) {
    p("Variance", e, t);
  }
  function ON(e, t) {
    p("VoidTypeAnnotation", e, t);
  }
  function IN(e, t) {
    p("EnumDeclaration", e, t);
  }
  function _N(e, t) {
    p("EnumBooleanBody", e, t);
  }
  function DN(e, t) {
    p("EnumNumberBody", e, t);
  }
  function NN(e, t) {
    p("EnumStringBody", e, t);
  }
  function CN(e, t) {
    p("EnumSymbolBody", e, t);
  }
  function wN(e, t) {
    p("EnumBooleanMember", e, t);
  }
  function LN(e, t) {
    p("EnumNumberMember", e, t);
  }
  function jN(e, t) {
    p("EnumStringMember", e, t);
  }
  function RN(e, t) {
    p("EnumDefaultedMember", e, t);
  }
  function MN(e, t) {
    p("IndexedAccessType", e, t);
  }
  function BN(e, t) {
    p("OptionalIndexedAccessType", e, t);
  }
  function FN(e, t) {
    p("JSXAttribute", e, t);
  }
  function kN(e, t) {
    p("JSXClosingElement", e, t);
  }
  function KN(e, t) {
    p("JSXElement", e, t);
  }
  function qN(e, t) {
    p("JSXEmptyExpression", e, t);
  }
  function YN(e, t) {
    p("JSXExpressionContainer", e, t);
  }
  function VN(e, t) {
    p("JSXSpreadChild", e, t);
  }
  function UN(e, t) {
    p("JSXIdentifier", e, t);
  }
  function JN(e, t) {
    p("JSXMemberExpression", e, t);
  }
  function XN(e, t) {
    p("JSXNamespacedName", e, t);
  }
  function WN(e, t) {
    p("JSXOpeningElement", e, t);
  }
  function $N(e, t) {
    p("JSXSpreadAttribute", e, t);
  }
  function GN(e, t) {
    p("JSXText", e, t);
  }
  function zN(e, t) {
    p("JSXFragment", e, t);
  }
  function HN(e, t) {
    p("JSXOpeningFragment", e, t);
  }
  function QN(e, t) {
    p("JSXClosingFragment", e, t);
  }
  function ZN(e, t) {
    p("Noop", e, t);
  }
  function eC(e, t) {
    p("Placeholder", e, t);
  }
  function tC(e, t) {
    p("V8IntrinsicIdentifier", e, t);
  }
  function rC(e, t) {
    p("ArgumentPlaceholder", e, t);
  }
  function nC(e, t) {
    p("BindExpression", e, t);
  }
  function aC(e, t) {
    p("ImportAttribute", e, t);
  }
  function iC(e, t) {
    p("Decorator", e, t);
  }
  function sC(e, t) {
    p("DoExpression", e, t);
  }
  function oC(e, t) {
    p("ExportDefaultSpecifier", e, t);
  }
  function uC(e, t) {
    p("RecordExpression", e, t);
  }
  function lC(e, t) {
    p("TupleExpression", e, t);
  }
  function cC(e, t) {
    p("DecimalLiteral", e, t);
  }
  function fC(e, t) {
    p("ModuleExpression", e, t);
  }
  function pC(e, t) {
    p("TopicReference", e, t);
  }
  function dC(e, t) {
    p("PipelineTopicExpression", e, t);
  }
  function yC(e, t) {
    p("PipelineBareFunction", e, t);
  }
  function mC(e, t) {
    p("PipelinePrimaryTopicReference", e, t);
  }
  function TC(e, t) {
    p("TSParameterProperty", e, t);
  }
  function SC(e, t) {
    p("TSDeclareFunction", e, t);
  }
  function bC(e, t) {
    p("TSDeclareMethod", e, t);
  }
  function EC(e, t) {
    p("TSQualifiedName", e, t);
  }
  function vC(e, t) {
    p("TSCallSignatureDeclaration", e, t);
  }
  function PC(e, t) {
    p("TSConstructSignatureDeclaration", e, t);
  }
  function xC(e, t) {
    p("TSPropertySignature", e, t);
  }
  function gC(e, t) {
    p("TSMethodSignature", e, t);
  }
  function hC(e, t) {
    p("TSIndexSignature", e, t);
  }
  function AC(e, t) {
    p("TSAnyKeyword", e, t);
  }
  function OC(e, t) {
    p("TSBooleanKeyword", e, t);
  }
  function IC(e, t) {
    p("TSBigIntKeyword", e, t);
  }
  function _C(e, t) {
    p("TSIntrinsicKeyword", e, t);
  }
  function DC(e, t) {
    p("TSNeverKeyword", e, t);
  }
  function NC(e, t) {
    p("TSNullKeyword", e, t);
  }
  function CC(e, t) {
    p("TSNumberKeyword", e, t);
  }
  function wC(e, t) {
    p("TSObjectKeyword", e, t);
  }
  function LC(e, t) {
    p("TSStringKeyword", e, t);
  }
  function jC(e, t) {
    p("TSSymbolKeyword", e, t);
  }
  function RC(e, t) {
    p("TSUndefinedKeyword", e, t);
  }
  function MC(e, t) {
    p("TSUnknownKeyword", e, t);
  }
  function BC(e, t) {
    p("TSVoidKeyword", e, t);
  }
  function FC(e, t) {
    p("TSThisType", e, t);
  }
  function kC(e, t) {
    p("TSFunctionType", e, t);
  }
  function KC(e, t) {
    p("TSConstructorType", e, t);
  }
  function qC(e, t) {
    p("TSTypeReference", e, t);
  }
  function YC(e, t) {
    p("TSTypePredicate", e, t);
  }
  function VC(e, t) {
    p("TSTypeQuery", e, t);
  }
  function UC(e, t) {
    p("TSTypeLiteral", e, t);
  }
  function JC(e, t) {
    p("TSArrayType", e, t);
  }
  function XC(e, t) {
    p("TSTupleType", e, t);
  }
  function WC(e, t) {
    p("TSOptionalType", e, t);
  }
  function $C(e, t) {
    p("TSRestType", e, t);
  }
  function GC(e, t) {
    p("TSNamedTupleMember", e, t);
  }
  function zC(e, t) {
    p("TSUnionType", e, t);
  }
  function HC(e, t) {
    p("TSIntersectionType", e, t);
  }
  function QC(e, t) {
    p("TSConditionalType", e, t);
  }
  function ZC(e, t) {
    p("TSInferType", e, t);
  }
  function e1(e, t) {
    p("TSParenthesizedType", e, t);
  }
  function t1(e, t) {
    p("TSTypeOperator", e, t);
  }
  function r1(e, t) {
    p("TSIndexedAccessType", e, t);
  }
  function n1(e, t) {
    p("TSMappedType", e, t);
  }
  function a1(e, t) {
    p("TSLiteralType", e, t);
  }
  function i1(e, t) {
    p("TSExpressionWithTypeArguments", e, t);
  }
  function s1(e, t) {
    p("TSInterfaceDeclaration", e, t);
  }
  function o1(e, t) {
    p("TSInterfaceBody", e, t);
  }
  function u1(e, t) {
    p("TSTypeAliasDeclaration", e, t);
  }
  function l1(e, t) {
    p("TSInstantiationExpression", e, t);
  }
  function c1(e, t) {
    p("TSAsExpression", e, t);
  }
  function f1(e, t) {
    p("TSSatisfiesExpression", e, t);
  }
  function p1(e, t) {
    p("TSTypeAssertion", e, t);
  }
  function d1(e, t) {
    p("TSEnumDeclaration", e, t);
  }
  function y1(e, t) {
    p("TSEnumMember", e, t);
  }
  function m1(e, t) {
    p("TSModuleDeclaration", e, t);
  }
  function T1(e, t) {
    p("TSModuleBlock", e, t);
  }
  function S1(e, t) {
    p("TSImportType", e, t);
  }
  function b1(e, t) {
    p("TSImportEqualsDeclaration", e, t);
  }
  function E1(e, t) {
    p("TSExternalModuleReference", e, t);
  }
  function v1(e, t) {
    p("TSNonNullExpression", e, t);
  }
  function P1(e, t) {
    p("TSExportAssignment", e, t);
  }
  function x1(e, t) {
    p("TSNamespaceExportDeclaration", e, t);
  }
  function g1(e, t) {
    p("TSTypeAnnotation", e, t);
  }
  function h1(e, t) {
    p("TSTypeParameterInstantiation", e, t);
  }
  function A1(e, t) {
    p("TSTypeParameterDeclaration", e, t);
  }
  function O1(e, t) {
    p("TSTypeParameter", e, t);
  }
  function I1(e, t) {
    p("Standardized", e, t);
  }
  function _1(e, t) {
    p("Expression", e, t);
  }
  function D1(e, t) {
    p("Binary", e, t);
  }
  function N1(e, t) {
    p("Scopable", e, t);
  }
  function C1(e, t) {
    p("BlockParent", e, t);
  }
  function w1(e, t) {
    p("Block", e, t);
  }
  function L1(e, t) {
    p("Statement", e, t);
  }
  function j1(e, t) {
    p("Terminatorless", e, t);
  }
  function R1(e, t) {
    p("CompletionStatement", e, t);
  }
  function M1(e, t) {
    p("Conditional", e, t);
  }
  function B1(e, t) {
    p("Loop", e, t);
  }
  function F1(e, t) {
    p("While", e, t);
  }
  function k1(e, t) {
    p("ExpressionWrapper", e, t);
  }
  function K1(e, t) {
    p("For", e, t);
  }
  function q1(e, t) {
    p("ForXStatement", e, t);
  }
  function Y1(e, t) {
    p("Function", e, t);
  }
  function V1(e, t) {
    p("FunctionParent", e, t);
  }
  function U1(e, t) {
    p("Pureish", e, t);
  }
  function J1(e, t) {
    p("Declaration", e, t);
  }
  function X1(e, t) {
    p("PatternLike", e, t);
  }
  function W1(e, t) {
    p("LVal", e, t);
  }
  function $1(e, t) {
    p("TSEntityName", e, t);
  }
  function G1(e, t) {
    p("Literal", e, t);
  }
  function z1(e, t) {
    p("Immutable", e, t);
  }
  function H1(e, t) {
    p("UserWhitespacable", e, t);
  }
  function Q1(e, t) {
    p("Method", e, t);
  }
  function Z1(e, t) {
    p("ObjectMember", e, t);
  }
  function ew(e, t) {
    p("Property", e, t);
  }
  function tw(e, t) {
    p("UnaryLike", e, t);
  }
  function rw(e, t) {
    p("Pattern", e, t);
  }
  function nw(e, t) {
    p("Class", e, t);
  }
  function aw(e, t) {
    p("ImportOrExportDeclaration", e, t);
  }
  function iw(e, t) {
    p("ExportDeclaration", e, t);
  }
  function sw(e, t) {
    p("ModuleSpecifier", e, t);
  }
  function ow(e, t) {
    p("Accessor", e, t);
  }
  function uw(e, t) {
    p("Private", e, t);
  }
  function lw(e, t) {
    p("Flow", e, t);
  }
  function cw(e, t) {
    p("FlowType", e, t);
  }
  function fw(e, t) {
    p("FlowBaseAnnotation", e, t);
  }
  function pw(e, t) {
    p("FlowDeclaration", e, t);
  }
  function dw(e, t) {
    p("FlowPredicate", e, t);
  }
  function yw(e, t) {
    p("EnumBody", e, t);
  }
  function mw(e, t) {
    p("EnumMember", e, t);
  }
  function Tw(e, t) {
    p("JSX", e, t);
  }
  function Sw(e, t) {
    p("Miscellaneous", e, t);
  }
  function bw(e, t) {
    p("TypeScript", e, t);
  }
  function Ew(e, t) {
    p("TSTypeElement", e, t);
  }
  function vw(e, t) {
    p("TSType", e, t);
  }
  function Pw(e, t) {
    p("TSBaseType", e, t);
  }
  function xw(e, t) {
    (0, sr.default)("assertNumberLiteral", "assertNumericLiteral"), p("NumberLiteral", e, t);
  }
  function gw(e, t) {
    (0, sr.default)("assertRegexLiteral", "assertRegExpLiteral"), p("RegexLiteral", e, t);
  }
  function hw(e, t) {
    (0, sr.default)("assertRestProperty", "assertRestElement"), p("RestProperty", e, t);
  }
  function Aw(e, t) {
    (0, sr.default)("assertSpreadProperty", "assertSpreadElement"), p("SpreadProperty", e, t);
  }
  function Ow(e, t) {
    (0, sr.default)("assertModuleDeclaration", "assertImportOrExportDeclaration"), p("ModuleDeclaration", e, t);
  }
});
var ec = x((Xr) => {
  "use strict";
  o();
  Object.defineProperty(Xr, "__esModule", { value: true });
  Xr.default = void 0;
  var Me = Ae(), gk = Xr.default = Iw;
  function Iw(e) {
    switch (e) {
      case "string":
        return (0, Me.stringTypeAnnotation)();
      case "number":
        return (0, Me.numberTypeAnnotation)();
      case "undefined":
        return (0, Me.voidTypeAnnotation)();
      case "boolean":
        return (0, Me.booleanTypeAnnotation)();
      case "function":
        return (0, Me.genericTypeAnnotation)((0, Me.identifier)("Function"));
      case "object":
        return (0, Me.genericTypeAnnotation)((0, Me.identifier)("Object"));
      case "symbol":
        return (0, Me.genericTypeAnnotation)((0, Me.identifier)("Symbol"));
      case "bigint":
        return (0, Me.anyTypeAnnotation)();
    }
    throw new Error("Invalid typeof value: " + e);
  }
});
var Na = x((Da) => {
  "use strict";
  o();
  Object.defineProperty(Da, "__esModule", { value: true });
  Da.default = rc;
  var or = pe();
  function tc(e) {
    return (0, or.isIdentifier)(e) ? e.name : `${e.id.name}.${tc(e.qualification)}`;
  }
  function rc(e) {
    let t = Array.from(e), r = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Set(), l = [];
    for (let y = 0; y < t.length; y++) {
      let S = t[y];
      if (!!S && !(l.indexOf(S) >= 0)) {
        if ((0, or.isAnyTypeAnnotation)(S))
          return [S];
        if ((0, or.isFlowBaseAnnotation)(S)) {
          n.set(S.type, S);
          continue;
        }
        if ((0, or.isUnionTypeAnnotation)(S)) {
          i.has(S.types) || (t.push(...S.types), i.add(S.types));
          continue;
        }
        if ((0, or.isGenericTypeAnnotation)(S)) {
          let P = tc(S.id);
          if (r.has(P)) {
            let A = r.get(P);
            A.typeParameters ? S.typeParameters && (A.typeParameters.params.push(...S.typeParameters.params), A.typeParameters.params = rc(A.typeParameters.params)) : A = S.typeParameters;
          } else
            r.set(P, S);
          continue;
        }
        l.push(S);
      }
    }
    for (let [, y] of n)
      l.push(y);
    for (let [, y] of r)
      l.push(y);
    return l;
  }
});
var nc = x((Ca) => {
  "use strict";
  o();
  Object.defineProperty(Ca, "__esModule", { value: true });
  Ca.default = Nw;
  var _w = Ae(), Dw = Na();
  function Nw(e) {
    let t = (0, Dw.default)(e);
    return t.length === 1 ? t[0] : (0, _w.unionTypeAnnotation)(t);
  }
});
var sc = x((wa) => {
  "use strict";
  o();
  Object.defineProperty(wa, "__esModule", { value: true });
  wa.default = ic;
  var ur = pe();
  function ac(e) {
    return (0, ur.isIdentifier)(e) ? e.name : `${e.right.name}.${ac(e.left)}`;
  }
  function ic(e) {
    let t = Array.from(e), r = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Set(), l = [];
    for (let y = 0; y < t.length; y++) {
      let S = t[y];
      if (!!S && !(l.indexOf(S) >= 0)) {
        if ((0, ur.isTSAnyKeyword)(S))
          return [S];
        if ((0, ur.isTSBaseType)(S)) {
          n.set(S.type, S);
          continue;
        }
        if ((0, ur.isTSUnionType)(S)) {
          i.has(S.types) || (t.push(...S.types), i.add(S.types));
          continue;
        }
        if ((0, ur.isTSTypeReference)(S) && S.typeParameters) {
          let P = ac(S.typeName);
          if (r.has(P)) {
            let A = r.get(P);
            A.typeParameters ? S.typeParameters && (A.typeParameters.params.push(...S.typeParameters.params), A.typeParameters.params = ic(A.typeParameters.params)) : A = S.typeParameters;
          } else
            r.set(P, S);
          continue;
        }
        l.push(S);
      }
    }
    for (let [, y] of n)
      l.push(y);
    for (let [, y] of r)
      l.push(y);
    return l;
  }
});
var oc = x((La) => {
  "use strict";
  o();
  Object.defineProperty(La, "__esModule", { value: true });
  La.default = jw;
  var Cw = Ae(), ww = sc(), Lw = pe();
  function jw(e) {
    let t = e.map((n) => (0, Lw.isTSTypeAnnotation)(n) ? n.typeAnnotation : n), r = (0, ww.default)(t);
    return r.length === 1 ? r[0] : (0, Cw.tsUnionType)(r);
  }
});
var uc = x((m) => {
  "use strict";
  o();
  Object.defineProperty(m, "__esModule", { value: true });
  Object.defineProperty(m, "AnyTypeAnnotation", { enumerable: true, get: function() {
    return T.anyTypeAnnotation;
  } });
  Object.defineProperty(m, "ArgumentPlaceholder", { enumerable: true, get: function() {
    return T.argumentPlaceholder;
  } });
  Object.defineProperty(m, "ArrayExpression", { enumerable: true, get: function() {
    return T.arrayExpression;
  } });
  Object.defineProperty(m, "ArrayPattern", { enumerable: true, get: function() {
    return T.arrayPattern;
  } });
  Object.defineProperty(m, "ArrayTypeAnnotation", { enumerable: true, get: function() {
    return T.arrayTypeAnnotation;
  } });
  Object.defineProperty(m, "ArrowFunctionExpression", { enumerable: true, get: function() {
    return T.arrowFunctionExpression;
  } });
  Object.defineProperty(m, "AssignmentExpression", { enumerable: true, get: function() {
    return T.assignmentExpression;
  } });
  Object.defineProperty(m, "AssignmentPattern", { enumerable: true, get: function() {
    return T.assignmentPattern;
  } });
  Object.defineProperty(m, "AwaitExpression", { enumerable: true, get: function() {
    return T.awaitExpression;
  } });
  Object.defineProperty(m, "BigIntLiteral", { enumerable: true, get: function() {
    return T.bigIntLiteral;
  } });
  Object.defineProperty(m, "BinaryExpression", { enumerable: true, get: function() {
    return T.binaryExpression;
  } });
  Object.defineProperty(m, "BindExpression", { enumerable: true, get: function() {
    return T.bindExpression;
  } });
  Object.defineProperty(m, "BlockStatement", { enumerable: true, get: function() {
    return T.blockStatement;
  } });
  Object.defineProperty(m, "BooleanLiteral", { enumerable: true, get: function() {
    return T.booleanLiteral;
  } });
  Object.defineProperty(m, "BooleanLiteralTypeAnnotation", { enumerable: true, get: function() {
    return T.booleanLiteralTypeAnnotation;
  } });
  Object.defineProperty(m, "BooleanTypeAnnotation", { enumerable: true, get: function() {
    return T.booleanTypeAnnotation;
  } });
  Object.defineProperty(m, "BreakStatement", { enumerable: true, get: function() {
    return T.breakStatement;
  } });
  Object.defineProperty(m, "CallExpression", { enumerable: true, get: function() {
    return T.callExpression;
  } });
  Object.defineProperty(m, "CatchClause", { enumerable: true, get: function() {
    return T.catchClause;
  } });
  Object.defineProperty(m, "ClassAccessorProperty", { enumerable: true, get: function() {
    return T.classAccessorProperty;
  } });
  Object.defineProperty(m, "ClassBody", { enumerable: true, get: function() {
    return T.classBody;
  } });
  Object.defineProperty(m, "ClassDeclaration", { enumerable: true, get: function() {
    return T.classDeclaration;
  } });
  Object.defineProperty(m, "ClassExpression", { enumerable: true, get: function() {
    return T.classExpression;
  } });
  Object.defineProperty(m, "ClassImplements", { enumerable: true, get: function() {
    return T.classImplements;
  } });
  Object.defineProperty(m, "ClassMethod", { enumerable: true, get: function() {
    return T.classMethod;
  } });
  Object.defineProperty(m, "ClassPrivateMethod", { enumerable: true, get: function() {
    return T.classPrivateMethod;
  } });
  Object.defineProperty(m, "ClassPrivateProperty", { enumerable: true, get: function() {
    return T.classPrivateProperty;
  } });
  Object.defineProperty(m, "ClassProperty", { enumerable: true, get: function() {
    return T.classProperty;
  } });
  Object.defineProperty(m, "ConditionalExpression", { enumerable: true, get: function() {
    return T.conditionalExpression;
  } });
  Object.defineProperty(m, "ContinueStatement", { enumerable: true, get: function() {
    return T.continueStatement;
  } });
  Object.defineProperty(m, "DebuggerStatement", { enumerable: true, get: function() {
    return T.debuggerStatement;
  } });
  Object.defineProperty(m, "DecimalLiteral", { enumerable: true, get: function() {
    return T.decimalLiteral;
  } });
  Object.defineProperty(m, "DeclareClass", { enumerable: true, get: function() {
    return T.declareClass;
  } });
  Object.defineProperty(m, "DeclareExportAllDeclaration", { enumerable: true, get: function() {
    return T.declareExportAllDeclaration;
  } });
  Object.defineProperty(m, "DeclareExportDeclaration", { enumerable: true, get: function() {
    return T.declareExportDeclaration;
  } });
  Object.defineProperty(m, "DeclareFunction", { enumerable: true, get: function() {
    return T.declareFunction;
  } });
  Object.defineProperty(m, "DeclareInterface", { enumerable: true, get: function() {
    return T.declareInterface;
  } });
  Object.defineProperty(m, "DeclareModule", { enumerable: true, get: function() {
    return T.declareModule;
  } });
  Object.defineProperty(m, "DeclareModuleExports", { enumerable: true, get: function() {
    return T.declareModuleExports;
  } });
  Object.defineProperty(m, "DeclareOpaqueType", { enumerable: true, get: function() {
    return T.declareOpaqueType;
  } });
  Object.defineProperty(m, "DeclareTypeAlias", { enumerable: true, get: function() {
    return T.declareTypeAlias;
  } });
  Object.defineProperty(m, "DeclareVariable", { enumerable: true, get: function() {
    return T.declareVariable;
  } });
  Object.defineProperty(m, "DeclaredPredicate", { enumerable: true, get: function() {
    return T.declaredPredicate;
  } });
  Object.defineProperty(m, "Decorator", { enumerable: true, get: function() {
    return T.decorator;
  } });
  Object.defineProperty(m, "Directive", { enumerable: true, get: function() {
    return T.directive;
  } });
  Object.defineProperty(m, "DirectiveLiteral", { enumerable: true, get: function() {
    return T.directiveLiteral;
  } });
  Object.defineProperty(m, "DoExpression", { enumerable: true, get: function() {
    return T.doExpression;
  } });
  Object.defineProperty(m, "DoWhileStatement", { enumerable: true, get: function() {
    return T.doWhileStatement;
  } });
  Object.defineProperty(m, "EmptyStatement", { enumerable: true, get: function() {
    return T.emptyStatement;
  } });
  Object.defineProperty(m, "EmptyTypeAnnotation", { enumerable: true, get: function() {
    return T.emptyTypeAnnotation;
  } });
  Object.defineProperty(m, "EnumBooleanBody", { enumerable: true, get: function() {
    return T.enumBooleanBody;
  } });
  Object.defineProperty(m, "EnumBooleanMember", { enumerable: true, get: function() {
    return T.enumBooleanMember;
  } });
  Object.defineProperty(m, "EnumDeclaration", { enumerable: true, get: function() {
    return T.enumDeclaration;
  } });
  Object.defineProperty(m, "EnumDefaultedMember", { enumerable: true, get: function() {
    return T.enumDefaultedMember;
  } });
  Object.defineProperty(m, "EnumNumberBody", { enumerable: true, get: function() {
    return T.enumNumberBody;
  } });
  Object.defineProperty(m, "EnumNumberMember", { enumerable: true, get: function() {
    return T.enumNumberMember;
  } });
  Object.defineProperty(m, "EnumStringBody", { enumerable: true, get: function() {
    return T.enumStringBody;
  } });
  Object.defineProperty(m, "EnumStringMember", { enumerable: true, get: function() {
    return T.enumStringMember;
  } });
  Object.defineProperty(m, "EnumSymbolBody", { enumerable: true, get: function() {
    return T.enumSymbolBody;
  } });
  Object.defineProperty(m, "ExistsTypeAnnotation", { enumerable: true, get: function() {
    return T.existsTypeAnnotation;
  } });
  Object.defineProperty(m, "ExportAllDeclaration", { enumerable: true, get: function() {
    return T.exportAllDeclaration;
  } });
  Object.defineProperty(m, "ExportDefaultDeclaration", { enumerable: true, get: function() {
    return T.exportDefaultDeclaration;
  } });
  Object.defineProperty(m, "ExportDefaultSpecifier", { enumerable: true, get: function() {
    return T.exportDefaultSpecifier;
  } });
  Object.defineProperty(m, "ExportNamedDeclaration", { enumerable: true, get: function() {
    return T.exportNamedDeclaration;
  } });
  Object.defineProperty(m, "ExportNamespaceSpecifier", { enumerable: true, get: function() {
    return T.exportNamespaceSpecifier;
  } });
  Object.defineProperty(m, "ExportSpecifier", { enumerable: true, get: function() {
    return T.exportSpecifier;
  } });
  Object.defineProperty(m, "ExpressionStatement", { enumerable: true, get: function() {
    return T.expressionStatement;
  } });
  Object.defineProperty(m, "File", { enumerable: true, get: function() {
    return T.file;
  } });
  Object.defineProperty(m, "ForInStatement", { enumerable: true, get: function() {
    return T.forInStatement;
  } });
  Object.defineProperty(m, "ForOfStatement", { enumerable: true, get: function() {
    return T.forOfStatement;
  } });
  Object.defineProperty(m, "ForStatement", { enumerable: true, get: function() {
    return T.forStatement;
  } });
  Object.defineProperty(m, "FunctionDeclaration", { enumerable: true, get: function() {
    return T.functionDeclaration;
  } });
  Object.defineProperty(m, "FunctionExpression", { enumerable: true, get: function() {
    return T.functionExpression;
  } });
  Object.defineProperty(m, "FunctionTypeAnnotation", { enumerable: true, get: function() {
    return T.functionTypeAnnotation;
  } });
  Object.defineProperty(m, "FunctionTypeParam", { enumerable: true, get: function() {
    return T.functionTypeParam;
  } });
  Object.defineProperty(m, "GenericTypeAnnotation", { enumerable: true, get: function() {
    return T.genericTypeAnnotation;
  } });
  Object.defineProperty(m, "Identifier", { enumerable: true, get: function() {
    return T.identifier;
  } });
  Object.defineProperty(m, "IfStatement", { enumerable: true, get: function() {
    return T.ifStatement;
  } });
  Object.defineProperty(m, "Import", { enumerable: true, get: function() {
    return T.import;
  } });
  Object.defineProperty(m, "ImportAttribute", { enumerable: true, get: function() {
    return T.importAttribute;
  } });
  Object.defineProperty(m, "ImportDeclaration", { enumerable: true, get: function() {
    return T.importDeclaration;
  } });
  Object.defineProperty(m, "ImportDefaultSpecifier", { enumerable: true, get: function() {
    return T.importDefaultSpecifier;
  } });
  Object.defineProperty(m, "ImportExpression", { enumerable: true, get: function() {
    return T.importExpression;
  } });
  Object.defineProperty(m, "ImportNamespaceSpecifier", { enumerable: true, get: function() {
    return T.importNamespaceSpecifier;
  } });
  Object.defineProperty(m, "ImportSpecifier", { enumerable: true, get: function() {
    return T.importSpecifier;
  } });
  Object.defineProperty(m, "IndexedAccessType", { enumerable: true, get: function() {
    return T.indexedAccessType;
  } });
  Object.defineProperty(m, "InferredPredicate", { enumerable: true, get: function() {
    return T.inferredPredicate;
  } });
  Object.defineProperty(m, "InterfaceDeclaration", { enumerable: true, get: function() {
    return T.interfaceDeclaration;
  } });
  Object.defineProperty(m, "InterfaceExtends", { enumerable: true, get: function() {
    return T.interfaceExtends;
  } });
  Object.defineProperty(m, "InterfaceTypeAnnotation", { enumerable: true, get: function() {
    return T.interfaceTypeAnnotation;
  } });
  Object.defineProperty(m, "InterpreterDirective", { enumerable: true, get: function() {
    return T.interpreterDirective;
  } });
  Object.defineProperty(m, "IntersectionTypeAnnotation", { enumerable: true, get: function() {
    return T.intersectionTypeAnnotation;
  } });
  Object.defineProperty(m, "JSXAttribute", { enumerable: true, get: function() {
    return T.jsxAttribute;
  } });
  Object.defineProperty(m, "JSXClosingElement", { enumerable: true, get: function() {
    return T.jsxClosingElement;
  } });
  Object.defineProperty(m, "JSXClosingFragment", { enumerable: true, get: function() {
    return T.jsxClosingFragment;
  } });
  Object.defineProperty(m, "JSXElement", { enumerable: true, get: function() {
    return T.jsxElement;
  } });
  Object.defineProperty(m, "JSXEmptyExpression", { enumerable: true, get: function() {
    return T.jsxEmptyExpression;
  } });
  Object.defineProperty(m, "JSXExpressionContainer", { enumerable: true, get: function() {
    return T.jsxExpressionContainer;
  } });
  Object.defineProperty(m, "JSXFragment", { enumerable: true, get: function() {
    return T.jsxFragment;
  } });
  Object.defineProperty(m, "JSXIdentifier", { enumerable: true, get: function() {
    return T.jsxIdentifier;
  } });
  Object.defineProperty(m, "JSXMemberExpression", { enumerable: true, get: function() {
    return T.jsxMemberExpression;
  } });
  Object.defineProperty(m, "JSXNamespacedName", { enumerable: true, get: function() {
    return T.jsxNamespacedName;
  } });
  Object.defineProperty(m, "JSXOpeningElement", { enumerable: true, get: function() {
    return T.jsxOpeningElement;
  } });
  Object.defineProperty(m, "JSXOpeningFragment", { enumerable: true, get: function() {
    return T.jsxOpeningFragment;
  } });
  Object.defineProperty(m, "JSXSpreadAttribute", { enumerable: true, get: function() {
    return T.jsxSpreadAttribute;
  } });
  Object.defineProperty(m, "JSXSpreadChild", { enumerable: true, get: function() {
    return T.jsxSpreadChild;
  } });
  Object.defineProperty(m, "JSXText", { enumerable: true, get: function() {
    return T.jsxText;
  } });
  Object.defineProperty(m, "LabeledStatement", { enumerable: true, get: function() {
    return T.labeledStatement;
  } });
  Object.defineProperty(m, "LogicalExpression", { enumerable: true, get: function() {
    return T.logicalExpression;
  } });
  Object.defineProperty(m, "MemberExpression", { enumerable: true, get: function() {
    return T.memberExpression;
  } });
  Object.defineProperty(m, "MetaProperty", { enumerable: true, get: function() {
    return T.metaProperty;
  } });
  Object.defineProperty(m, "MixedTypeAnnotation", { enumerable: true, get: function() {
    return T.mixedTypeAnnotation;
  } });
  Object.defineProperty(m, "ModuleExpression", { enumerable: true, get: function() {
    return T.moduleExpression;
  } });
  Object.defineProperty(m, "NewExpression", { enumerable: true, get: function() {
    return T.newExpression;
  } });
  Object.defineProperty(m, "Noop", { enumerable: true, get: function() {
    return T.noop;
  } });
  Object.defineProperty(m, "NullLiteral", { enumerable: true, get: function() {
    return T.nullLiteral;
  } });
  Object.defineProperty(m, "NullLiteralTypeAnnotation", { enumerable: true, get: function() {
    return T.nullLiteralTypeAnnotation;
  } });
  Object.defineProperty(m, "NullableTypeAnnotation", { enumerable: true, get: function() {
    return T.nullableTypeAnnotation;
  } });
  Object.defineProperty(m, "NumberLiteral", { enumerable: true, get: function() {
    return T.numberLiteral;
  } });
  Object.defineProperty(m, "NumberLiteralTypeAnnotation", { enumerable: true, get: function() {
    return T.numberLiteralTypeAnnotation;
  } });
  Object.defineProperty(m, "NumberTypeAnnotation", { enumerable: true, get: function() {
    return T.numberTypeAnnotation;
  } });
  Object.defineProperty(m, "NumericLiteral", { enumerable: true, get: function() {
    return T.numericLiteral;
  } });
  Object.defineProperty(m, "ObjectExpression", { enumerable: true, get: function() {
    return T.objectExpression;
  } });
  Object.defineProperty(m, "ObjectMethod", { enumerable: true, get: function() {
    return T.objectMethod;
  } });
  Object.defineProperty(m, "ObjectPattern", { enumerable: true, get: function() {
    return T.objectPattern;
  } });
  Object.defineProperty(m, "ObjectProperty", { enumerable: true, get: function() {
    return T.objectProperty;
  } });
  Object.defineProperty(m, "ObjectTypeAnnotation", { enumerable: true, get: function() {
    return T.objectTypeAnnotation;
  } });
  Object.defineProperty(m, "ObjectTypeCallProperty", { enumerable: true, get: function() {
    return T.objectTypeCallProperty;
  } });
  Object.defineProperty(m, "ObjectTypeIndexer", { enumerable: true, get: function() {
    return T.objectTypeIndexer;
  } });
  Object.defineProperty(m, "ObjectTypeInternalSlot", { enumerable: true, get: function() {
    return T.objectTypeInternalSlot;
  } });
  Object.defineProperty(m, "ObjectTypeProperty", { enumerable: true, get: function() {
    return T.objectTypeProperty;
  } });
  Object.defineProperty(m, "ObjectTypeSpreadProperty", { enumerable: true, get: function() {
    return T.objectTypeSpreadProperty;
  } });
  Object.defineProperty(m, "OpaqueType", { enumerable: true, get: function() {
    return T.opaqueType;
  } });
  Object.defineProperty(m, "OptionalCallExpression", { enumerable: true, get: function() {
    return T.optionalCallExpression;
  } });
  Object.defineProperty(m, "OptionalIndexedAccessType", { enumerable: true, get: function() {
    return T.optionalIndexedAccessType;
  } });
  Object.defineProperty(m, "OptionalMemberExpression", { enumerable: true, get: function() {
    return T.optionalMemberExpression;
  } });
  Object.defineProperty(m, "ParenthesizedExpression", { enumerable: true, get: function() {
    return T.parenthesizedExpression;
  } });
  Object.defineProperty(m, "PipelineBareFunction", { enumerable: true, get: function() {
    return T.pipelineBareFunction;
  } });
  Object.defineProperty(m, "PipelinePrimaryTopicReference", { enumerable: true, get: function() {
    return T.pipelinePrimaryTopicReference;
  } });
  Object.defineProperty(m, "PipelineTopicExpression", { enumerable: true, get: function() {
    return T.pipelineTopicExpression;
  } });
  Object.defineProperty(m, "Placeholder", { enumerable: true, get: function() {
    return T.placeholder;
  } });
  Object.defineProperty(m, "PrivateName", { enumerable: true, get: function() {
    return T.privateName;
  } });
  Object.defineProperty(m, "Program", { enumerable: true, get: function() {
    return T.program;
  } });
  Object.defineProperty(m, "QualifiedTypeIdentifier", { enumerable: true, get: function() {
    return T.qualifiedTypeIdentifier;
  } });
  Object.defineProperty(m, "RecordExpression", { enumerable: true, get: function() {
    return T.recordExpression;
  } });
  Object.defineProperty(m, "RegExpLiteral", { enumerable: true, get: function() {
    return T.regExpLiteral;
  } });
  Object.defineProperty(m, "RegexLiteral", { enumerable: true, get: function() {
    return T.regexLiteral;
  } });
  Object.defineProperty(m, "RestElement", { enumerable: true, get: function() {
    return T.restElement;
  } });
  Object.defineProperty(m, "RestProperty", { enumerable: true, get: function() {
    return T.restProperty;
  } });
  Object.defineProperty(m, "ReturnStatement", { enumerable: true, get: function() {
    return T.returnStatement;
  } });
  Object.defineProperty(m, "SequenceExpression", { enumerable: true, get: function() {
    return T.sequenceExpression;
  } });
  Object.defineProperty(m, "SpreadElement", { enumerable: true, get: function() {
    return T.spreadElement;
  } });
  Object.defineProperty(m, "SpreadProperty", { enumerable: true, get: function() {
    return T.spreadProperty;
  } });
  Object.defineProperty(m, "StaticBlock", { enumerable: true, get: function() {
    return T.staticBlock;
  } });
  Object.defineProperty(m, "StringLiteral", { enumerable: true, get: function() {
    return T.stringLiteral;
  } });
  Object.defineProperty(m, "StringLiteralTypeAnnotation", { enumerable: true, get: function() {
    return T.stringLiteralTypeAnnotation;
  } });
  Object.defineProperty(m, "StringTypeAnnotation", { enumerable: true, get: function() {
    return T.stringTypeAnnotation;
  } });
  Object.defineProperty(m, "Super", { enumerable: true, get: function() {
    return T.super;
  } });
  Object.defineProperty(m, "SwitchCase", { enumerable: true, get: function() {
    return T.switchCase;
  } });
  Object.defineProperty(m, "SwitchStatement", { enumerable: true, get: function() {
    return T.switchStatement;
  } });
  Object.defineProperty(m, "SymbolTypeAnnotation", { enumerable: true, get: function() {
    return T.symbolTypeAnnotation;
  } });
  Object.defineProperty(m, "TSAnyKeyword", { enumerable: true, get: function() {
    return T.tsAnyKeyword;
  } });
  Object.defineProperty(m, "TSArrayType", { enumerable: true, get: function() {
    return T.tsArrayType;
  } });
  Object.defineProperty(m, "TSAsExpression", { enumerable: true, get: function() {
    return T.tsAsExpression;
  } });
  Object.defineProperty(m, "TSBigIntKeyword", { enumerable: true, get: function() {
    return T.tsBigIntKeyword;
  } });
  Object.defineProperty(m, "TSBooleanKeyword", { enumerable: true, get: function() {
    return T.tsBooleanKeyword;
  } });
  Object.defineProperty(m, "TSCallSignatureDeclaration", { enumerable: true, get: function() {
    return T.tsCallSignatureDeclaration;
  } });
  Object.defineProperty(m, "TSConditionalType", { enumerable: true, get: function() {
    return T.tsConditionalType;
  } });
  Object.defineProperty(m, "TSConstructSignatureDeclaration", { enumerable: true, get: function() {
    return T.tsConstructSignatureDeclaration;
  } });
  Object.defineProperty(m, "TSConstructorType", { enumerable: true, get: function() {
    return T.tsConstructorType;
  } });
  Object.defineProperty(m, "TSDeclareFunction", { enumerable: true, get: function() {
    return T.tsDeclareFunction;
  } });
  Object.defineProperty(m, "TSDeclareMethod", { enumerable: true, get: function() {
    return T.tsDeclareMethod;
  } });
  Object.defineProperty(m, "TSEnumDeclaration", { enumerable: true, get: function() {
    return T.tsEnumDeclaration;
  } });
  Object.defineProperty(m, "TSEnumMember", { enumerable: true, get: function() {
    return T.tsEnumMember;
  } });
  Object.defineProperty(m, "TSExportAssignment", { enumerable: true, get: function() {
    return T.tsExportAssignment;
  } });
  Object.defineProperty(m, "TSExpressionWithTypeArguments", { enumerable: true, get: function() {
    return T.tsExpressionWithTypeArguments;
  } });
  Object.defineProperty(m, "TSExternalModuleReference", { enumerable: true, get: function() {
    return T.tsExternalModuleReference;
  } });
  Object.defineProperty(m, "TSFunctionType", { enumerable: true, get: function() {
    return T.tsFunctionType;
  } });
  Object.defineProperty(m, "TSImportEqualsDeclaration", { enumerable: true, get: function() {
    return T.tsImportEqualsDeclaration;
  } });
  Object.defineProperty(m, "TSImportType", { enumerable: true, get: function() {
    return T.tsImportType;
  } });
  Object.defineProperty(m, "TSIndexSignature", { enumerable: true, get: function() {
    return T.tsIndexSignature;
  } });
  Object.defineProperty(m, "TSIndexedAccessType", { enumerable: true, get: function() {
    return T.tsIndexedAccessType;
  } });
  Object.defineProperty(m, "TSInferType", { enumerable: true, get: function() {
    return T.tsInferType;
  } });
  Object.defineProperty(m, "TSInstantiationExpression", { enumerable: true, get: function() {
    return T.tsInstantiationExpression;
  } });
  Object.defineProperty(m, "TSInterfaceBody", { enumerable: true, get: function() {
    return T.tsInterfaceBody;
  } });
  Object.defineProperty(m, "TSInterfaceDeclaration", { enumerable: true, get: function() {
    return T.tsInterfaceDeclaration;
  } });
  Object.defineProperty(m, "TSIntersectionType", { enumerable: true, get: function() {
    return T.tsIntersectionType;
  } });
  Object.defineProperty(m, "TSIntrinsicKeyword", { enumerable: true, get: function() {
    return T.tsIntrinsicKeyword;
  } });
  Object.defineProperty(m, "TSLiteralType", { enumerable: true, get: function() {
    return T.tsLiteralType;
  } });
  Object.defineProperty(m, "TSMappedType", { enumerable: true, get: function() {
    return T.tsMappedType;
  } });
  Object.defineProperty(m, "TSMethodSignature", { enumerable: true, get: function() {
    return T.tsMethodSignature;
  } });
  Object.defineProperty(m, "TSModuleBlock", { enumerable: true, get: function() {
    return T.tsModuleBlock;
  } });
  Object.defineProperty(m, "TSModuleDeclaration", { enumerable: true, get: function() {
    return T.tsModuleDeclaration;
  } });
  Object.defineProperty(m, "TSNamedTupleMember", { enumerable: true, get: function() {
    return T.tsNamedTupleMember;
  } });
  Object.defineProperty(m, "TSNamespaceExportDeclaration", { enumerable: true, get: function() {
    return T.tsNamespaceExportDeclaration;
  } });
  Object.defineProperty(m, "TSNeverKeyword", { enumerable: true, get: function() {
    return T.tsNeverKeyword;
  } });
  Object.defineProperty(m, "TSNonNullExpression", { enumerable: true, get: function() {
    return T.tsNonNullExpression;
  } });
  Object.defineProperty(m, "TSNullKeyword", { enumerable: true, get: function() {
    return T.tsNullKeyword;
  } });
  Object.defineProperty(m, "TSNumberKeyword", { enumerable: true, get: function() {
    return T.tsNumberKeyword;
  } });
  Object.defineProperty(m, "TSObjectKeyword", { enumerable: true, get: function() {
    return T.tsObjectKeyword;
  } });
  Object.defineProperty(m, "TSOptionalType", { enumerable: true, get: function() {
    return T.tsOptionalType;
  } });
  Object.defineProperty(m, "TSParameterProperty", { enumerable: true, get: function() {
    return T.tsParameterProperty;
  } });
  Object.defineProperty(m, "TSParenthesizedType", { enumerable: true, get: function() {
    return T.tsParenthesizedType;
  } });
  Object.defineProperty(m, "TSPropertySignature", { enumerable: true, get: function() {
    return T.tsPropertySignature;
  } });
  Object.defineProperty(m, "TSQualifiedName", { enumerable: true, get: function() {
    return T.tsQualifiedName;
  } });
  Object.defineProperty(m, "TSRestType", { enumerable: true, get: function() {
    return T.tsRestType;
  } });
  Object.defineProperty(m, "TSSatisfiesExpression", { enumerable: true, get: function() {
    return T.tsSatisfiesExpression;
  } });
  Object.defineProperty(m, "TSStringKeyword", { enumerable: true, get: function() {
    return T.tsStringKeyword;
  } });
  Object.defineProperty(m, "TSSymbolKeyword", { enumerable: true, get: function() {
    return T.tsSymbolKeyword;
  } });
  Object.defineProperty(m, "TSThisType", { enumerable: true, get: function() {
    return T.tsThisType;
  } });
  Object.defineProperty(m, "TSTupleType", { enumerable: true, get: function() {
    return T.tsTupleType;
  } });
  Object.defineProperty(m, "TSTypeAliasDeclaration", { enumerable: true, get: function() {
    return T.tsTypeAliasDeclaration;
  } });
  Object.defineProperty(m, "TSTypeAnnotation", { enumerable: true, get: function() {
    return T.tsTypeAnnotation;
  } });
  Object.defineProperty(m, "TSTypeAssertion", { enumerable: true, get: function() {
    return T.tsTypeAssertion;
  } });
  Object.defineProperty(m, "TSTypeLiteral", { enumerable: true, get: function() {
    return T.tsTypeLiteral;
  } });
  Object.defineProperty(m, "TSTypeOperator", { enumerable: true, get: function() {
    return T.tsTypeOperator;
  } });
  Object.defineProperty(m, "TSTypeParameter", { enumerable: true, get: function() {
    return T.tsTypeParameter;
  } });
  Object.defineProperty(m, "TSTypeParameterDeclaration", { enumerable: true, get: function() {
    return T.tsTypeParameterDeclaration;
  } });
  Object.defineProperty(m, "TSTypeParameterInstantiation", { enumerable: true, get: function() {
    return T.tsTypeParameterInstantiation;
  } });
  Object.defineProperty(m, "TSTypePredicate", { enumerable: true, get: function() {
    return T.tsTypePredicate;
  } });
  Object.defineProperty(m, "TSTypeQuery", { enumerable: true, get: function() {
    return T.tsTypeQuery;
  } });
  Object.defineProperty(m, "TSTypeReference", { enumerable: true, get: function() {
    return T.tsTypeReference;
  } });
  Object.defineProperty(m, "TSUndefinedKeyword", { enumerable: true, get: function() {
    return T.tsUndefinedKeyword;
  } });
  Object.defineProperty(m, "TSUnionType", { enumerable: true, get: function() {
    return T.tsUnionType;
  } });
  Object.defineProperty(m, "TSUnknownKeyword", { enumerable: true, get: function() {
    return T.tsUnknownKeyword;
  } });
  Object.defineProperty(m, "TSVoidKeyword", { enumerable: true, get: function() {
    return T.tsVoidKeyword;
  } });
  Object.defineProperty(m, "TaggedTemplateExpression", { enumerable: true, get: function() {
    return T.taggedTemplateExpression;
  } });
  Object.defineProperty(m, "TemplateElement", { enumerable: true, get: function() {
    return T.templateElement;
  } });
  Object.defineProperty(m, "TemplateLiteral", { enumerable: true, get: function() {
    return T.templateLiteral;
  } });
  Object.defineProperty(m, "ThisExpression", { enumerable: true, get: function() {
    return T.thisExpression;
  } });
  Object.defineProperty(m, "ThisTypeAnnotation", { enumerable: true, get: function() {
    return T.thisTypeAnnotation;
  } });
  Object.defineProperty(m, "ThrowStatement", { enumerable: true, get: function() {
    return T.throwStatement;
  } });
  Object.defineProperty(m, "TopicReference", { enumerable: true, get: function() {
    return T.topicReference;
  } });
  Object.defineProperty(m, "TryStatement", { enumerable: true, get: function() {
    return T.tryStatement;
  } });
  Object.defineProperty(m, "TupleExpression", { enumerable: true, get: function() {
    return T.tupleExpression;
  } });
  Object.defineProperty(m, "TupleTypeAnnotation", { enumerable: true, get: function() {
    return T.tupleTypeAnnotation;
  } });
  Object.defineProperty(m, "TypeAlias", { enumerable: true, get: function() {
    return T.typeAlias;
  } });
  Object.defineProperty(m, "TypeAnnotation", { enumerable: true, get: function() {
    return T.typeAnnotation;
  } });
  Object.defineProperty(m, "TypeCastExpression", { enumerable: true, get: function() {
    return T.typeCastExpression;
  } });
  Object.defineProperty(m, "TypeParameter", { enumerable: true, get: function() {
    return T.typeParameter;
  } });
  Object.defineProperty(m, "TypeParameterDeclaration", { enumerable: true, get: function() {
    return T.typeParameterDeclaration;
  } });
  Object.defineProperty(m, "TypeParameterInstantiation", { enumerable: true, get: function() {
    return T.typeParameterInstantiation;
  } });
  Object.defineProperty(m, "TypeofTypeAnnotation", { enumerable: true, get: function() {
    return T.typeofTypeAnnotation;
  } });
  Object.defineProperty(m, "UnaryExpression", { enumerable: true, get: function() {
    return T.unaryExpression;
  } });
  Object.defineProperty(m, "UnionTypeAnnotation", { enumerable: true, get: function() {
    return T.unionTypeAnnotation;
  } });
  Object.defineProperty(m, "UpdateExpression", { enumerable: true, get: function() {
    return T.updateExpression;
  } });
  Object.defineProperty(m, "V8IntrinsicIdentifier", { enumerable: true, get: function() {
    return T.v8IntrinsicIdentifier;
  } });
  Object.defineProperty(m, "VariableDeclaration", { enumerable: true, get: function() {
    return T.variableDeclaration;
  } });
  Object.defineProperty(m, "VariableDeclarator", { enumerable: true, get: function() {
    return T.variableDeclarator;
  } });
  Object.defineProperty(m, "Variance", { enumerable: true, get: function() {
    return T.variance;
  } });
  Object.defineProperty(m, "VoidTypeAnnotation", { enumerable: true, get: function() {
    return T.voidTypeAnnotation;
  } });
  Object.defineProperty(m, "WhileStatement", { enumerable: true, get: function() {
    return T.whileStatement;
  } });
  Object.defineProperty(m, "WithStatement", { enumerable: true, get: function() {
    return T.withStatement;
  } });
  Object.defineProperty(m, "YieldExpression", { enumerable: true, get: function() {
    return T.yieldExpression;
  } });
  var T = Ae();
});
var cc = x((ja) => {
  "use strict";
  o();
  Object.defineProperty(ja, "__esModule", { value: true });
  ja.buildUndefinedNode = Rw;
  var lc = Ae();
  function Rw() {
    return (0, lc.unaryExpression)("void", (0, lc.numericLiteral)(0), true);
  }
});
var Qe = x((Ra) => {
  "use strict";
  o();
  Object.defineProperty(Ra, "__esModule", { value: true });
  Ra.default = Mw;
  var fc = je(), pc = pe(), Ue = Function.call.bind(Object.prototype.hasOwnProperty);
  function dc(e, t, r, n) {
    return e && typeof e.type == "string" ? mc(e, t, r, n) : e;
  }
  function yc(e, t, r, n) {
    return Array.isArray(e) ? e.map((i) => dc(i, t, r, n)) : dc(e, t, r, n);
  }
  function Mw(e, t = true, r = false) {
    return mc(e, t, r, /* @__PURE__ */ new Map());
  }
  function mc(e, t = true, r = false, n) {
    if (!e)
      return e;
    let { type: i } = e, l = { type: e.type };
    if ((0, pc.isIdentifier)(e))
      l.name = e.name, Ue(e, "optional") && typeof e.optional == "boolean" && (l.optional = e.optional), Ue(e, "typeAnnotation") && (l.typeAnnotation = t ? yc(e.typeAnnotation, true, r, n) : e.typeAnnotation);
    else if (Ue(fc.NODE_FIELDS, i))
      for (let y of Object.keys(fc.NODE_FIELDS[i]))
        Ue(e, y) && (t ? l[y] = (0, pc.isFile)(e) && y === "comments" ? Wr(e.comments, t, r, n) : yc(e[y], true, r, n) : l[y] = e[y]);
    else
      throw new Error(`Unknown node type: "${i}"`);
    return Ue(e, "loc") && (r ? l.loc = null : l.loc = e.loc), Ue(e, "leadingComments") && (l.leadingComments = Wr(e.leadingComments, t, r, n)), Ue(e, "innerComments") && (l.innerComments = Wr(e.innerComments, t, r, n)), Ue(e, "trailingComments") && (l.trailingComments = Wr(e.trailingComments, t, r, n)), Ue(e, "extra") && (l.extra = Object.assign({}, e.extra)), l;
  }
  function Wr(e, t, r, n) {
    return !e || !t ? e : e.map((i) => {
      let l = n.get(i);
      if (l)
        return l;
      let { type: y, value: S, loc: P } = i, A = { type: y, value: S, loc: P };
      return r && (A.loc = null), n.set(i, A), A;
    });
  }
});
var Tc = x((Ma) => {
  "use strict";
  o();
  Object.defineProperty(Ma, "__esModule", { value: true });
  Ma.default = Fw;
  var Bw = Qe();
  function Fw(e) {
    return (0, Bw.default)(e, false);
  }
});
var Sc = x((Ba) => {
  "use strict";
  o();
  Object.defineProperty(Ba, "__esModule", { value: true });
  Ba.default = Kw;
  var kw = Qe();
  function Kw(e) {
    return (0, kw.default)(e);
  }
});
var bc = x((Fa) => {
  "use strict";
  o();
  Object.defineProperty(Fa, "__esModule", { value: true });
  Fa.default = Yw;
  var qw = Qe();
  function Yw(e) {
    return (0, qw.default)(e, true, true);
  }
});
var Ec = x((ka) => {
  "use strict";
  o();
  Object.defineProperty(ka, "__esModule", { value: true });
  ka.default = Uw;
  var Vw = Qe();
  function Uw(e) {
    return (0, Vw.default)(e, false, true);
  }
});
var qa = x((Ka) => {
  "use strict";
  o();
  Object.defineProperty(Ka, "__esModule", { value: true });
  Ka.default = Jw;
  function Jw(e, t, r) {
    if (!r || !e)
      return e;
    let n = `${t}Comments`;
    return e[n] ? t === "leading" ? e[n] = r.concat(e[n]) : e[n].push(...r) : e[n] = r, e;
  }
});
var vc = x((Ya) => {
  "use strict";
  o();
  Object.defineProperty(Ya, "__esModule", { value: true });
  Ya.default = Ww;
  var Xw = qa();
  function Ww(e, t, r, n) {
    return (0, Xw.default)(e, t, [{ type: n ? "CommentLine" : "CommentBlock", value: r }]);
  }
});
var $r = x((Va) => {
  "use strict";
  o();
  Object.defineProperty(Va, "__esModule", { value: true });
  Va.default = $w;
  function $w(e, t, r) {
    t && r && (t[e] = Array.from(new Set([].concat(t[e], r[e]).filter(Boolean))));
  }
});
var Ja = x((Ua) => {
  "use strict";
  o();
  Object.defineProperty(Ua, "__esModule", { value: true });
  Ua.default = zw;
  var Gw = $r();
  function zw(e, t) {
    (0, Gw.default)("innerComments", e, t);
  }
});
var Wa = x((Xa) => {
  "use strict";
  o();
  Object.defineProperty(Xa, "__esModule", { value: true });
  Xa.default = Qw;
  var Hw = $r();
  function Qw(e, t) {
    (0, Hw.default)("leadingComments", e, t);
  }
});
var Ga = x(($a) => {
  "use strict";
  o();
  Object.defineProperty($a, "__esModule", { value: true });
  $a.default = eL;
  var Zw = $r();
  function eL(e, t) {
    (0, Zw.default)("trailingComments", e, t);
  }
});
var Ha = x((za) => {
  "use strict";
  o();
  Object.defineProperty(za, "__esModule", { value: true });
  za.default = aL;
  var tL = Ga(), rL = Wa(), nL = Ja();
  function aL(e, t) {
    return (0, tL.default)(e, t), (0, rL.default)(e, t), (0, nL.default)(e, t), e;
  }
});
var Pc = x((Qa) => {
  "use strict";
  o();
  Object.defineProperty(Qa, "__esModule", { value: true });
  Qa.default = sL;
  var iL = Ge();
  function sL(e) {
    return iL.COMMENT_KEYS.forEach((t) => {
      e[t] = null;
    }), e;
  }
});
var xc = x((_) => {
  "use strict";
  o();
  Object.defineProperty(_, "__esModule", { value: true });
  _.WHILE_TYPES = _.USERWHITESPACABLE_TYPES = _.UNARYLIKE_TYPES = _.TYPESCRIPT_TYPES = _.TSTYPE_TYPES = _.TSTYPEELEMENT_TYPES = _.TSENTITYNAME_TYPES = _.TSBASETYPE_TYPES = _.TERMINATORLESS_TYPES = _.STATEMENT_TYPES = _.STANDARDIZED_TYPES = _.SCOPABLE_TYPES = _.PUREISH_TYPES = _.PROPERTY_TYPES = _.PRIVATE_TYPES = _.PATTERN_TYPES = _.PATTERNLIKE_TYPES = _.OBJECTMEMBER_TYPES = _.MODULESPECIFIER_TYPES = _.MODULEDECLARATION_TYPES = _.MISCELLANEOUS_TYPES = _.METHOD_TYPES = _.LVAL_TYPES = _.LOOP_TYPES = _.LITERAL_TYPES = _.JSX_TYPES = _.IMPORTOREXPORTDECLARATION_TYPES = _.IMMUTABLE_TYPES = _.FUNCTION_TYPES = _.FUNCTIONPARENT_TYPES = _.FOR_TYPES = _.FORXSTATEMENT_TYPES = _.FLOW_TYPES = _.FLOWTYPE_TYPES = _.FLOWPREDICATE_TYPES = _.FLOWDECLARATION_TYPES = _.FLOWBASEANNOTATION_TYPES = _.EXPRESSION_TYPES = _.EXPRESSIONWRAPPER_TYPES = _.EXPORTDECLARATION_TYPES = _.ENUMMEMBER_TYPES = _.ENUMBODY_TYPES = _.DECLARATION_TYPES = _.CONDITIONAL_TYPES = _.COMPLETIONSTATEMENT_TYPES = _.CLASS_TYPES = _.BLOCK_TYPES = _.BLOCKPARENT_TYPES = _.BINARY_TYPES = _.ACCESSOR_TYPES = void 0;
  var q = je(), Uk = _.STANDARDIZED_TYPES = q.FLIPPED_ALIAS_KEYS.Standardized, Jk = _.EXPRESSION_TYPES = q.FLIPPED_ALIAS_KEYS.Expression, Xk = _.BINARY_TYPES = q.FLIPPED_ALIAS_KEYS.Binary, Wk = _.SCOPABLE_TYPES = q.FLIPPED_ALIAS_KEYS.Scopable, $k = _.BLOCKPARENT_TYPES = q.FLIPPED_ALIAS_KEYS.BlockParent, Gk = _.BLOCK_TYPES = q.FLIPPED_ALIAS_KEYS.Block, zk = _.STATEMENT_TYPES = q.FLIPPED_ALIAS_KEYS.Statement, Hk = _.TERMINATORLESS_TYPES = q.FLIPPED_ALIAS_KEYS.Terminatorless, Qk = _.COMPLETIONSTATEMENT_TYPES = q.FLIPPED_ALIAS_KEYS.CompletionStatement, Zk = _.CONDITIONAL_TYPES = q.FLIPPED_ALIAS_KEYS.Conditional, eK = _.LOOP_TYPES = q.FLIPPED_ALIAS_KEYS.Loop, tK = _.WHILE_TYPES = q.FLIPPED_ALIAS_KEYS.While, rK = _.EXPRESSIONWRAPPER_TYPES = q.FLIPPED_ALIAS_KEYS.ExpressionWrapper, nK = _.FOR_TYPES = q.FLIPPED_ALIAS_KEYS.For, aK = _.FORXSTATEMENT_TYPES = q.FLIPPED_ALIAS_KEYS.ForXStatement, iK = _.FUNCTION_TYPES = q.FLIPPED_ALIAS_KEYS.Function, sK = _.FUNCTIONPARENT_TYPES = q.FLIPPED_ALIAS_KEYS.FunctionParent, oK = _.PUREISH_TYPES = q.FLIPPED_ALIAS_KEYS.Pureish, uK = _.DECLARATION_TYPES = q.FLIPPED_ALIAS_KEYS.Declaration, lK = _.PATTERNLIKE_TYPES = q.FLIPPED_ALIAS_KEYS.PatternLike, cK = _.LVAL_TYPES = q.FLIPPED_ALIAS_KEYS.LVal, fK = _.TSENTITYNAME_TYPES = q.FLIPPED_ALIAS_KEYS.TSEntityName, pK = _.LITERAL_TYPES = q.FLIPPED_ALIAS_KEYS.Literal, dK = _.IMMUTABLE_TYPES = q.FLIPPED_ALIAS_KEYS.Immutable, yK = _.USERWHITESPACABLE_TYPES = q.FLIPPED_ALIAS_KEYS.UserWhitespacable, mK = _.METHOD_TYPES = q.FLIPPED_ALIAS_KEYS.Method, TK = _.OBJECTMEMBER_TYPES = q.FLIPPED_ALIAS_KEYS.ObjectMember, SK = _.PROPERTY_TYPES = q.FLIPPED_ALIAS_KEYS.Property, bK = _.UNARYLIKE_TYPES = q.FLIPPED_ALIAS_KEYS.UnaryLike, EK = _.PATTERN_TYPES = q.FLIPPED_ALIAS_KEYS.Pattern, vK = _.CLASS_TYPES = q.FLIPPED_ALIAS_KEYS.Class, oL = _.IMPORTOREXPORTDECLARATION_TYPES = q.FLIPPED_ALIAS_KEYS.ImportOrExportDeclaration, PK = _.EXPORTDECLARATION_TYPES = q.FLIPPED_ALIAS_KEYS.ExportDeclaration, xK = _.MODULESPECIFIER_TYPES = q.FLIPPED_ALIAS_KEYS.ModuleSpecifier, gK = _.ACCESSOR_TYPES = q.FLIPPED_ALIAS_KEYS.Accessor, hK = _.PRIVATE_TYPES = q.FLIPPED_ALIAS_KEYS.Private, AK = _.FLOW_TYPES = q.FLIPPED_ALIAS_KEYS.Flow, OK = _.FLOWTYPE_TYPES = q.FLIPPED_ALIAS_KEYS.FlowType, IK = _.FLOWBASEANNOTATION_TYPES = q.FLIPPED_ALIAS_KEYS.FlowBaseAnnotation, _K = _.FLOWDECLARATION_TYPES = q.FLIPPED_ALIAS_KEYS.FlowDeclaration, DK = _.FLOWPREDICATE_TYPES = q.FLIPPED_ALIAS_KEYS.FlowPredicate, NK = _.ENUMBODY_TYPES = q.FLIPPED_ALIAS_KEYS.EnumBody, CK = _.ENUMMEMBER_TYPES = q.FLIPPED_ALIAS_KEYS.EnumMember, wK = _.JSX_TYPES = q.FLIPPED_ALIAS_KEYS.JSX, LK = _.MISCELLANEOUS_TYPES = q.FLIPPED_ALIAS_KEYS.Miscellaneous, jK = _.TYPESCRIPT_TYPES = q.FLIPPED_ALIAS_KEYS.TypeScript, RK = _.TSTYPEELEMENT_TYPES = q.FLIPPED_ALIAS_KEYS.TSTypeElement, MK = _.TSTYPE_TYPES = q.FLIPPED_ALIAS_KEYS.TSType, BK = _.TSBASETYPE_TYPES = q.FLIPPED_ALIAS_KEYS.TSBaseType, FK = _.MODULEDECLARATION_TYPES = oL;
});
var ti = x((ei) => {
  "use strict";
  o();
  Object.defineProperty(ei, "__esModule", { value: true });
  ei.default = uL;
  var Gr = pe(), Za = Ae();
  function uL(e, t) {
    if ((0, Gr.isBlockStatement)(e))
      return e;
    let r = [];
    return (0, Gr.isEmptyStatement)(e) ? r = [] : ((0, Gr.isStatement)(e) || ((0, Gr.isFunction)(t) ? e = (0, Za.returnStatement)(e) : e = (0, Za.expressionStatement)(e)), r = [e]), (0, Za.blockStatement)(r);
  }
});
var gc = x((ri) => {
  "use strict";
  o();
  Object.defineProperty(ri, "__esModule", { value: true });
  ri.default = cL;
  var lL = ti();
  function cL(e, t = "body") {
    let r = (0, lL.default)(e[t], e);
    return e[t] = r, r;
  }
});
var ai = x((ni) => {
  "use strict";
  o();
  Object.defineProperty(ni, "__esModule", { value: true });
  ni.default = dL;
  var fL = ht(), pL = Rr();
  function dL(e) {
    e = e + "";
    let t = "";
    for (let r of e)
      t += (0, pL.isIdentifierChar)(r.codePointAt(0)) ? r : "-";
    return t = t.replace(/^[-0-9]+/, ""), t = t.replace(/[-\s]+(.)?/g, function(r, n) {
      return n ? n.toUpperCase() : "";
    }), (0, fL.default)(t) || (t = `_${t}`), t || "_";
  }
});
var hc = x((ii) => {
  "use strict";
  o();
  Object.defineProperty(ii, "__esModule", { value: true });
  ii.default = mL;
  var yL = ai();
  function mL(e) {
    return e = (0, yL.default)(e), (e === "eval" || e === "arguments") && (e = "_" + e), e;
  }
});
var Ac = x((si) => {
  "use strict";
  o();
  Object.defineProperty(si, "__esModule", { value: true });
  si.default = bL;
  var TL = pe(), SL = Ae();
  function bL(e, t = e.key || e.property) {
    return !e.computed && (0, TL.isIdentifier)(t) && (t = (0, SL.stringLiteral)(t.name)), t;
  }
});
var Oc = x((zr) => {
  "use strict";
  o();
  Object.defineProperty(zr, "__esModule", { value: true });
  zr.default = void 0;
  var lr = pe(), JK = zr.default = EL;
  function EL(e) {
    if ((0, lr.isExpressionStatement)(e) && (e = e.expression), (0, lr.isExpression)(e))
      return e;
    if ((0, lr.isClass)(e) ? e.type = "ClassExpression" : (0, lr.isFunction)(e) && (e.type = "FunctionExpression"), !(0, lr.isExpression)(e))
      throw new Error(`cannot turn ${e.type} to an expression`);
    return e;
  }
});
var li = x((ui) => {
  "use strict";
  o();
  Object.defineProperty(ui, "__esModule", { value: true });
  ui.default = oi;
  var vL = je();
  function oi(e, t, r) {
    if (!e)
      return;
    let n = vL.VISITOR_KEYS[e.type];
    if (!!n) {
      r = r || {}, t(e, r);
      for (let i of n) {
        let l = e[i];
        if (Array.isArray(l))
          for (let y of l)
            oi(y, t, r);
        else
          oi(l, t, r);
      }
    }
  }
});
var fi = x((ci) => {
  "use strict";
  o();
  Object.defineProperty(ci, "__esModule", { value: true });
  ci.default = gL;
  var PL = Ge(), Ic = ["tokens", "start", "end", "loc", "raw", "rawValue"], xL = [...PL.COMMENT_KEYS, "comments", ...Ic];
  function gL(e, t = {}) {
    let r = t.preserveComments ? Ic : xL;
    for (let i of r)
      e[i] != null && (e[i] = void 0);
    for (let i of Object.keys(e))
      i[0] === "_" && e[i] != null && (e[i] = void 0);
    let n = Object.getOwnPropertySymbols(e);
    for (let i of n)
      e[i] = null;
  }
});
var di = x((pi) => {
  "use strict";
  o();
  Object.defineProperty(pi, "__esModule", { value: true });
  pi.default = OL;
  var hL = li(), AL = fi();
  function OL(e, t) {
    return (0, hL.default)(e, AL.default, t), e;
  }
});
var Dc = x((yi) => {
  "use strict";
  o();
  Object.defineProperty(yi, "__esModule", { value: true });
  yi.default = ot;
  var _c = pe(), IL = Qe(), _L = di();
  function ot(e, t = e.key) {
    let r;
    return e.kind === "method" ? ot.increment() + "" : ((0, _c.isIdentifier)(t) ? r = t.name : (0, _c.isStringLiteral)(t) ? r = JSON.stringify(t.value) : r = JSON.stringify((0, _L.default)((0, IL.default)(t))), e.computed && (r = `[${r}]`), e.static && (r = `static:${r}`), r);
  }
  ot.uid = 0;
  ot.increment = function() {
    return ot.uid >= Number.MAX_SAFE_INTEGER ? ot.uid = 0 : ot.uid++;
  };
});
var Nc = x((Qr) => {
  "use strict";
  o();
  Object.defineProperty(Qr, "__esModule", { value: true });
  Qr.default = void 0;
  var Hr = pe(), DL = Ae(), HK = Qr.default = NL;
  function NL(e, t) {
    if ((0, Hr.isStatement)(e))
      return e;
    let r = false, n;
    if ((0, Hr.isClass)(e))
      r = true, n = "ClassDeclaration";
    else if ((0, Hr.isFunction)(e))
      r = true, n = "FunctionDeclaration";
    else if ((0, Hr.isAssignmentExpression)(e))
      return (0, DL.expressionStatement)(e);
    if (r && !e.id && (n = false), !n) {
      if (t)
        return false;
      throw new Error(`cannot turn ${e.type} to a statement`);
    }
    return e.type = n, e;
  }
});
var Cc = x((Zr) => {
  "use strict";
  o();
  Object.defineProperty(Zr, "__esModule", { value: true });
  Zr.default = void 0;
  var CL = ht(), be = Ae(), ZK = Zr.default = mi, wL = Function.call.bind(Object.prototype.toString);
  function LL(e) {
    return wL(e) === "[object RegExp]";
  }
  function jL(e) {
    if (typeof e != "object" || e === null || Object.prototype.toString.call(e) !== "[object Object]")
      return false;
    let t = Object.getPrototypeOf(e);
    return t === null || Object.getPrototypeOf(t) === null;
  }
  function mi(e) {
    if (e === void 0)
      return (0, be.identifier)("undefined");
    if (e === true || e === false)
      return (0, be.booleanLiteral)(e);
    if (e === null)
      return (0, be.nullLiteral)();
    if (typeof e == "string")
      return (0, be.stringLiteral)(e);
    if (typeof e == "number") {
      let t;
      if (Number.isFinite(e))
        t = (0, be.numericLiteral)(Math.abs(e));
      else {
        let r;
        Number.isNaN(e) ? r = (0, be.numericLiteral)(0) : r = (0, be.numericLiteral)(1), t = (0, be.binaryExpression)("/", r, (0, be.numericLiteral)(0));
      }
      return (e < 0 || Object.is(e, -0)) && (t = (0, be.unaryExpression)("-", t)), t;
    }
    if (LL(e)) {
      let t = e.source, r = e.toString().match(/\/([a-z]+|)$/)[1];
      return (0, be.regExpLiteral)(t, r);
    }
    if (Array.isArray(e))
      return (0, be.arrayExpression)(e.map(mi));
    if (jL(e)) {
      let t = [];
      for (let r of Object.keys(e)) {
        let n;
        (0, CL.default)(r) ? n = (0, be.identifier)(r) : n = (0, be.stringLiteral)(r), t.push((0, be.objectProperty)(n, mi(e[r])));
      }
      return (0, be.objectExpression)(t);
    }
    throw new Error("don't know how to turn this value into a node");
  }
});
var wc = x((Ti) => {
  "use strict";
  o();
  Object.defineProperty(Ti, "__esModule", { value: true });
  Ti.default = ML;
  var RL = Ae();
  function ML(e, t, r = false) {
    return e.object = (0, RL.memberExpression)(e.object, e.property, e.computed), e.property = t, e.computed = !!r, e;
  }
});
var jc = x((Si) => {
  "use strict";
  o();
  Object.defineProperty(Si, "__esModule", { value: true });
  Si.default = FL;
  var Lc = Ge(), BL = Ha();
  function FL(e, t) {
    if (!e || !t)
      return e;
    for (let r of Lc.INHERIT_KEYS.optional)
      e[r] == null && (e[r] = t[r]);
    for (let r of Object.keys(t))
      r[0] === "_" && r !== "__clone" && (e[r] = t[r]);
    for (let r of Lc.INHERIT_KEYS.force)
      e[r] = t[r];
    return (0, BL.default)(e, t), e;
  }
});
var Rc = x((bi) => {
  "use strict";
  o();
  Object.defineProperty(bi, "__esModule", { value: true });
  bi.default = qL;
  var kL = Ae(), KL = ir();
  function qL(e, t) {
    if ((0, KL.isSuper)(e.object))
      throw new Error("Cannot prepend node to super property access (`super.foo`).");
    return e.object = (0, kL.memberExpression)(t, e.object), e;
  }
});
var cr = x((vi) => {
  "use strict";
  o();
  Object.defineProperty(vi, "__esModule", { value: true });
  vi.default = Ei;
  var Ze = pe();
  function Ei(e, t, r, n) {
    let i = [].concat(e), l = /* @__PURE__ */ Object.create(null);
    for (; i.length; ) {
      let y = i.shift();
      if (!y || n && ((0, Ze.isAssignmentExpression)(y) || (0, Ze.isUnaryExpression)(y)))
        continue;
      let S = Ei.keys[y.type];
      if ((0, Ze.isIdentifier)(y)) {
        t ? (l[y.name] = l[y.name] || []).push(y) : l[y.name] = y;
        continue;
      }
      if ((0, Ze.isExportDeclaration)(y) && !(0, Ze.isExportAllDeclaration)(y)) {
        (0, Ze.isDeclaration)(y.declaration) && i.push(y.declaration);
        continue;
      }
      if (r) {
        if ((0, Ze.isFunctionDeclaration)(y)) {
          i.push(y.id);
          continue;
        }
        if ((0, Ze.isFunctionExpression)(y))
          continue;
      }
      if (S)
        for (let P = 0; P < S.length; P++) {
          let A = S[P], L = y[A];
          L && (Array.isArray(L) ? i.push(...L) : i.push(L));
        }
    }
    return l;
  }
  Ei.keys = { DeclareClass: ["id"], DeclareFunction: ["id"], DeclareModule: ["id"], DeclareVariable: ["id"], DeclareInterface: ["id"], DeclareTypeAlias: ["id"], DeclareOpaqueType: ["id"], InterfaceDeclaration: ["id"], TypeAlias: ["id"], OpaqueType: ["id"], CatchClause: ["param"], LabeledStatement: ["label"], UnaryExpression: ["argument"], AssignmentExpression: ["left"], ImportSpecifier: ["local"], ImportNamespaceSpecifier: ["local"], ImportDefaultSpecifier: ["local"], ImportDeclaration: ["specifiers"], ExportSpecifier: ["exported"], ExportNamespaceSpecifier: ["exported"], ExportDefaultSpecifier: ["exported"], FunctionDeclaration: ["id", "params"], FunctionExpression: ["id", "params"], ArrowFunctionExpression: ["params"], ObjectMethod: ["params"], ClassMethod: ["params"], ClassPrivateMethod: ["params"], ForInStatement: ["left"], ForOfStatement: ["left"], ClassDeclaration: ["id"], ClassExpression: ["id"], RestElement: ["argument"], UpdateExpression: ["argument"], ObjectProperty: ["value"], AssignmentPattern: ["left"], ArrayPattern: ["elements"], ObjectPattern: ["properties"], VariableDeclaration: ["declarations"], VariableDeclarator: ["id"] };
});
var Mc = x((en) => {
  "use strict";
  o();
  Object.defineProperty(en, "__esModule", { value: true });
  en.default = void 0;
  var YL = cr(), iq = en.default = VL;
  function VL(e, t) {
    return (0, YL.default)(e, t, true);
  }
});
var Bc = x((xi) => {
  "use strict";
  o();
  Object.defineProperty(xi, "__esModule", { value: true });
  xi.default = JL;
  var UL = je();
  function JL(e, t, r) {
    typeof t == "function" && (t = { enter: t });
    let { enter: n, exit: i } = t;
    Pi(e, n, i, r, []);
  }
  function Pi(e, t, r, n, i) {
    let l = UL.VISITOR_KEYS[e.type];
    if (!!l) {
      t && t(e, i, n);
      for (let y of l) {
        let S = e[y];
        if (Array.isArray(S))
          for (let P = 0; P < S.length; P++) {
            let A = S[P];
            !A || (i.push({ node: e, key: y, index: P }), Pi(A, t, r, n, i), i.pop());
          }
        else
          S && (i.push({ node: e, key: y }), Pi(S, t, r, n, i), i.pop());
      }
      r && r(e, i, n);
    }
  }
});
var Fc = x((gi) => {
  "use strict";
  o();
  Object.defineProperty(gi, "__esModule", { value: true });
  gi.default = WL;
  var XL = cr();
  function WL(e, t, r) {
    if (r && e.type === "Identifier" && t.type === "ObjectProperty" && r.type === "ObjectExpression")
      return false;
    let n = XL.default.keys[t.type];
    if (n)
      for (let i = 0; i < n.length; i++) {
        let l = n[i], y = t[l];
        if (Array.isArray(y)) {
          if (y.indexOf(e) >= 0)
            return true;
        } else if (y === e)
          return true;
      }
    return false;
  }
});
var Ai = x((hi) => {
  "use strict";
  o();
  Object.defineProperty(hi, "__esModule", { value: true });
  hi.default = zL;
  var $L = pe(), GL = Ge();
  function zL(e) {
    return (0, $L.isVariableDeclaration)(e) && (e.kind !== "var" || e[GL.BLOCK_SCOPED_SYMBOL]);
  }
});
var Kc = x((Oi) => {
  "use strict";
  o();
  Object.defineProperty(Oi, "__esModule", { value: true });
  Oi.default = QL;
  var kc = pe(), HL = Ai();
  function QL(e) {
    return (0, kc.isFunctionDeclaration)(e) || (0, kc.isClassDeclaration)(e) || (0, HL.default)(e);
  }
});
var qc = x((Ii) => {
  "use strict";
  o();
  Object.defineProperty(Ii, "__esModule", { value: true });
  Ii.default = tj;
  var ZL = jr(), ej = pe();
  function tj(e) {
    return (0, ZL.default)(e.type, "Immutable") ? true : (0, ej.isIdentifier)(e) ? e.name === "undefined" : false;
  }
});
var Vc = x((Di) => {
  "use strict";
  o();
  Object.defineProperty(Di, "__esModule", { value: true });
  Di.default = _i;
  var Yc = je();
  function _i(e, t) {
    if (typeof e != "object" || typeof t != "object" || e == null || t == null)
      return e === t;
    if (e.type !== t.type)
      return false;
    let r = Object.keys(Yc.NODE_FIELDS[e.type] || e.type), n = Yc.VISITOR_KEYS[e.type];
    for (let i of r) {
      let l = e[i], y = t[i];
      if (typeof l != typeof y)
        return false;
      if (!(l == null && y == null)) {
        if (l == null || y == null)
          return false;
        if (Array.isArray(l)) {
          if (!Array.isArray(y) || l.length !== y.length)
            return false;
          for (let S = 0; S < l.length; S++)
            if (!_i(l[S], y[S]))
              return false;
          continue;
        }
        if (typeof l == "object" && !(n != null && n.includes(i))) {
          for (let S of Object.keys(l))
            if (l[S] !== y[S])
              return false;
          continue;
        }
        if (!_i(l, y))
          return false;
      }
    }
    return true;
  }
});
var Uc = x((Ni) => {
  "use strict";
  o();
  Object.defineProperty(Ni, "__esModule", { value: true });
  Ni.default = rj;
  function rj(e, t, r) {
    switch (t.type) {
      case "MemberExpression":
      case "OptionalMemberExpression":
        return t.property === e ? !!t.computed : t.object === e;
      case "JSXMemberExpression":
        return t.object === e;
      case "VariableDeclarator":
        return t.init === e;
      case "ArrowFunctionExpression":
        return t.body === e;
      case "PrivateName":
        return false;
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "ObjectMethod":
        return t.key === e ? !!t.computed : false;
      case "ObjectProperty":
        return t.key === e ? !!t.computed : !r || r.type !== "ObjectPattern";
      case "ClassProperty":
      case "ClassAccessorProperty":
        return t.key === e ? !!t.computed : true;
      case "ClassPrivateProperty":
        return t.key !== e;
      case "ClassDeclaration":
      case "ClassExpression":
        return t.superClass === e;
      case "AssignmentExpression":
        return t.right === e;
      case "AssignmentPattern":
        return t.right === e;
      case "LabeledStatement":
        return false;
      case "CatchClause":
        return false;
      case "RestElement":
        return false;
      case "BreakStatement":
      case "ContinueStatement":
        return false;
      case "FunctionDeclaration":
      case "FunctionExpression":
        return false;
      case "ExportNamespaceSpecifier":
      case "ExportDefaultSpecifier":
        return false;
      case "ExportSpecifier":
        return r != null && r.source ? false : t.local === e;
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
        return false;
      case "ImportAttribute":
        return false;
      case "JSXAttribute":
        return false;
      case "ObjectPattern":
      case "ArrayPattern":
        return false;
      case "MetaProperty":
        return false;
      case "ObjectTypeProperty":
        return t.key !== e;
      case "TSEnumMember":
        return t.id !== e;
      case "TSPropertySignature":
        return t.key === e ? !!t.computed : true;
    }
    return true;
  }
});
var Jc = x((Ci) => {
  "use strict";
  o();
  Object.defineProperty(Ci, "__esModule", { value: true });
  Ci.default = nj;
  var ut = pe();
  function nj(e, t) {
    return (0, ut.isBlockStatement)(e) && ((0, ut.isFunction)(t) || (0, ut.isCatchClause)(t)) ? false : (0, ut.isPattern)(e) && ((0, ut.isFunction)(t) || (0, ut.isCatchClause)(t)) ? true : (0, ut.isScopable)(e);
  }
});
var Wc = x((wi) => {
  "use strict";
  o();
  Object.defineProperty(wi, "__esModule", { value: true });
  wi.default = aj;
  var Xc = pe();
  function aj(e) {
    return (0, Xc.isImportDefaultSpecifier)(e) || (0, Xc.isIdentifier)(e.imported || e.exported, { name: "default" });
  }
});
var $c = x((Li) => {
  "use strict";
  o();
  Object.defineProperty(Li, "__esModule", { value: true });
  Li.default = oj;
  var ij = ht(), sj = /* @__PURE__ */ new Set(["abstract", "boolean", "byte", "char", "double", "enum", "final", "float", "goto", "implements", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "synchronized", "throws", "transient", "volatile"]);
  function oj(e) {
    return (0, ij.default)(e) && !sj.has(e);
  }
});
var Gc = x((ji) => {
  "use strict";
  o();
  Object.defineProperty(ji, "__esModule", { value: true });
  ji.default = cj;
  var uj = pe(), lj = Ge();
  function cj(e) {
    return (0, uj.isVariableDeclaration)(e, { kind: "var" }) && !e[lj.BLOCK_SCOPED_SYMBOL];
  }
});
var zc = x((Mi) => {
  "use strict";
  o();
  Object.defineProperty(Mi, "__esModule", { value: true });
  Mi.default = tn;
  var fj = cr(), lt = pe(), Ri = Ae(), pj = Qe();
  function tn(e, t, r) {
    let n = [], i = true;
    for (let l of e)
      if ((0, lt.isEmptyStatement)(l) || (i = false), (0, lt.isExpression)(l))
        n.push(l);
      else if ((0, lt.isExpressionStatement)(l))
        n.push(l.expression);
      else if ((0, lt.isVariableDeclaration)(l)) {
        if (l.kind !== "var")
          return;
        for (let y of l.declarations) {
          let S = (0, fj.default)(y);
          for (let P of Object.keys(S))
            r.push({ kind: l.kind, id: (0, pj.default)(S[P]) });
          y.init && n.push((0, Ri.assignmentExpression)("=", y.id, y.init));
        }
        i = true;
      } else if ((0, lt.isIfStatement)(l)) {
        let y = l.consequent ? tn([l.consequent], t, r) : t.buildUndefinedNode(), S = l.alternate ? tn([l.alternate], t, r) : t.buildUndefinedNode();
        if (!y || !S)
          return;
        n.push((0, Ri.conditionalExpression)(l.test, y, S));
      } else if ((0, lt.isBlockStatement)(l)) {
        let y = tn(l.body, t, r);
        if (!y)
          return;
        n.push(y);
      } else if ((0, lt.isEmptyStatement)(l))
        e.indexOf(l) === 0 && (i = true);
      else
        return;
    return i && n.push(t.buildUndefinedNode()), n.length === 1 ? n[0] : (0, Ri.sequenceExpression)(n);
  }
});
var Hc = x((Bi) => {
  "use strict";
  o();
  Object.defineProperty(Bi, "__esModule", { value: true });
  Bi.default = yj;
  var dj = zc();
  function yj(e, t) {
    if (!(e != null && e.length))
      return;
    let r = [], n = (0, dj.default)(e, t, r);
    if (!!n) {
      for (let i of r)
        t.push(i);
      return n;
    }
  }
});
var ir = x((C) => {
  "use strict";
  o();
  Object.defineProperty(C, "__esModule", { value: true });
  var Je = { react: true, assertNode: true, createTypeAnnotationBasedOnTypeof: true, createUnionTypeAnnotation: true, createFlowUnionType: true, createTSUnionType: true, cloneNode: true, clone: true, cloneDeep: true, cloneDeepWithoutLoc: true, cloneWithoutLoc: true, addComment: true, addComments: true, inheritInnerComments: true, inheritLeadingComments: true, inheritsComments: true, inheritTrailingComments: true, removeComments: true, ensureBlock: true, toBindingIdentifierName: true, toBlock: true, toComputedKey: true, toExpression: true, toIdentifier: true, toKeyAlias: true, toStatement: true, valueToNode: true, appendToMemberExpression: true, inherits: true, prependToMemberExpression: true, removeProperties: true, removePropertiesDeep: true, removeTypeDuplicates: true, getBindingIdentifiers: true, getOuterBindingIdentifiers: true, traverse: true, traverseFast: true, shallowEqual: true, is: true, isBinding: true, isBlockScoped: true, isImmutable: true, isLet: true, isNode: true, isNodesEquivalent: true, isPlaceholderType: true, isReferenced: true, isScope: true, isSpecifierDefault: true, isType: true, isValidES3Identifier: true, isValidIdentifier: true, isVar: true, matchesPattern: true, validate: true, buildMatchMemberExpression: true, __internal__deprecationWarning: true };
  Object.defineProperty(C, "__internal__deprecationWarning", { enumerable: true, get: function() {
    return TR.default;
  } });
  Object.defineProperty(C, "addComment", { enumerable: true, get: function() {
    return Oj.default;
  } });
  Object.defineProperty(C, "addComments", { enumerable: true, get: function() {
    return Ij.default;
  } });
  Object.defineProperty(C, "appendToMemberExpression", { enumerable: true, get: function() {
    return Yj.default;
  } });
  Object.defineProperty(C, "assertNode", { enumerable: true, get: function() {
    return bj.default;
  } });
  Object.defineProperty(C, "buildMatchMemberExpression", { enumerable: true, get: function() {
    return mR.default;
  } });
  Object.defineProperty(C, "clone", { enumerable: true, get: function() {
    return xj.default;
  } });
  Object.defineProperty(C, "cloneDeep", { enumerable: true, get: function() {
    return gj.default;
  } });
  Object.defineProperty(C, "cloneDeepWithoutLoc", { enumerable: true, get: function() {
    return hj.default;
  } });
  Object.defineProperty(C, "cloneNode", { enumerable: true, get: function() {
    return Pj.default;
  } });
  Object.defineProperty(C, "cloneWithoutLoc", { enumerable: true, get: function() {
    return Aj.default;
  } });
  Object.defineProperty(C, "createFlowUnionType", { enumerable: true, get: function() {
    return Qc.default;
  } });
  Object.defineProperty(C, "createTSUnionType", { enumerable: true, get: function() {
    return vj.default;
  } });
  Object.defineProperty(C, "createTypeAnnotationBasedOnTypeof", { enumerable: true, get: function() {
    return Ej.default;
  } });
  Object.defineProperty(C, "createUnionTypeAnnotation", { enumerable: true, get: function() {
    return Qc.default;
  } });
  Object.defineProperty(C, "ensureBlock", { enumerable: true, get: function() {
    return Lj.default;
  } });
  Object.defineProperty(C, "getBindingIdentifiers", { enumerable: true, get: function() {
    return $j.default;
  } });
  Object.defineProperty(C, "getOuterBindingIdentifiers", { enumerable: true, get: function() {
    return Gj.default;
  } });
  Object.defineProperty(C, "inheritInnerComments", { enumerable: true, get: function() {
    return _j.default;
  } });
  Object.defineProperty(C, "inheritLeadingComments", { enumerable: true, get: function() {
    return Dj.default;
  } });
  Object.defineProperty(C, "inheritTrailingComments", { enumerable: true, get: function() {
    return Cj.default;
  } });
  Object.defineProperty(C, "inherits", { enumerable: true, get: function() {
    return Vj.default;
  } });
  Object.defineProperty(C, "inheritsComments", { enumerable: true, get: function() {
    return Nj.default;
  } });
  Object.defineProperty(C, "is", { enumerable: true, get: function() {
    return Qj.default;
  } });
  Object.defineProperty(C, "isBinding", { enumerable: true, get: function() {
    return Zj.default;
  } });
  Object.defineProperty(C, "isBlockScoped", { enumerable: true, get: function() {
    return eR.default;
  } });
  Object.defineProperty(C, "isImmutable", { enumerable: true, get: function() {
    return tR.default;
  } });
  Object.defineProperty(C, "isLet", { enumerable: true, get: function() {
    return rR.default;
  } });
  Object.defineProperty(C, "isNode", { enumerable: true, get: function() {
    return nR.default;
  } });
  Object.defineProperty(C, "isNodesEquivalent", { enumerable: true, get: function() {
    return aR.default;
  } });
  Object.defineProperty(C, "isPlaceholderType", { enumerable: true, get: function() {
    return iR.default;
  } });
  Object.defineProperty(C, "isReferenced", { enumerable: true, get: function() {
    return sR.default;
  } });
  Object.defineProperty(C, "isScope", { enumerable: true, get: function() {
    return oR.default;
  } });
  Object.defineProperty(C, "isSpecifierDefault", { enumerable: true, get: function() {
    return uR.default;
  } });
  Object.defineProperty(C, "isType", { enumerable: true, get: function() {
    return lR.default;
  } });
  Object.defineProperty(C, "isValidES3Identifier", { enumerable: true, get: function() {
    return cR.default;
  } });
  Object.defineProperty(C, "isValidIdentifier", { enumerable: true, get: function() {
    return fR.default;
  } });
  Object.defineProperty(C, "isVar", { enumerable: true, get: function() {
    return pR.default;
  } });
  Object.defineProperty(C, "matchesPattern", { enumerable: true, get: function() {
    return dR.default;
  } });
  Object.defineProperty(C, "prependToMemberExpression", { enumerable: true, get: function() {
    return Uj.default;
  } });
  C.react = void 0;
  Object.defineProperty(C, "removeComments", { enumerable: true, get: function() {
    return wj.default;
  } });
  Object.defineProperty(C, "removeProperties", { enumerable: true, get: function() {
    return Jj.default;
  } });
  Object.defineProperty(C, "removePropertiesDeep", { enumerable: true, get: function() {
    return Xj.default;
  } });
  Object.defineProperty(C, "removeTypeDuplicates", { enumerable: true, get: function() {
    return Wj.default;
  } });
  Object.defineProperty(C, "shallowEqual", { enumerable: true, get: function() {
    return Hj.default;
  } });
  Object.defineProperty(C, "toBindingIdentifierName", { enumerable: true, get: function() {
    return jj.default;
  } });
  Object.defineProperty(C, "toBlock", { enumerable: true, get: function() {
    return Rj.default;
  } });
  Object.defineProperty(C, "toComputedKey", { enumerable: true, get: function() {
    return Mj.default;
  } });
  Object.defineProperty(C, "toExpression", { enumerable: true, get: function() {
    return Bj.default;
  } });
  Object.defineProperty(C, "toIdentifier", { enumerable: true, get: function() {
    return Fj.default;
  } });
  Object.defineProperty(C, "toKeyAlias", { enumerable: true, get: function() {
    return kj.default;
  } });
  Object.defineProperty(C, "toStatement", { enumerable: true, get: function() {
    return Kj.default;
  } });
  Object.defineProperty(C, "traverse", { enumerable: true, get: function() {
    return rn.default;
  } });
  Object.defineProperty(C, "traverseFast", { enumerable: true, get: function() {
    return zj.default;
  } });
  Object.defineProperty(C, "validate", { enumerable: true, get: function() {
    return yR.default;
  } });
  Object.defineProperty(C, "valueToNode", { enumerable: true, get: function() {
    return qj.default;
  } });
  var mj = rl(), Tj = nl(), Sj = Hl(), bj = Ql(), Fi = Zl();
  Object.keys(Fi).forEach(function(e) {
    e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(Je, e) || e in C && C[e] === Fi[e] || Object.defineProperty(C, e, { enumerable: true, get: function() {
      return Fi[e];
    } });
  });
  var Ej = ec(), Qc = nc(), vj = oc(), ki = Ae();
  Object.keys(ki).forEach(function(e) {
    e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(Je, e) || e in C && C[e] === ki[e] || Object.defineProperty(C, e, { enumerable: true, get: function() {
      return ki[e];
    } });
  });
  var Ki = uc();
  Object.keys(Ki).forEach(function(e) {
    e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(Je, e) || e in C && C[e] === Ki[e] || Object.defineProperty(C, e, { enumerable: true, get: function() {
      return Ki[e];
    } });
  });
  var qi = cc();
  Object.keys(qi).forEach(function(e) {
    e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(Je, e) || e in C && C[e] === qi[e] || Object.defineProperty(C, e, { enumerable: true, get: function() {
      return qi[e];
    } });
  });
  var Pj = Qe(), xj = Tc(), gj = Sc(), hj = bc(), Aj = Ec(), Oj = vc(), Ij = qa(), _j = Ja(), Dj = Wa(), Nj = Ha(), Cj = Ga(), wj = Pc(), Yi = xc();
  Object.keys(Yi).forEach(function(e) {
    e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(Je, e) || e in C && C[e] === Yi[e] || Object.defineProperty(C, e, { enumerable: true, get: function() {
      return Yi[e];
    } });
  });
  var Vi = Ge();
  Object.keys(Vi).forEach(function(e) {
    e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(Je, e) || e in C && C[e] === Vi[e] || Object.defineProperty(C, e, { enumerable: true, get: function() {
      return Vi[e];
    } });
  });
  var Lj = gc(), jj = hc(), Rj = ti(), Mj = Ac(), Bj = Oc(), Fj = ai(), kj = Dc(), Kj = Nc(), qj = Cc(), Ui = je();
  Object.keys(Ui).forEach(function(e) {
    e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(Je, e) || e in C && C[e] === Ui[e] || Object.defineProperty(C, e, { enumerable: true, get: function() {
      return Ui[e];
    } });
  });
  var Yj = wc(), Vj = jc(), Uj = Rc(), Jj = fi(), Xj = di(), Wj = Na(), $j = cr(), Gj = Mc(), rn = Bc();
  Object.keys(rn).forEach(function(e) {
    e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(Je, e) || e in C && C[e] === rn[e] || Object.defineProperty(C, e, { enumerable: true, get: function() {
      return rn[e];
    } });
  });
  var zj = li(), Hj = wr(), Qj = gt(), Zj = Fc(), eR = Kc(), tR = qc(), rR = Ai(), nR = Ia(), aR = Vc(), iR = ea(), sR = Uc(), oR = Jc(), uR = Wc(), lR = jr(), cR = $c(), fR = ht(), pR = Gc(), dR = $n(), yR = Kr(), mR = zn(), Ji = pe();
  Object.keys(Ji).forEach(function(e) {
    e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(Je, e) || e in C && C[e] === Ji[e] || Object.defineProperty(C, e, { enumerable: true, get: function() {
      return Ji[e];
    } });
  });
  var TR = $t(), vq = C.react = { isReactComponent: mj.default, isCompatTag: Tj.default, buildChildren: Sj.default };
  C.toSequenceExpression = Hc().default;
});
var tf = x((Iq, ef) => {
  o();
  function bR(e, t) {
    for (var r = -1, n = e == null ? 0 : e.length, i = Array(n); ++r < n; )
      i[r] = t(e[r], r, e);
    return i;
  }
  ef.exports = bR;
});
var nf = x((_q, rf) => {
  o();
  var ER = Array.isArray;
  rf.exports = ER;
});
var cf = x((Dq, lf) => {
  o();
  var af = Dr(), vR = tf(), PR = nf(), xR = Kn(), gR = 1 / 0, sf = af ? af.prototype : void 0, of = sf ? sf.toString : void 0;
  function uf(e) {
    if (typeof e == "string")
      return e;
    if (PR(e))
      return vR(e, uf) + "";
    if (xR(e))
      return of ? of.call(e) : "";
    var t = e + "";
    return t == "0" && 1 / e == -gR ? "-0" : t;
  }
  lf.exports = uf;
});
var fr = x((Nq, ff) => {
  o();
  var hR = cf();
  function AR(e) {
    return e == null ? "" : hR(e);
  }
  ff.exports = AR;
});
var df = x((Cq, pf) => {
  o();
  function OR(e, t, r) {
    var n = -1, i = e.length;
    t < 0 && (t = -t > i ? 0 : i + t), r = r > i ? i : r, r < 0 && (r += i), i = t > r ? 0 : r - t >>> 0, t >>>= 0;
    for (var l = Array(i); ++n < i; )
      l[n] = e[n + t];
    return l;
  }
  pf.exports = OR;
});
var mf = x((wq, yf) => {
  o();
  var IR = df();
  function _R(e, t, r) {
    var n = e.length;
    return r = r === void 0 ? n : r, !t && r >= n ? e : IR(e, t, r);
  }
  yf.exports = _R;
});
var Xi = x((Lq, Tf) => {
  o();
  var DR = "\\ud800-\\udfff", NR = "\\u0300-\\u036f", CR = "\\ufe20-\\ufe2f", wR = "\\u20d0-\\u20ff", LR = NR + CR + wR, jR = "\\ufe0e\\ufe0f", RR = "\\u200d", MR = RegExp("[" + RR + DR + LR + jR + "]");
  function BR(e) {
    return MR.test(e);
  }
  Tf.exports = BR;
});
var bf = x((jq, Sf) => {
  o();
  function FR(e) {
    return e.split("");
  }
  Sf.exports = FR;
});
var Of = x((Rq, Af) => {
  o();
  var Ef = "\\ud800-\\udfff", kR = "\\u0300-\\u036f", KR = "\\ufe20-\\ufe2f", qR = "\\u20d0-\\u20ff", YR = kR + KR + qR, VR = "\\ufe0e\\ufe0f", UR = "[" + Ef + "]", Wi = "[" + YR + "]", $i = "\\ud83c[\\udffb-\\udfff]", JR = "(?:" + Wi + "|" + $i + ")", vf = "[^" + Ef + "]", Pf = "(?:\\ud83c[\\udde6-\\uddff]){2}", xf = "[\\ud800-\\udbff][\\udc00-\\udfff]", XR = "\\u200d", gf = JR + "?", hf = "[" + VR + "]?", WR = "(?:" + XR + "(?:" + [vf, Pf, xf].join("|") + ")" + hf + gf + ")*", $R = hf + gf + WR, GR = "(?:" + [vf + Wi + "?", Wi, Pf, xf, UR].join("|") + ")", zR = RegExp($i + "(?=" + $i + ")|" + GR + $R, "g");
  function HR(e) {
    return e.match(zR) || [];
  }
  Af.exports = HR;
});
var _f = x((Mq, If) => {
  o();
  var QR = bf(), ZR = Xi(), eM = Of();
  function tM(e) {
    return ZR(e) ? eM(e) : QR(e);
  }
  If.exports = tM;
});
var Nf = x((Bq, Df) => {
  o();
  var rM = mf(), nM = Xi(), aM = _f(), iM = fr();
  function sM(e) {
    return function(t) {
      t = iM(t);
      var r = nM(t) ? aM(t) : void 0, n = r ? r[0] : t.charAt(0), i = r ? rM(r, 1).join("") : t.slice(1);
      return n[e]() + i;
    };
  }
  Df.exports = sM;
});
var wf = x((Fq, Cf) => {
  o();
  var oM = Nf(), uM = oM("toUpperCase");
  Cf.exports = uM;
});
var jf = x((kq, Lf) => {
  o();
  var lM = fr(), cM = wf();
  function fM(e) {
    return cM(lM(e).toLowerCase());
  }
  Lf.exports = fM;
});
var Mf = x((Kq, Rf) => {
  o();
  function pM(e, t, r, n) {
    var i = -1, l = e == null ? 0 : e.length;
    for (n && l && (r = e[++i]); ++i < l; )
      r = t(r, e[i], i, e);
    return r;
  }
  Rf.exports = pM;
});
var Ff = x((qq, Bf) => {
  o();
  function dM(e) {
    return function(t) {
      return e == null ? void 0 : e[t];
    };
  }
  Bf.exports = dM;
});
var Kf = x((Yq, kf) => {
  o();
  var yM = Ff(), mM = { À: "A", Á: "A", Â: "A", Ã: "A", Ä: "A", Å: "A", à: "a", á: "a", â: "a", ã: "a", ä: "a", å: "a", Ç: "C", ç: "c", Ð: "D", ð: "d", È: "E", É: "E", Ê: "E", Ë: "E", è: "e", é: "e", ê: "e", ë: "e", Ì: "I", Í: "I", Î: "I", Ï: "I", ì: "i", í: "i", î: "i", ï: "i", Ñ: "N", ñ: "n", Ò: "O", Ó: "O", Ô: "O", Õ: "O", Ö: "O", Ø: "O", ò: "o", ó: "o", ô: "o", õ: "o", ö: "o", ø: "o", Ù: "U", Ú: "U", Û: "U", Ü: "U", ù: "u", ú: "u", û: "u", ü: "u", Ý: "Y", ý: "y", ÿ: "y", Æ: "Ae", æ: "ae", Þ: "Th", þ: "th", ß: "ss", Ā: "A", Ă: "A", Ą: "A", ā: "a", ă: "a", ą: "a", Ć: "C", Ĉ: "C", Ċ: "C", Č: "C", ć: "c", ĉ: "c", ċ: "c", č: "c", Ď: "D", Đ: "D", ď: "d", đ: "d", Ē: "E", Ĕ: "E", Ė: "E", Ę: "E", Ě: "E", ē: "e", ĕ: "e", ė: "e", ę: "e", ě: "e", Ĝ: "G", Ğ: "G", Ġ: "G", Ģ: "G", ĝ: "g", ğ: "g", ġ: "g", ģ: "g", Ĥ: "H", Ħ: "H", ĥ: "h", ħ: "h", Ĩ: "I", Ī: "I", Ĭ: "I", Į: "I", İ: "I", ĩ: "i", ī: "i", ĭ: "i", į: "i", ı: "i", Ĵ: "J", ĵ: "j", Ķ: "K", ķ: "k", ĸ: "k", Ĺ: "L", Ļ: "L", Ľ: "L", Ŀ: "L", Ł: "L", ĺ: "l", ļ: "l", ľ: "l", ŀ: "l", ł: "l", Ń: "N", Ņ: "N", Ň: "N", Ŋ: "N", ń: "n", ņ: "n", ň: "n", ŋ: "n", Ō: "O", Ŏ: "O", Ő: "O", ō: "o", ŏ: "o", ő: "o", Ŕ: "R", Ŗ: "R", Ř: "R", ŕ: "r", ŗ: "r", ř: "r", Ś: "S", Ŝ: "S", Ş: "S", Š: "S", ś: "s", ŝ: "s", ş: "s", š: "s", Ţ: "T", Ť: "T", Ŧ: "T", ţ: "t", ť: "t", ŧ: "t", Ũ: "U", Ū: "U", Ŭ: "U", Ů: "U", Ű: "U", Ų: "U", ũ: "u", ū: "u", ŭ: "u", ů: "u", ű: "u", ų: "u", Ŵ: "W", ŵ: "w", Ŷ: "Y", ŷ: "y", Ÿ: "Y", Ź: "Z", Ż: "Z", Ž: "Z", ź: "z", ż: "z", ž: "z", Ĳ: "IJ", ĳ: "ij", Œ: "Oe", œ: "oe", ŉ: "'n", ſ: "s" }, TM = yM(mM);
  kf.exports = TM;
});
var Yf = x((Vq, qf) => {
  o();
  var SM = Kf(), bM = fr(), EM = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, vM = "\\u0300-\\u036f", PM = "\\ufe20-\\ufe2f", xM = "\\u20d0-\\u20ff", gM = vM + PM + xM, hM = "[" + gM + "]", AM = RegExp(hM, "g");
  function OM(e) {
    return e = bM(e), e && e.replace(EM, SM).replace(AM, "");
  }
  qf.exports = OM;
});
var Uf = x((Uq, Vf) => {
  o();
  var IM = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
  function _M(e) {
    return e.match(IM) || [];
  }
  Vf.exports = _M;
});
var Xf = x((Jq, Jf) => {
  o();
  var DM = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
  function NM(e) {
    return DM.test(e);
  }
  Jf.exports = NM;
});
var fp = x((Xq, cp) => {
  o();
  var Hf = "\\ud800-\\udfff", CM = "\\u0300-\\u036f", wM = "\\ufe20-\\ufe2f", LM = "\\u20d0-\\u20ff", jM = CM + wM + LM, Qf = "\\u2700-\\u27bf", Zf = "a-z\\xdf-\\xf6\\xf8-\\xff", RM = "\\xac\\xb1\\xd7\\xf7", MM = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", BM = "\\u2000-\\u206f", FM = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", ep = "A-Z\\xc0-\\xd6\\xd8-\\xde", kM = "\\ufe0e\\ufe0f", tp = RM + MM + BM + FM, rp = "['’]", Wf = "[" + tp + "]", KM = "[" + jM + "]", np = "\\d+", qM = "[" + Qf + "]", ap = "[" + Zf + "]", ip = "[^" + Hf + tp + np + Qf + Zf + ep + "]", YM = "\\ud83c[\\udffb-\\udfff]", VM = "(?:" + KM + "|" + YM + ")", UM = "[^" + Hf + "]", sp = "(?:\\ud83c[\\udde6-\\uddff]){2}", op = "[\\ud800-\\udbff][\\udc00-\\udfff]", It = "[" + ep + "]", JM = "\\u200d", $f = "(?:" + ap + "|" + ip + ")", XM = "(?:" + It + "|" + ip + ")", Gf = "(?:" + rp + "(?:d|ll|m|re|s|t|ve))?", zf = "(?:" + rp + "(?:D|LL|M|RE|S|T|VE))?", up = VM + "?", lp = "[" + kM + "]?", WM = "(?:" + JM + "(?:" + [UM, sp, op].join("|") + ")" + lp + up + ")*", $M = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", GM = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", zM = lp + up + WM, HM = "(?:" + [qM, sp, op].join("|") + ")" + zM, QM = RegExp([It + "?" + ap + "+" + Gf + "(?=" + [Wf, It, "$"].join("|") + ")", XM + "+" + zf + "(?=" + [Wf, It + $f, "$"].join("|") + ")", It + "?" + $f + "+" + Gf, It + "+" + zf, GM, $M, np, HM].join("|"), "g");
  function ZM(e) {
    return e.match(QM) || [];
  }
  cp.exports = ZM;
});
var dp = x((Wq, pp) => {
  o();
  var eB = Uf(), tB = Xf(), rB = fr(), nB = fp();
  function aB(e, t, r) {
    return e = rB(e), t = r ? void 0 : t, t === void 0 ? tB(e) ? nB(e) : eB(e) : e.match(t) || [];
  }
  pp.exports = aB;
});
var mp = x(($q, yp) => {
  o();
  var iB = Mf(), sB = Yf(), oB = dp(), uB = "['’]", lB = RegExp(uB, "g");
  function cB(e) {
    return function(t) {
      return iB(oB(sB(t).replace(lB, "")), e, "");
    };
  }
  yp.exports = cB;
});
var Sp = x((Gq, Tp) => {
  o();
  var fB = jf(), pB = mp(), dB = pB(function(e, t, r) {
    return t = t.toLowerCase(), e + (r ? fB(t) : t);
  });
  Tp.exports = dB;
});
var Up = x((z) => {
  "use strict";
  o();
  var pr = Symbol.for("react.element"), jB = Symbol.for("react.portal"), RB = Symbol.for("react.fragment"), MB = Symbol.for("react.strict_mode"), BB = Symbol.for("react.profiler"), FB = Symbol.for("react.provider"), kB = Symbol.for("react.context"), KB = Symbol.for("react.forward_ref"), qB = Symbol.for("react.suspense"), YB = Symbol.for("react.memo"), VB = Symbol.for("react.lazy"), jp = Symbol.iterator;
  function UB(e) {
    return e === null || typeof e != "object" ? null : (e = jp && e[jp] || e["@@iterator"], typeof e == "function" ? e : null);
  }
  var Bp = { isMounted: function() {
    return false;
  }, enqueueForceUpdate: function() {
  }, enqueueReplaceState: function() {
  }, enqueueSetState: function() {
  } }, Fp = Object.assign, kp = {};
  function _t(e, t, r) {
    this.props = e, this.context = t, this.refs = kp, this.updater = r || Bp;
  }
  _t.prototype.isReactComponent = {};
  _t.prototype.setState = function(e, t) {
    if (typeof e != "object" && typeof e != "function" && e != null)
      throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, e, t, "setState");
  };
  _t.prototype.forceUpdate = function(e) {
    this.updater.enqueueForceUpdate(this, e, "forceUpdate");
  };
  function Kp() {
  }
  Kp.prototype = _t.prototype;
  function es(e, t, r) {
    this.props = e, this.context = t, this.refs = kp, this.updater = r || Bp;
  }
  var ts = es.prototype = new Kp();
  ts.constructor = es;
  Fp(ts, _t.prototype);
  ts.isPureReactComponent = true;
  var Rp = Array.isArray, qp = Object.prototype.hasOwnProperty, rs = { current: null }, Yp = { key: true, ref: true, __self: true, __source: true };
  function Vp(e, t, r) {
    var n, i = {}, l = null, y = null;
    if (t != null)
      for (n in t.ref !== void 0 && (y = t.ref), t.key !== void 0 && (l = "" + t.key), t)
        qp.call(t, n) && !Yp.hasOwnProperty(n) && (i[n] = t[n]);
    var S = arguments.length - 2;
    if (S === 1)
      i.children = r;
    else if (1 < S) {
      for (var P = Array(S), A = 0; A < S; A++)
        P[A] = arguments[A + 2];
      i.children = P;
    }
    if (e && e.defaultProps)
      for (n in S = e.defaultProps, S)
        i[n] === void 0 && (i[n] = S[n]);
    return { $$typeof: pr, type: e, key: l, ref: y, props: i, _owner: rs.current };
  }
  function JB(e, t) {
    return { $$typeof: pr, type: e.type, key: t, ref: e.ref, props: e.props, _owner: e._owner };
  }
  function ns(e) {
    return typeof e == "object" && e !== null && e.$$typeof === pr;
  }
  function XB(e) {
    var t = { "=": "=0", ":": "=2" };
    return "$" + e.replace(/[=:]/g, function(r) {
      return t[r];
    });
  }
  var Mp = /\/+/g;
  function Zi(e, t) {
    return typeof e == "object" && e !== null && e.key != null ? XB("" + e.key) : t.toString(36);
  }
  function an(e, t, r, n, i) {
    var l = typeof e;
    (l === "undefined" || l === "boolean") && (e = null);
    var y = false;
    if (e === null)
      y = true;
    else
      switch (l) {
        case "string":
        case "number":
          y = true;
          break;
        case "object":
          switch (e.$$typeof) {
            case pr:
            case jB:
              y = true;
          }
      }
    if (y)
      return y = e, i = i(y), e = n === "" ? "." + Zi(y, 0) : n, Rp(i) ? (r = "", e != null && (r = e.replace(Mp, "$&/") + "/"), an(i, t, r, "", function(A) {
        return A;
      })) : i != null && (ns(i) && (i = JB(i, r + (!i.key || y && y.key === i.key ? "" : ("" + i.key).replace(Mp, "$&/") + "/") + e)), t.push(i)), 1;
    if (y = 0, n = n === "" ? "." : n + ":", Rp(e))
      for (var S = 0; S < e.length; S++) {
        l = e[S];
        var P = n + Zi(l, S);
        y += an(l, t, r, P, i);
      }
    else if (P = UB(e), typeof P == "function")
      for (e = P.call(e), S = 0; !(l = e.next()).done; )
        l = l.value, P = n + Zi(l, S++), y += an(l, t, r, P, i);
    else if (l === "object")
      throw t = String(e), Error("Objects are not valid as a React child (found: " + (t === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : t) + "). If you meant to render a collection of children, use an array instead.");
    return y;
  }
  function nn(e, t, r) {
    if (e == null)
      return e;
    var n = [], i = 0;
    return an(e, n, "", "", function(l) {
      return t.call(r, l, i++);
    }), n;
  }
  function WB(e) {
    if (e._status === -1) {
      var t = e._result;
      t = t(), t.then(function(r) {
        (e._status === 0 || e._status === -1) && (e._status = 1, e._result = r);
      }, function(r) {
        (e._status === 0 || e._status === -1) && (e._status = 2, e._result = r);
      }), e._status === -1 && (e._status = 0, e._result = t);
    }
    if (e._status === 1)
      return e._result.default;
    throw e._result;
  }
  var Ie = { current: null }, sn = { transition: null }, $B = { ReactCurrentDispatcher: Ie, ReactCurrentBatchConfig: sn, ReactCurrentOwner: rs };
  z.Children = { map: nn, forEach: function(e, t, r) {
    nn(e, function() {
      t.apply(this, arguments);
    }, r);
  }, count: function(e) {
    var t = 0;
    return nn(e, function() {
      t++;
    }), t;
  }, toArray: function(e) {
    return nn(e, function(t) {
      return t;
    }) || [];
  }, only: function(e) {
    if (!ns(e))
      throw Error("React.Children.only expected to receive a single React element child.");
    return e;
  } };
  z.Component = _t;
  z.Fragment = RB;
  z.Profiler = BB;
  z.PureComponent = es;
  z.StrictMode = MB;
  z.Suspense = qB;
  z.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = $B;
  z.cloneElement = function(e, t, r) {
    if (e == null)
      throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + e + ".");
    var n = Fp({}, e.props), i = e.key, l = e.ref, y = e._owner;
    if (t != null) {
      if (t.ref !== void 0 && (l = t.ref, y = rs.current), t.key !== void 0 && (i = "" + t.key), e.type && e.type.defaultProps)
        var S = e.type.defaultProps;
      for (P in t)
        qp.call(t, P) && !Yp.hasOwnProperty(P) && (n[P] = t[P] === void 0 && S !== void 0 ? S[P] : t[P]);
    }
    var P = arguments.length - 2;
    if (P === 1)
      n.children = r;
    else if (1 < P) {
      S = Array(P);
      for (var A = 0; A < P; A++)
        S[A] = arguments[A + 2];
      n.children = S;
    }
    return { $$typeof: pr, type: e.type, key: i, ref: l, props: n, _owner: y };
  };
  z.createContext = function(e) {
    return e = { $$typeof: kB, _currentValue: e, _currentValue2: e, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, e.Provider = { $$typeof: FB, _context: e }, e.Consumer = e;
  };
  z.createElement = Vp;
  z.createFactory = function(e) {
    var t = Vp.bind(null, e);
    return t.type = e, t;
  };
  z.createRef = function() {
    return { current: null };
  };
  z.forwardRef = function(e) {
    return { $$typeof: KB, render: e };
  };
  z.isValidElement = ns;
  z.lazy = function(e) {
    return { $$typeof: VB, _payload: { _status: -1, _result: e }, _init: WB };
  };
  z.memo = function(e, t) {
    return { $$typeof: YB, type: e, compare: t === void 0 ? null : t };
  };
  z.startTransition = function(e) {
    var t = sn.transition;
    sn.transition = {};
    try {
      e();
    } finally {
      sn.transition = t;
    }
  };
  z.unstable_act = function() {
    throw Error("act(...) is not supported in production builds of React.");
  };
  z.useCallback = function(e, t) {
    return Ie.current.useCallback(e, t);
  };
  z.useContext = function(e) {
    return Ie.current.useContext(e);
  };
  z.useDebugValue = function() {
  };
  z.useDeferredValue = function(e) {
    return Ie.current.useDeferredValue(e);
  };
  z.useEffect = function(e, t) {
    return Ie.current.useEffect(e, t);
  };
  z.useId = function() {
    return Ie.current.useId();
  };
  z.useImperativeHandle = function(e, t, r) {
    return Ie.current.useImperativeHandle(e, t, r);
  };
  z.useInsertionEffect = function(e, t) {
    return Ie.current.useInsertionEffect(e, t);
  };
  z.useLayoutEffect = function(e, t) {
    return Ie.current.useLayoutEffect(e, t);
  };
  z.useMemo = function(e, t) {
    return Ie.current.useMemo(e, t);
  };
  z.useReducer = function(e, t, r) {
    return Ie.current.useReducer(e, t, r);
  };
  z.useRef = function(e) {
    return Ie.current.useRef(e);
  };
  z.useState = function(e) {
    return Ie.current.useState(e);
  };
  z.useSyncExternalStore = function(e, t, r) {
    return Ie.current.useSyncExternalStore(e, t, r);
  };
  z.useTransition = function() {
    return Ie.current.useTransition();
  };
  z.version = "18.2.0";
});
var Jp = x((H, on) => {
  "use strict";
  o();
  E.NODE_ENV !== "production" && function() {
    "use strict";
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ != "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var e = "18.2.0", t = Symbol.for("react.element"), r = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), i = Symbol.for("react.strict_mode"), l = Symbol.for("react.profiler"), y = Symbol.for("react.provider"), S = Symbol.for("react.context"), P = Symbol.for("react.forward_ref"), A = Symbol.for("react.suspense"), L = Symbol.for("react.suspense_list"), D = Symbol.for("react.memo"), te = Symbol.for("react.lazy"), X = Symbol.for("react.offscreen"), ie = Symbol.iterator, Re = "@@iterator";
    function fe(a) {
      if (a === null || typeof a != "object")
        return null;
      var b = ie && a[ie] || a[Re];
      return typeof b == "function" ? b : null;
    }
    var W = { current: null }, $ = { transition: null }, J = { current: null, isBatchingLegacy: false, didScheduleLegacyUpdate: false }, j = { current: null }, F = {}, V = null;
    function se(a) {
      V = a;
    }
    F.setExtraStackFrame = function(a) {
      V = a;
    }, F.getCurrentStack = null, F.getStackAddendum = function() {
      var a = "";
      V && (a += V);
      var b = F.getCurrentStack;
      return b && (a += b() || ""), a;
    };
    var _e = false, We = false, rt = false, ft = false, Dt = false, Fe = { ReactCurrentDispatcher: W, ReactCurrentBatchConfig: $, ReactCurrentOwner: j };
    Fe.ReactDebugCurrentFrame = F, Fe.ReactCurrentActQueue = J;
    function ke(a) {
      {
        for (var b = arguments.length, h = new Array(b > 1 ? b - 1 : 0), O = 1; O < b; O++)
          h[O - 1] = arguments[O];
        yr("warn", a, h);
      }
    }
    function G(a) {
      {
        for (var b = arguments.length, h = new Array(b > 1 ? b - 1 : 0), O = 1; O < b; O++)
          h[O - 1] = arguments[O];
        yr("error", a, h);
      }
    }
    function yr(a, b, h) {
      {
        var O = Fe.ReactDebugCurrentFrame, w = O.getStackAddendum();
        w !== "" && (b += "%s", h = h.concat([w]));
        var K = h.map(function(M) {
          return String(M);
        });
        K.unshift("Warning: " + b), Function.prototype.apply.call(console[a], console, K);
      }
    }
    var mr = {};
    function pt(a, b) {
      {
        var h = a.constructor, O = h && (h.displayName || h.name) || "ReactClass", w = O + "." + b;
        if (mr[w])
          return;
        G("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", b, O), mr[w] = true;
      }
    }
    var Tr = { isMounted: function(a) {
      return false;
    }, enqueueForceUpdate: function(a, b, h) {
      pt(a, "forceUpdate");
    }, enqueueReplaceState: function(a, b, h, O) {
      pt(a, "replaceState");
    }, enqueueSetState: function(a, b, h, O) {
      pt(a, "setState");
    } }, we = Object.assign, Nt = {};
    Object.freeze(Nt);
    function Ye(a, b, h) {
      this.props = a, this.context = b, this.refs = Nt, this.updater = h || Tr;
    }
    Ye.prototype.isReactComponent = {}, Ye.prototype.setState = function(a, b) {
      if (typeof a != "object" && typeof a != "function" && a != null)
        throw new Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
      this.updater.enqueueSetState(this, a, b, "setState");
    }, Ye.prototype.forceUpdate = function(a) {
      this.updater.enqueueForceUpdate(this, a, "forceUpdate");
    };
    {
      var Ct = { isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."], replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."] }, vn = function(a, b) {
        Object.defineProperty(Ye.prototype, a, { get: function() {
          ke("%s(...) is deprecated in plain JavaScript React classes. %s", b[0], b[1]);
        } });
      };
      for (var wt in Ct)
        Ct.hasOwnProperty(wt) && vn(wt, Ct[wt]);
    }
    function Sr() {
    }
    Sr.prototype = Ye.prototype;
    function Lt(a, b, h) {
      this.props = a, this.context = b, this.refs = Nt, this.updater = h || Tr;
    }
    var jt = Lt.prototype = new Sr();
    jt.constructor = Lt, we(jt, Ye.prototype), jt.isPureReactComponent = true;
    function Pn() {
      var a = { current: null };
      return Object.seal(a), a;
    }
    var xn = Array.isArray;
    function dt(a) {
      return xn(a);
    }
    function B(a) {
      {
        var b = typeof Symbol == "function" && Symbol.toStringTag, h = b && a[Symbol.toStringTag] || a.constructor.name || "Object";
        return h;
      }
    }
    function Rt(a) {
      try {
        return nt(a), false;
      } catch (b) {
        return true;
      }
    }
    function nt(a) {
      return "" + a;
    }
    function at(a) {
      if (Rt(a))
        return G("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", B(a)), nt(a);
    }
    function dd(a, b, h) {
      var O = a.displayName;
      if (O)
        return O;
      var w = b.displayName || b.name || "";
      return w !== "" ? h + "(" + w + ")" : h;
    }
    function ms(a) {
      return a.displayName || "Context";
    }
    function $e(a) {
      if (a == null)
        return null;
      if (typeof a.tag == "number" && G("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof a == "function")
        return a.displayName || a.name || null;
      if (typeof a == "string")
        return a;
      switch (a) {
        case n:
          return "Fragment";
        case r:
          return "Portal";
        case l:
          return "Profiler";
        case i:
          return "StrictMode";
        case A:
          return "Suspense";
        case L:
          return "SuspenseList";
      }
      if (typeof a == "object")
        switch (a.$$typeof) {
          case S:
            var b = a;
            return ms(b) + ".Consumer";
          case y:
            var h = a;
            return ms(h._context) + ".Provider";
          case P:
            return dd(a, a.render, "ForwardRef");
          case D:
            var O = a.displayName || null;
            return O !== null ? O : $e(a.type) || "Memo";
          case te: {
            var w = a, K = w._payload, M = w._init;
            try {
              return $e(M(K));
            } catch (Y) {
              return null;
            }
          }
        }
      return null;
    }
    var Mt = Object.prototype.hasOwnProperty, Ts = { key: true, ref: true, __self: true, __source: true }, Ss, bs, gn;
    gn = {};
    function Es(a) {
      if (Mt.call(a, "ref")) {
        var b = Object.getOwnPropertyDescriptor(a, "ref").get;
        if (b && b.isReactWarning)
          return false;
      }
      return a.ref !== void 0;
    }
    function vs(a) {
      if (Mt.call(a, "key")) {
        var b = Object.getOwnPropertyDescriptor(a, "key").get;
        if (b && b.isReactWarning)
          return false;
      }
      return a.key !== void 0;
    }
    function yd(a, b) {
      var h = function() {
        Ss || (Ss = true, G("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", b));
      };
      h.isReactWarning = true, Object.defineProperty(a, "key", { get: h, configurable: true });
    }
    function md(a, b) {
      var h = function() {
        bs || (bs = true, G("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", b));
      };
      h.isReactWarning = true, Object.defineProperty(a, "ref", { get: h, configurable: true });
    }
    function Td(a) {
      if (typeof a.ref == "string" && j.current && a.__self && j.current.stateNode !== a.__self) {
        var b = $e(j.current.type);
        gn[b] || (G('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', b, a.ref), gn[b] = true);
      }
    }
    var hn = function(a, b, h, O, w, K, M) {
      var Y = { $$typeof: t, type: a, key: b, ref: h, props: M, _owner: K };
      return Y._store = {}, Object.defineProperty(Y._store, "validated", { configurable: false, enumerable: false, writable: true, value: false }), Object.defineProperty(Y, "_self", { configurable: false, enumerable: false, writable: false, value: O }), Object.defineProperty(Y, "_source", { configurable: false, enumerable: false, writable: false, value: w }), Object.freeze && (Object.freeze(Y.props), Object.freeze(Y)), Y;
    };
    function Sd(a, b, h) {
      var O, w = {}, K = null, M = null, Y = null, Q = null;
      if (b != null) {
        Es(b) && (M = b.ref, Td(b)), vs(b) && (at(b.key), K = "" + b.key), Y = b.__self === void 0 ? null : b.__self, Q = b.__source === void 0 ? null : b.__source;
        for (O in b)
          Mt.call(b, O) && !Ts.hasOwnProperty(O) && (w[O] = b[O]);
      }
      var oe = arguments.length - 2;
      if (oe === 1)
        w.children = h;
      else if (oe > 1) {
        for (var ue = Array(oe), le = 0; le < oe; le++)
          ue[le] = arguments[le + 2];
        Object.freeze && Object.freeze(ue), w.children = ue;
      }
      if (a && a.defaultProps) {
        var ce = a.defaultProps;
        for (O in ce)
          w[O] === void 0 && (w[O] = ce[O]);
      }
      if (K || M) {
        var de = typeof a == "function" ? a.displayName || a.name || "Unknown" : a;
        K && yd(w, de), M && md(w, de);
      }
      return hn(a, K, M, Y, Q, j.current, w);
    }
    function bd(a, b) {
      var h = hn(a.type, b, a.ref, a._self, a._source, a._owner, a.props);
      return h;
    }
    function Ed(a, b, h) {
      if (a == null)
        throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + a + ".");
      var O, w = we({}, a.props), K = a.key, M = a.ref, Y = a._self, Q = a._source, oe = a._owner;
      if (b != null) {
        Es(b) && (M = b.ref, oe = j.current), vs(b) && (at(b.key), K = "" + b.key);
        var ue;
        a.type && a.type.defaultProps && (ue = a.type.defaultProps);
        for (O in b)
          Mt.call(b, O) && !Ts.hasOwnProperty(O) && (b[O] === void 0 && ue !== void 0 ? w[O] = ue[O] : w[O] = b[O]);
      }
      var le = arguments.length - 2;
      if (le === 1)
        w.children = h;
      else if (le > 1) {
        for (var ce = Array(le), de = 0; de < le; de++)
          ce[de] = arguments[de + 2];
        w.children = ce;
      }
      return hn(a.type, K, M, Y, Q, oe, w);
    }
    function yt(a) {
      return typeof a == "object" && a !== null && a.$$typeof === t;
    }
    var Ps = ".", vd = ":";
    function Pd(a) {
      var b = /[=:]/g, h = { "=": "=0", ":": "=2" }, O = a.replace(b, function(w) {
        return h[w];
      });
      return "$" + O;
    }
    var xs = false, xd = /\/+/g;
    function gs(a) {
      return a.replace(xd, "$&/");
    }
    function An(a, b) {
      return typeof a == "object" && a !== null && a.key != null ? (at(a.key), Pd("" + a.key)) : b.toString(36);
    }
    function br(a, b, h, O, w) {
      var K = typeof a;
      (K === "undefined" || K === "boolean") && (a = null);
      var M = false;
      if (a === null)
        M = true;
      else
        switch (K) {
          case "string":
          case "number":
            M = true;
            break;
          case "object":
            switch (a.$$typeof) {
              case t:
              case r:
                M = true;
            }
        }
      if (M) {
        var Y = a, Q = w(Y), oe = O === "" ? Ps + An(Y, 0) : O;
        if (dt(Q)) {
          var ue = "";
          oe != null && (ue = gs(oe) + "/"), br(Q, b, ue, "", function(my) {
            return my;
          });
        } else
          Q != null && (yt(Q) && (Q.key && (!Y || Y.key !== Q.key) && at(Q.key), Q = bd(Q, h + (Q.key && (!Y || Y.key !== Q.key) ? gs("" + Q.key) + "/" : "") + oe)), b.push(Q));
        return 1;
      }
      var le, ce, de = 0, Te = O === "" ? Ps : O + vd;
      if (dt(a))
        for (var Or = 0; Or < a.length; Or++)
          le = a[Or], ce = Te + An(le, Or), de += br(le, b, h, ce, w);
      else {
        var jn = fe(a);
        if (typeof jn == "function") {
          var Ws = a;
          jn === Ws.entries && (xs || ke("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), xs = true);
          for (var dy = jn.call(Ws), $s, yy = 0; !($s = dy.next()).done; )
            le = $s.value, ce = Te + An(le, yy++), de += br(le, b, h, ce, w);
        } else if (K === "object") {
          var Gs = String(a);
          throw new Error("Objects are not valid as a React child (found: " + (Gs === "[object Object]" ? "object with keys {" + Object.keys(a).join(", ") + "}" : Gs) + "). If you meant to render a collection of children, use an array instead.");
        }
      }
      return de;
    }
    function Er(a, b, h) {
      if (a == null)
        return a;
      var O = [], w = 0;
      return br(a, O, "", "", function(K) {
        return b.call(h, K, w++);
      }), O;
    }
    function gd(a) {
      var b = 0;
      return Er(a, function() {
        b++;
      }), b;
    }
    function hd(a, b, h) {
      Er(a, function() {
        b.apply(this, arguments);
      }, h);
    }
    function Ad(a) {
      return Er(a, function(b) {
        return b;
      }) || [];
    }
    function Od(a) {
      if (!yt(a))
        throw new Error("React.Children.only expected to receive a single React element child.");
      return a;
    }
    function Id(a) {
      var b = { $$typeof: S, _currentValue: a, _currentValue2: a, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
      b.Provider = { $$typeof: y, _context: b };
      var h = false, O = false, w = false;
      {
        var K = { $$typeof: S, _context: b };
        Object.defineProperties(K, { Provider: { get: function() {
          return O || (O = true, G("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?")), b.Provider;
        }, set: function(M) {
          b.Provider = M;
        } }, _currentValue: { get: function() {
          return b._currentValue;
        }, set: function(M) {
          b._currentValue = M;
        } }, _currentValue2: { get: function() {
          return b._currentValue2;
        }, set: function(M) {
          b._currentValue2 = M;
        } }, _threadCount: { get: function() {
          return b._threadCount;
        }, set: function(M) {
          b._threadCount = M;
        } }, Consumer: { get: function() {
          return h || (h = true, G("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?")), b.Consumer;
        } }, displayName: { get: function() {
          return b.displayName;
        }, set: function(M) {
          w || (ke("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", M), w = true);
        } } }), b.Consumer = K;
      }
      return b._currentRenderer = null, b._currentRenderer2 = null, b;
    }
    var Bt = -1, On = 0, hs = 1, _d = 2;
    function Dd(a) {
      if (a._status === Bt) {
        var b = a._result, h = b();
        if (h.then(function(K) {
          if (a._status === On || a._status === Bt) {
            var M = a;
            M._status = hs, M._result = K;
          }
        }, function(K) {
          if (a._status === On || a._status === Bt) {
            var M = a;
            M._status = _d, M._result = K;
          }
        }), a._status === Bt) {
          var O = a;
          O._status = On, O._result = h;
        }
      }
      if (a._status === hs) {
        var w = a._result;
        return w === void 0 && G(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))

Did you accidentally put curly braces around the import?`, w), "default" in w || G(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))`, w), w.default;
      } else
        throw a._result;
    }
    function Nd(a) {
      var b = { _status: Bt, _result: a }, h = { $$typeof: te, _payload: b, _init: Dd };
      {
        var O, w;
        Object.defineProperties(h, { defaultProps: { configurable: true, get: function() {
          return O;
        }, set: function(K) {
          G("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it."), O = K, Object.defineProperty(h, "defaultProps", { enumerable: true });
        } }, propTypes: { configurable: true, get: function() {
          return w;
        }, set: function(K) {
          G("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it."), w = K, Object.defineProperty(h, "propTypes", { enumerable: true });
        } } });
      }
      return h;
    }
    function Cd(a) {
      a != null && a.$$typeof === D ? G("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).") : typeof a != "function" ? G("forwardRef requires a render function but was given %s.", a === null ? "null" : typeof a) : a.length !== 0 && a.length !== 2 && G("forwardRef render functions accept exactly two parameters: props and ref. %s", a.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined."), a != null && (a.defaultProps != null || a.propTypes != null) && G("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
      var b = { $$typeof: P, render: a };
      {
        var h;
        Object.defineProperty(b, "displayName", { enumerable: false, configurable: true, get: function() {
          return h;
        }, set: function(O) {
          h = O, !a.name && !a.displayName && (a.displayName = O);
        } });
      }
      return b;
    }
    var As;
    As = Symbol.for("react.module.reference");
    function Os(a) {
      return !!(typeof a == "string" || typeof a == "function" || a === n || a === l || Dt || a === i || a === A || a === L || ft || a === X || _e || We || rt || typeof a == "object" && a !== null && (a.$$typeof === te || a.$$typeof === D || a.$$typeof === y || a.$$typeof === S || a.$$typeof === P || a.$$typeof === As || a.getModuleId !== void 0));
    }
    function wd(a, b) {
      Os(a) || G("memo: The first argument must be a component. Instead received: %s", a === null ? "null" : typeof a);
      var h = { $$typeof: D, type: a, compare: b === void 0 ? null : b };
      {
        var O;
        Object.defineProperty(h, "displayName", { enumerable: false, configurable: true, get: function() {
          return O;
        }, set: function(w) {
          O = w, !a.name && !a.displayName && (a.displayName = w);
        } });
      }
      return h;
    }
    function ve() {
      var a = W.current;
      return a === null && G(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`), a;
    }
    function Ld(a) {
      var b = ve();
      if (a._context !== void 0) {
        var h = a._context;
        h.Consumer === a ? G("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?") : h.Provider === a && G("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
      }
      return b.useContext(a);
    }
    function jd(a) {
      var b = ve();
      return b.useState(a);
    }
    function Rd(a, b, h) {
      var O = ve();
      return O.useReducer(a, b, h);
    }
    function Md(a) {
      var b = ve();
      return b.useRef(a);
    }
    function Bd(a, b) {
      var h = ve();
      return h.useEffect(a, b);
    }
    function Fd(a, b) {
      var h = ve();
      return h.useInsertionEffect(a, b);
    }
    function kd(a, b) {
      var h = ve();
      return h.useLayoutEffect(a, b);
    }
    function Kd(a, b) {
      var h = ve();
      return h.useCallback(a, b);
    }
    function qd(a, b) {
      var h = ve();
      return h.useMemo(a, b);
    }
    function Yd(a, b, h) {
      var O = ve();
      return O.useImperativeHandle(a, b, h);
    }
    function Vd(a, b) {
      {
        var h = ve();
        return h.useDebugValue(a, b);
      }
    }
    function Ud() {
      var a = ve();
      return a.useTransition();
    }
    function Jd(a) {
      var b = ve();
      return b.useDeferredValue(a);
    }
    function Xd() {
      var a = ve();
      return a.useId();
    }
    function Wd(a, b, h) {
      var O = ve();
      return O.useSyncExternalStore(a, b, h);
    }
    var Ft = 0, Is, _s, Ds, Ns, Cs, ws, Ls;
    function js() {
    }
    js.__reactDisabledLog = true;
    function $d() {
      {
        if (Ft === 0) {
          Is = console.log, _s = console.info, Ds = console.warn, Ns = console.error, Cs = console.group, ws = console.groupCollapsed, Ls = console.groupEnd;
          var a = { configurable: true, enumerable: true, value: js, writable: true };
          Object.defineProperties(console, { info: a, log: a, warn: a, error: a, group: a, groupCollapsed: a, groupEnd: a });
        }
        Ft++;
      }
    }
    function Gd() {
      {
        if (Ft--, Ft === 0) {
          var a = { configurable: true, enumerable: true, writable: true };
          Object.defineProperties(console, { log: we({}, a, { value: Is }), info: we({}, a, { value: _s }), warn: we({}, a, { value: Ds }), error: we({}, a, { value: Ns }), group: we({}, a, { value: Cs }), groupCollapsed: we({}, a, { value: ws }), groupEnd: we({}, a, { value: Ls }) });
        }
        Ft < 0 && G("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var In = Fe.ReactCurrentDispatcher, _n;
    function vr(a, b, h) {
      {
        if (_n === void 0)
          try {
            throw Error();
          } catch (w) {
            var O = w.stack.trim().match(/\n( *(at )?)/);
            _n = O && O[1] || "";
          }
        return `
` + _n + a;
      }
    }
    var Dn = false, Pr;
    {
      var zd = typeof WeakMap == "function" ? WeakMap : Map;
      Pr = new zd();
    }
    function Rs(a, b) {
      if (!a || Dn)
        return "";
      {
        var h = Pr.get(a);
        if (h !== void 0)
          return h;
      }
      var O;
      Dn = true;
      var w = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var K;
      K = In.current, In.current = null, $d();
      try {
        if (b) {
          var M = function() {
            throw Error();
          };
          if (Object.defineProperty(M.prototype, "props", { set: function() {
            throw Error();
          } }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(M, []);
            } catch (Te) {
              O = Te;
            }
            Reflect.construct(a, [], M);
          } else {
            try {
              M.call();
            } catch (Te) {
              O = Te;
            }
            a.call(M.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Te) {
            O = Te;
          }
          a();
        }
      } catch (Te) {
        if (Te && O && typeof Te.stack == "string") {
          for (var Y = Te.stack.split(`
`), Q = O.stack.split(`
`), oe = Y.length - 1, ue = Q.length - 1; oe >= 1 && ue >= 0 && Y[oe] !== Q[ue]; )
            ue--;
          for (; oe >= 1 && ue >= 0; oe--, ue--)
            if (Y[oe] !== Q[ue]) {
              if (oe !== 1 || ue !== 1)
                do
                  if (oe--, ue--, ue < 0 || Y[oe] !== Q[ue]) {
                    var le = `
` + Y[oe].replace(" at new ", " at ");
                    return a.displayName && le.includes("<anonymous>") && (le = le.replace("<anonymous>", a.displayName)), typeof a == "function" && Pr.set(a, le), le;
                  }
                while (oe >= 1 && ue >= 0);
              break;
            }
        }
      } finally {
        Dn = false, In.current = K, Gd(), Error.prepareStackTrace = w;
      }
      var ce = a ? a.displayName || a.name : "", de = ce ? vr(ce) : "";
      return typeof a == "function" && Pr.set(a, de), de;
    }
    function Hd(a, b, h) {
      return Rs(a, false);
    }
    function Qd(a) {
      var b = a.prototype;
      return !!(b && b.isReactComponent);
    }
    function xr(a, b, h) {
      if (a == null)
        return "";
      if (typeof a == "function")
        return Rs(a, Qd(a));
      if (typeof a == "string")
        return vr(a);
      switch (a) {
        case A:
          return vr("Suspense");
        case L:
          return vr("SuspenseList");
      }
      if (typeof a == "object")
        switch (a.$$typeof) {
          case P:
            return Hd(a.render);
          case D:
            return xr(a.type, b, h);
          case te: {
            var O = a, w = O._payload, K = O._init;
            try {
              return xr(K(w), b, h);
            } catch (M) {
            }
          }
        }
      return "";
    }
    var Ms = {}, Bs = Fe.ReactDebugCurrentFrame;
    function gr(a) {
      if (a) {
        var b = a._owner, h = xr(a.type, a._source, b ? b.type : null);
        Bs.setExtraStackFrame(h);
      } else
        Bs.setExtraStackFrame(null);
    }
    function Zd(a, b, h, O, w) {
      {
        var K = Function.call.bind(Mt);
        for (var M in a)
          if (K(a, M)) {
            var Y = void 0;
            try {
              if (typeof a[M] != "function") {
                var Q = Error((O || "React class") + ": " + h + " type `" + M + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof a[M] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Q.name = "Invariant Violation", Q;
              }
              Y = a[M](b, M, O, h, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (oe) {
              Y = oe;
            }
            Y && !(Y instanceof Error) && (gr(w), G("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", O || "React class", h, M, typeof Y), gr(null)), Y instanceof Error && !(Y.message in Ms) && (Ms[Y.message] = true, gr(w), G("Failed %s type: %s", h, Y.message), gr(null));
          }
      }
    }
    function mt(a) {
      if (a) {
        var b = a._owner, h = xr(a.type, a._source, b ? b.type : null);
        se(h);
      } else
        se(null);
    }
    var Nn;
    Nn = false;
    function Fs() {
      if (j.current) {
        var a = $e(j.current.type);
        if (a)
          return `

Check the render method of \`` + a + "`.";
      }
      return "";
    }
    function ey(a) {
      if (a !== void 0) {
        var b = a.fileName.replace(/^.*[\\\/]/, ""), h = a.lineNumber;
        return `

Check your code at ` + b + ":" + h + ".";
      }
      return "";
    }
    function ty(a) {
      return a != null ? ey(a.__source) : "";
    }
    var ks = {};
    function ry(a) {
      var b = Fs();
      if (!b) {
        var h = typeof a == "string" ? a : a.displayName || a.name;
        h && (b = `

Check the top-level render call using <` + h + ">.");
      }
      return b;
    }
    function Ks(a, b) {
      if (!(!a._store || a._store.validated || a.key != null)) {
        a._store.validated = true;
        var h = ry(b);
        if (!ks[h]) {
          ks[h] = true;
          var O = "";
          a && a._owner && a._owner !== j.current && (O = " It was passed a child from " + $e(a._owner.type) + "."), mt(a), G('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', h, O), mt(null);
        }
      }
    }
    function qs(a, b) {
      if (typeof a == "object") {
        if (dt(a))
          for (var h = 0; h < a.length; h++) {
            var O = a[h];
            yt(O) && Ks(O, b);
          }
        else if (yt(a))
          a._store && (a._store.validated = true);
        else if (a) {
          var w = fe(a);
          if (typeof w == "function" && w !== a.entries)
            for (var K = w.call(a), M; !(M = K.next()).done; )
              yt(M.value) && Ks(M.value, b);
        }
      }
    }
    function Ys(a) {
      {
        var b = a.type;
        if (b == null || typeof b == "string")
          return;
        var h;
        if (typeof b == "function")
          h = b.propTypes;
        else if (typeof b == "object" && (b.$$typeof === P || b.$$typeof === D))
          h = b.propTypes;
        else
          return;
        if (h) {
          var O = $e(b);
          Zd(h, a.props, "prop", O, a);
        } else if (b.PropTypes !== void 0 && !Nn) {
          Nn = true;
          var w = $e(b);
          G("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", w || "Unknown");
        }
        typeof b.getDefaultProps == "function" && !b.getDefaultProps.isReactClassApproved && G("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function ny(a) {
      {
        for (var b = Object.keys(a.props), h = 0; h < b.length; h++) {
          var O = b[h];
          if (O !== "children" && O !== "key") {
            mt(a), G("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", O), mt(null);
            break;
          }
        }
        a.ref !== null && (mt(a), G("Invalid attribute `ref` supplied to `React.Fragment`."), mt(null));
      }
    }
    function Vs(a, b, h) {
      var O = Os(a);
      if (!O) {
        var w = "";
        (a === void 0 || typeof a == "object" && a !== null && Object.keys(a).length === 0) && (w += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
        var K = ty(b);
        K ? w += K : w += Fs();
        var M;
        a === null ? M = "null" : dt(a) ? M = "array" : a !== void 0 && a.$$typeof === t ? (M = "<" + ($e(a.type) || "Unknown") + " />", w = " Did you accidentally export a JSX literal instead of a component?") : M = typeof a, G("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", M, w);
      }
      var Y = Sd.apply(this, arguments);
      if (Y == null)
        return Y;
      if (O)
        for (var Q = 2; Q < arguments.length; Q++)
          qs(arguments[Q], a);
      return a === n ? ny(Y) : Ys(Y), Y;
    }
    var Us = false;
    function ay(a) {
      var b = Vs.bind(null, a);
      return b.type = a, Us || (Us = true, ke("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.")), Object.defineProperty(b, "type", { enumerable: false, get: function() {
        return ke("Factory.type is deprecated. Access the class directly before passing it to createFactory."), Object.defineProperty(this, "type", { value: a }), a;
      } }), b;
    }
    function iy(a, b, h) {
      for (var O = Ed.apply(this, arguments), w = 2; w < arguments.length; w++)
        qs(arguments[w], O.type);
      return Ys(O), O;
    }
    function sy(a, b) {
      var h = $.transition;
      $.transition = {};
      var O = $.transition;
      $.transition._updatedFibers = /* @__PURE__ */ new Set();
      try {
        a();
      } finally {
        if ($.transition = h, h === null && O._updatedFibers) {
          var w = O._updatedFibers.size;
          w > 10 && ke("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), O._updatedFibers.clear();
        }
      }
    }
    var Js = false, hr = null;
    function oy(a) {
      if (hr === null)
        try {
          var b = ("require" + Math.random()).slice(0, 7), h = on && on[b];
          hr = h.call(on, "timers").setImmediate;
        } catch (O) {
          hr = function(w) {
            Js === false && (Js = true, typeof MessageChannel == "undefined" && G("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."));
            var K = new MessageChannel();
            K.port1.onmessage = w, K.port2.postMessage(void 0);
          };
        }
      return hr(a);
    }
    var Tt = 0, Xs = false;
    function uy(a) {
      {
        var b = Tt;
        Tt++, J.current === null && (J.current = []);
        var h = J.isBatchingLegacy, O;
        try {
          if (J.isBatchingLegacy = true, O = a(), !h && J.didScheduleLegacyUpdate) {
            var w = J.current;
            w !== null && (J.didScheduleLegacyUpdate = false, Ln(w));
          }
        } catch (ce) {
          throw Ar(b), ce;
        } finally {
          J.isBatchingLegacy = h;
        }
        if (O !== null && typeof O == "object" && typeof O.then == "function") {
          var K = O, M = false, Y = { then: function(ce, de) {
            M = true, K.then(function(Te) {
              Ar(b), Tt === 0 ? Cn(Te, ce, de) : ce(Te);
            }, function(Te) {
              Ar(b), de(Te);
            });
          } };
          return !Xs && typeof Promise != "undefined" && Promise.resolve().then(function() {
          }).then(function() {
            M || (Xs = true, G("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"));
          }), Y;
        } else {
          var Q = O;
          if (Ar(b), Tt === 0) {
            var oe = J.current;
            oe !== null && (Ln(oe), J.current = null);
            var ue = { then: function(ce, de) {
              J.current === null ? (J.current = [], Cn(Q, ce, de)) : ce(Q);
            } };
            return ue;
          } else {
            var le = { then: function(ce, de) {
              ce(Q);
            } };
            return le;
          }
        }
      }
    }
    function Ar(a) {
      a !== Tt - 1 && G("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. "), Tt = a;
    }
    function Cn(a, b, h) {
      {
        var O = J.current;
        if (O !== null)
          try {
            Ln(O), oy(function() {
              O.length === 0 ? (J.current = null, b(a)) : Cn(a, b, h);
            });
          } catch (w) {
            h(w);
          }
        else
          b(a);
      }
    }
    var wn = false;
    function Ln(a) {
      if (!wn) {
        wn = true;
        var b = 0;
        try {
          for (; b < a.length; b++) {
            var h = a[b];
            do
              h = h(true);
            while (h !== null);
          }
          a.length = 0;
        } catch (O) {
          throw a = a.slice(b + 1), O;
        } finally {
          wn = false;
        }
      }
    }
    var ly = Vs, cy = iy, fy = ay, py = { map: Er, forEach: hd, count: gd, toArray: Ad, only: Od };
    H.Children = py, H.Component = Ye, H.Fragment = n, H.Profiler = l, H.PureComponent = Lt, H.StrictMode = i, H.Suspense = A, H.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Fe, H.cloneElement = cy, H.createContext = Id, H.createElement = ly, H.createFactory = fy, H.createRef = Pn, H.forwardRef = Cd, H.isValidElement = yt, H.lazy = Nd, H.memo = wd, H.startTransition = sy, H.unstable_act = uy, H.useCallback = Kd, H.useContext = Ld, H.useDebugValue = Vd, H.useDeferredValue = Jd, H.useEffect = Bd, H.useId = Xd, H.useImperativeHandle = Yd, H.useInsertionEffect = Fd, H.useLayoutEffect = kd, H.useMemo = qd, H.useReducer = Rd, H.useRef = Md, H.useState = jd, H.useSyncExternalStore = Wd, H.useTransition = Ud, H.version = e, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ != "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }();
});
var Xp = x((c3, as) => {
  "use strict";
  o();
  E.NODE_ENV === "production" ? as.exports = Up() : as.exports = Jp();
});
var $p = x((ne) => {
  "use strict";
  o();
  var me = typeof Symbol == "function" && Symbol.for, ss = me ? Symbol.for("react.element") : 60103, os = me ? Symbol.for("react.portal") : 60106, cn = me ? Symbol.for("react.fragment") : 60107, fn = me ? Symbol.for("react.strict_mode") : 60108, pn = me ? Symbol.for("react.profiler") : 60114, dn = me ? Symbol.for("react.provider") : 60109, yn = me ? Symbol.for("react.context") : 60110, us = me ? Symbol.for("react.async_mode") : 60111, mn = me ? Symbol.for("react.concurrent_mode") : 60111, Tn = me ? Symbol.for("react.forward_ref") : 60112, Sn = me ? Symbol.for("react.suspense") : 60113, GB = me ? Symbol.for("react.suspense_list") : 60120, bn = me ? Symbol.for("react.memo") : 60115, En = me ? Symbol.for("react.lazy") : 60116, zB = me ? Symbol.for("react.block") : 60121, HB = me ? Symbol.for("react.fundamental") : 60117, QB = me ? Symbol.for("react.responder") : 60118, ZB = me ? Symbol.for("react.scope") : 60119;
  function Ce(e) {
    if (typeof e == "object" && e !== null) {
      var t = e.$$typeof;
      switch (t) {
        case ss:
          switch (e = e.type, e) {
            case us:
            case mn:
            case cn:
            case pn:
            case fn:
            case Sn:
              return e;
            default:
              switch (e = e && e.$$typeof, e) {
                case yn:
                case Tn:
                case En:
                case bn:
                case dn:
                  return e;
                default:
                  return t;
              }
          }
        case os:
          return t;
      }
    }
  }
  function Wp(e) {
    return Ce(e) === mn;
  }
  ne.AsyncMode = us;
  ne.ConcurrentMode = mn;
  ne.ContextConsumer = yn;
  ne.ContextProvider = dn;
  ne.Element = ss;
  ne.ForwardRef = Tn;
  ne.Fragment = cn;
  ne.Lazy = En;
  ne.Memo = bn;
  ne.Portal = os;
  ne.Profiler = pn;
  ne.StrictMode = fn;
  ne.Suspense = Sn;
  ne.isAsyncMode = function(e) {
    return Wp(e) || Ce(e) === us;
  };
  ne.isConcurrentMode = Wp;
  ne.isContextConsumer = function(e) {
    return Ce(e) === yn;
  };
  ne.isContextProvider = function(e) {
    return Ce(e) === dn;
  };
  ne.isElement = function(e) {
    return typeof e == "object" && e !== null && e.$$typeof === ss;
  };
  ne.isForwardRef = function(e) {
    return Ce(e) === Tn;
  };
  ne.isFragment = function(e) {
    return Ce(e) === cn;
  };
  ne.isLazy = function(e) {
    return Ce(e) === En;
  };
  ne.isMemo = function(e) {
    return Ce(e) === bn;
  };
  ne.isPortal = function(e) {
    return Ce(e) === os;
  };
  ne.isProfiler = function(e) {
    return Ce(e) === pn;
  };
  ne.isStrictMode = function(e) {
    return Ce(e) === fn;
  };
  ne.isSuspense = function(e) {
    return Ce(e) === Sn;
  };
  ne.isValidElementType = function(e) {
    return typeof e == "string" || typeof e == "function" || e === cn || e === mn || e === pn || e === fn || e === Sn || e === GB || typeof e == "object" && e !== null && (e.$$typeof === En || e.$$typeof === bn || e.$$typeof === dn || e.$$typeof === yn || e.$$typeof === Tn || e.$$typeof === HB || e.$$typeof === QB || e.$$typeof === ZB || e.$$typeof === zB);
  };
  ne.typeOf = Ce;
});
var Gp = x((ae) => {
  "use strict";
  o();
  E.NODE_ENV !== "production" && function() {
    "use strict";
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, r = e ? Symbol.for("react.portal") : 60106, n = e ? Symbol.for("react.fragment") : 60107, i = e ? Symbol.for("react.strict_mode") : 60108, l = e ? Symbol.for("react.profiler") : 60114, y = e ? Symbol.for("react.provider") : 60109, S = e ? Symbol.for("react.context") : 60110, P = e ? Symbol.for("react.async_mode") : 60111, A = e ? Symbol.for("react.concurrent_mode") : 60111, L = e ? Symbol.for("react.forward_ref") : 60112, D = e ? Symbol.for("react.suspense") : 60113, te = e ? Symbol.for("react.suspense_list") : 60120, X = e ? Symbol.for("react.memo") : 60115, ie = e ? Symbol.for("react.lazy") : 60116, Re = e ? Symbol.for("react.block") : 60121, fe = e ? Symbol.for("react.fundamental") : 60117, W = e ? Symbol.for("react.responder") : 60118, $ = e ? Symbol.for("react.scope") : 60119;
    function J(B) {
      return typeof B == "string" || typeof B == "function" || B === n || B === A || B === l || B === i || B === D || B === te || typeof B == "object" && B !== null && (B.$$typeof === ie || B.$$typeof === X || B.$$typeof === y || B.$$typeof === S || B.$$typeof === L || B.$$typeof === fe || B.$$typeof === W || B.$$typeof === $ || B.$$typeof === Re);
    }
    function j(B) {
      if (typeof B == "object" && B !== null) {
        var Rt = B.$$typeof;
        switch (Rt) {
          case t:
            var nt = B.type;
            switch (nt) {
              case P:
              case A:
              case n:
              case l:
              case i:
              case D:
                return nt;
              default:
                var at = nt && nt.$$typeof;
                switch (at) {
                  case S:
                  case L:
                  case ie:
                  case X:
                  case y:
                    return at;
                  default:
                    return Rt;
                }
            }
          case r:
            return Rt;
        }
      }
    }
    var F = P, V = A, se = S, _e = y, We = t, rt = L, ft = n, Dt = ie, Fe = X, ke = r, G = l, yr = i, mr = D, pt = false;
    function Tr(B) {
      return pt || (pt = true, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), we(B) || j(B) === P;
    }
    function we(B) {
      return j(B) === A;
    }
    function Nt(B) {
      return j(B) === S;
    }
    function Ye(B) {
      return j(B) === y;
    }
    function Ct(B) {
      return typeof B == "object" && B !== null && B.$$typeof === t;
    }
    function vn(B) {
      return j(B) === L;
    }
    function wt(B) {
      return j(B) === n;
    }
    function Sr(B) {
      return j(B) === ie;
    }
    function Lt(B) {
      return j(B) === X;
    }
    function jt(B) {
      return j(B) === r;
    }
    function Pn(B) {
      return j(B) === l;
    }
    function xn(B) {
      return j(B) === i;
    }
    function dt(B) {
      return j(B) === D;
    }
    ae.AsyncMode = F, ae.ConcurrentMode = V, ae.ContextConsumer = se, ae.ContextProvider = _e, ae.Element = We, ae.ForwardRef = rt, ae.Fragment = ft, ae.Lazy = Dt, ae.Memo = Fe, ae.Portal = ke, ae.Profiler = G, ae.StrictMode = yr, ae.Suspense = mr, ae.isAsyncMode = Tr, ae.isConcurrentMode = we, ae.isContextConsumer = Nt, ae.isContextProvider = Ye, ae.isElement = Ct, ae.isForwardRef = vn, ae.isFragment = wt, ae.isLazy = Sr, ae.isMemo = Lt, ae.isPortal = jt, ae.isProfiler = Pn, ae.isStrictMode = xn, ae.isSuspense = dt, ae.isValidElementType = J, ae.typeOf = j;
  }();
});
var cs = x((E3, ls) => {
  "use strict";
  o();
  E.NODE_ENV === "production" ? ls.exports = $p() : ls.exports = Gp();
});
var rd = x((v3, td) => {
  "use strict";
  o();
  var fs = cs(), eF = { childContextTypes: true, contextType: true, contextTypes: true, defaultProps: true, displayName: true, getDefaultProps: true, getDerivedStateFromError: true, getDerivedStateFromProps: true, mixins: true, propTypes: true, type: true }, tF = { name: true, length: true, prototype: true, caller: true, callee: true, arguments: true, arity: true }, rF = { $$typeof: true, render: true, defaultProps: true, displayName: true, propTypes: true }, Zp = { $$typeof: true, compare: true, defaultProps: true, displayName: true, propTypes: true, type: true }, ps = {};
  ps[fs.ForwardRef] = rF;
  ps[fs.Memo] = Zp;
  function zp(e) {
    return fs.isMemo(e) ? Zp : ps[e.$$typeof] || eF;
  }
  var nF = Object.defineProperty, aF = Object.getOwnPropertyNames, Hp = Object.getOwnPropertySymbols, iF = Object.getOwnPropertyDescriptor, sF = Object.getPrototypeOf, Qp = Object.prototype;
  function ed(e, t, r) {
    if (typeof t != "string") {
      if (Qp) {
        var n = sF(t);
        n && n !== Qp && ed(e, n, r);
      }
      var i = aF(t);
      Hp && (i = i.concat(Hp(t)));
      for (var l = zp(e), y = zp(t), S = 0; S < i.length; ++S) {
        var P = i[S];
        if (!tF[P] && !(r && r[P]) && !(y && y[P]) && !(l && l[P])) {
          var A = iF(t, P);
          try {
            nF(e, P, A);
          } catch (L) {
          }
        }
      }
    }
    return e;
  }
  td.exports = ed;
});
o();
o();
var Cp = Le(oo());
var wp = Le(Fo());
var xB = Le(Ko());
var gB = Le(zu());
o();
var SR = Le(Nr());
o();
o();
var Zu = { INLINE: "InlineStyle", STYLED_COMPONENT: "ScStyle", EMOTION: "EmotionStyle", COMPONENT_ID: "ComponentId", CSS_VARIABLE_ID: "CssVariableId" };
var Cr = class {
  constructor(t, r) {
    this.kind = t;
    this.filename = r;
  }
  displayName() {
    return null;
  }
  get ident() {
    return null;
  }
};
var Ee = Le(Nr());
var et = Le(ir());
var Be = class extends Cr {
  constructor(r, n, i) {
    super(Zu.COMPONENT_ID, r);
    this.localIdentifier = n;
    this.exportIdentifier = i;
  }
  get ident() {
    return new Oe(this.filename, this.localIdentifier || "", this.exportIdentifier || "");
  }
  displayName() {
    if (this.localIdentifier && this.localIdentifier !== "default")
      return this.localIdentifier;
    if (this.exportIdentifier === "default" && this.filename) {
      let r = Zc(this.filename);
      return `default (${r || "unidentified"})`;
    }
    return this.exportIdentifier ? this.exportIdentifier : null;
  }
  equals(r) {
    return !r || !(r instanceof Be) || this.filename !== r.filename ? false : !!(this.localIdentifier === r.localIdentifier || this.exportIdentifier && r.exportIdentifier && this.exportIdentifier === r.exportIdentifier);
  }
  toString() {
    return [this.filename, this.localIdentifier || "", this.exportIdentifier || ""].join(":");
  }
  static fromString(r) {
    let n = r.split(":");
    if (n.length !== 3) {
      console.warn("ComponentId.fromString -- invalid input string: " + r);
      return;
    }
    let i = n[0], l = n[1], y = n[2];
    return new Be(i, l, y);
  }
  static fromPlainObject(r) {
    if (r.filename)
      return new Be(r.filename, r.localIdentifier || null, r.exportIdentifier || null);
  }
  toPlain() {
    return bt(St({}, this.ident), { kind: this.kind });
  }
  addFilenamePrefix(r) {
    let n = r.endsWith("/") ? r : r + "/";
    this.filename = n + this.filename;
  }
  withoutFilenamePrefix(r) {
    let n = r.endsWith("/") ? r : r + "/";
    if (!this.filename.startsWith(n))
      throw new Error(`Filename "${this.filename}" does not start with prefix "${n}"`);
    return new Be(this.filename.slice(n.length), this.localIdentifier, this.exportIdentifier);
  }
};
var Xe = class {
  constructor(t, r) {
    this.componentId = t;
    this.astLocation = r;
  }
  equals(t) {
    return !(!t || !this.componentId.equals(t.componentId) || this.astLocation !== t.astLocation);
  }
  toString() {
    return [this.componentId.toString(), this.astLocation].join(":");
  }
  static parse(t) {
    return t instanceof this ? t : typeof t == "string" ? this.fromString(t) : this.fromPlainObject(t);
  }
  static fromString(t) {
    if (!t || t.length === 0) {
      console.warn("JsxId.fromString -- input string is empty or undefined");
      return;
    }
    let r = t.lastIndexOf(":");
    if (r == null) {
      console.warn("JsxId.fromString -- cannot find astLocation in serialized value: " + t);
      return;
    }
    let n = t.slice(0, r), i = t.slice(r + 1);
    if (n && i) {
      let l = Be.fromString(n);
      if (!l) {
        console.warn("JsxId.fromString -- cannot parse component ID: " + t);
        return;
      }
      let y = i;
      return new Xe(l, y);
    } else {
      console.warn("JsxId.fromString -- cannot parse serialized value: " + t);
      return;
    }
  }
  static fromPlainObject(t) {
    if (t.componentId && t.astLocation) {
      let r = Be.fromPlainObject(t.componentId);
      if (r)
        return new Xe(r, t.astLocation);
    }
  }
  static compare(t, r) {
    return t.toString().localeCompare(r.toString());
  }
  addFilenamePrefix(t) {
    this.componentId.addFilenamePrefix(t);
  }
};
var Oe = class {
  constructor(t, r, n) {
    this.filename = t;
    this.localIdentifier = r;
    this.exportIdentifier = n;
  }
  equals(t) {
    return this.toString() === t.toString();
  }
  toString() {
    return `${this.filename}:${this.localIdentifier}:${this.exportIdentifier}`;
  }
  static fromString(t) {
    let r = t.split(":");
    if (r.length !== 3)
      throw new Error(`Invalid serialized Ident: ${t}`);
    return new Oe(r[0], r[1], r[2]);
  }
  static fromImport(t, r, n) {
    return Oe.isRelativePath(t) || (t = "!" + t), new Oe(t, r, n);
  }
  static fromPlainObject(t) {
    return new Oe(t.filename || "", t.localIdentifier || "", t.exportIdentifier || "");
  }
  parsedFilename() {
    return Ee.parse(this.filename);
  }
  isIndex() {
    return this.parsedFilename().name === "index";
  }
  static isRelativePath(t) {
    return t.startsWith("./") || t.startsWith("../") || t === ".." || t === ".";
  }
  isAbsolute() {
    let t = this.parsedFilename().dir;
    return !t.startsWith("./") && !t.startsWith("../") && t != ".." && t != ".";
  }
  isFile() {
    return !this.isPackage();
  }
  isPackage() {
    return this.filename.startsWith("!");
  }
  equivalentNames() {
    let t = this.parsedFilename(), r = [new Oe(this.filename, this.localIdentifier, this.exportIdentifier)];
    this.isIndex() && r.push(new Oe(t.dir, this.localIdentifier, this.exportIdentifier)), t.ext && r.push(new Oe(Ee.format(bt(St({}, t), { base: t.name, ext: "" })), this.localIdentifier, this.exportIdentifier));
    for (let n of new Set(r))
      n.exportIdentifier && r.push(new Oe(n.filename, "", n.exportIdentifier)), n.localIdentifier && r.push(new Oe(n.filename, n.localIdentifier, ""));
    return new Set(r.map((n) => n.toString()));
  }
  isGlobal() {
    return this.filename === "" && this.localIdentifier === "";
  }
  isUnnamedDefault() {
    return this.localIdentifier === "" && this.exportIdentifier === "default";
  }
  makeAbsolute(t) {
    if (this.isPackage())
      return this;
    let r = Ee.parse(t).dir, n = new Oe(this.filename, this.localIdentifier, this.exportIdentifier);
    return n.filename = Ee.normalize(Ee.join(r, n.filename)), n;
  }
  makeRelative(t) {
    if (this.isPackage())
      return this;
    let r = new Oe(this.filename, this.localIdentifier, this.exportIdentifier), n = Ee.parse(Ee.relative(Ee.dirname(t), this.filename));
    return !n.dir.startsWith("./") && !n.dir.startsWith("../") && n.dir != ".." && n.dir != "." && (n.dir = n.dir ? "./" + n.dir : "."), r.filename = Ee.format(n), r;
  }
  importName() {
    if (this.filename.startsWith("!"))
      return this.filename.slice(1);
    let t = this.parsedFilename();
    return t.name == "index" ? t.dir : Ee.format(bt(St({}, t), { base: t.name, ext: "" }));
  }
};
var Zc = (e) => {
  let t = e.split("/");
  if (t && t.length > 0) {
    let r = t[t.length - 1];
    return r.toLowerCase().includes("index") && t.length > 1 ? t[t.length - 2] : r.split(".")[0];
  }
  return null;
};
o();
var Ep = Le(Sp());
o();
var Gi = "jsxid";
function yB(e) {
  for (var t = []; e; ) {
    var r = (e.memoizedProps || {})["data-" + Gi], n = (r || "").split("|")[0];
    n && (!t.length || n !== t[t.length - 1]) && t.push(n), e = e._debugOwner;
  }
  return t;
}
function mB(e) {
  let t = Object.keys(e).find((r) => r.startsWith("__reactFiber$") || r.startsWith("__reactInternalInstance$"));
  return t ? e[t] : null;
}
function zi(e) {
  if (e instanceof HTMLElement || e instanceof SVGElement) {
    let t = e.dataset[vp];
    if (!t)
      return null;
    let r = [t], n = mB(e);
    n && r.push(...yB(n)), r.length >= 2 && r[0] === r[1] && r.shift();
    let i = r.map((l) => Xe.fromString(l));
    return i.some((l) => l === void 0) ? null : i;
  }
  return null;
}
var vp = (0, Ep.default)(Gi);
var bp = /* @__PURE__ */ new WeakMap();
var TB = Math.random().toString(36).substring(2, 15);
var SB = 0;
var bB = () => `${TB}-${++SB}`;
var Hi = /* @__PURE__ */ new Map();
var Pp = () => {
  var t;
  Hi.clear();
  let e = {};
  return xp(document.body, e), (t = e.children) != null ? t : [];
};
var xp = (e, t) => {
  let r = zi(e), n = false;
  if (e instanceof HTMLElement || e instanceof SVGElement) {
    if (e.dataset.mmIgnoreTree)
      return;
    e.dataset.mmIgnore && (n = true);
  }
  if (!n && r) {
    let i = e.getBoundingClientRect(), { x: l, y, width: S, height: P } = i;
    if (!isNaN(l) && !isNaN(y) && !isNaN(S) && !isNaN(P)) {
      let L = Object.values(e.attributes).map((te) => ({ name: te.name, value: te.value })), D = { id: Ap(e), jsxIds: r, type: e.nodeName, text: e.textContent || "", attributes: L, rect: i };
      t.children || (t.children = []), t.children.push(D), t = D;
    }
  }
  for (let i of e.children)
    xp(i, t);
};
var gp = (e) => {
  let t = document.elementFromPoint(e.x, e.y);
  for (; t && !t.dataset[vp]; )
    t = t.parentElement;
  return t ? Ap(t) : null;
};
var hp = (e) => {
  var t;
  return (t = Hi.get(e)) != null ? t : null;
};
var Qi = (e, t) => {
  t(e);
  for (let r of e.children)
    Qi(r, t);
};
var Ap = (e) => {
  let t = bp.get(e);
  return t || (t = bB(), bp.set(e, t)), Hi.set(t, e), t;
};
o();
var Op = (e, t) => {
  var S;
  let r = {}, n = window.__REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!n)
    throw new Error("No react devtools hook");
  let i = (S = n.rendererInterfaces) == null ? void 0 : S.entries().next().value[1];
  if (!i)
    throw new Error("No renderer interface");
  let l = Be.fromPlainObject(t);
  if (!l)
    throw new Error(`Invalid componentId object: ${t}`);
  let y = hp(e);
  if (!y)
    throw new Error(`No element found with id ${e}`);
  return Qi(y, (P) => {
    var te, X, ie;
    if (!zi(P))
      return;
    let A = null, L = i.getFiberIDForNative(P, true);
    for (; Number.isInteger(L); ) {
      let fe = i.inspectElement("FAKE-ID", L, null, true).value;
      if (!fe)
        throw new Error(`No inspected component for fiber id ${L}`);
      L = (X = (te = fe.owners) == null ? void 0 : te[0]) == null ? void 0 : X.id;
      let W = Xe.fromString((ie = fe.props.data.jsxids) == null ? void 0 : ie.split("|")[0]);
      if (!W)
        continue;
      if (W.componentId.equals(l)) {
        A = { jsxId: W, inspectedComponent: fe };
        break;
      }
    }
    if (!A) {
      console.error("No match for componentId", l);
      return;
    }
    let D = EB(A.inspectedComponent.props.data);
    D && (r[A.jsxId.toString()] = D);
  }), r;
};
var EB = (e) => e ? Object.entries(e).reduce((t, [r, n]) => r === "jsxids" || r === "data-jsxids" ? t : typeof n == "string" || typeof n == "boolean" || typeof n == "number" ? bt(St({}, t), { [r]: n }) : t, {}) : null;
o();
var Ip = (e) => {
  let t = document.elementFromPoint(e.x, e.y);
  t instanceof HTMLElement && t.click();
};
var _p = (e) => {
  let t = document.elementFromPoint(e.x, e.y);
  t instanceof HTMLElement && t.dataset.mmTutorialClick && t.click();
};
var Dp = (e, t) => {
  let r = t ? document.elementFromPoint(t.x, t.y) : null;
  PB(r).scrollBy(e.x, e.y);
};
var vB = (e) => {
  let t = getComputedStyle(e, null).getPropertyValue("overflow");
  return t.indexOf("scroll") > -1 || t.indexOf("auto") > -1;
};
var PB = (e) => {
  for (; e && e.parentNode; ) {
    if (vB(e))
      return e;
    e = e.parentElement;
  }
  return document.scrollingElement || document.documentElement;
};
var hB = "devigner-";
var AB = "GET_DOM_ELEMENTS_ON_PAGE";
var OB = "GET_DOM_ELEMENT_ID_AT_POINT";
var IB = "GET_REACT_RUNTIME_PROPS";
var _B = "CLICK";
var DB = "TUTORIAL_CLICK";
var NB = "SCROLL";
var Np = "LOCATION_CHANGE";
var CB = "DOM_UPDATED";
var wB = "ESC";
var LB = (e) => hB + e;
var Lp = () => {
  if (window.parent === window)
    throw new Error("DevignerApiServer must be run inside an iframe.");
  let e = new Cp.RPC({ target: window.parent, serviceId: LB(window.name) });
  e.expose(AB, Pp), e.expose(OB, gp), e.expose(IB, (n) => Op(n.elementId, n.componentId)), e.expose(_B, Ip), e.expose(DB, _p), e.expose(NB, (n) => Dp(n.delta, n.atPoint)), new MutationObserver((0, wp.default)(() => {
    e.call(CB, {});
  }, 50)).observe(document.documentElement, { childList: true, subtree: true });
  let r = "";
  setInterval(() => {
    r !== window.location.href && (r = window.location.href, e.call(Np, { location: r }));
  }, 100), window.addEventListener("pagehide", () => {
    e.call(Np, { location: null });
  }), window.addEventListener("keydown", (n) => {
    n.key === "Escape" && e.call(wB, {});
  });
};
o();
var fd = Le(Nr());
o();
var tt = Le(Xp(), 1);
o();
function un(e, t) {
  if (e == null)
    return {};
  var r = {}, n = Object.keys(e), i, l;
  for (l = 0; l < n.length; l++)
    i = n[l], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
  return r;
}
o();
function ct() {
  return ct = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]);
    }
    return e;
  }, ct.apply(this, arguments);
}
o();
function ln(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
o();
o();
function dr(e, t) {
  return dr = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, i) {
    return n.__proto__ = i, n;
  }, dr(e, t);
}
function is(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, dr(e, t);
}
var ad = Le(cs(), 1);
var id = Le(rd(), 1);
function oF(e, t) {
  if (!e) {
    var r = new Error("loadable: " + t);
    throw r.framesToPop = 1, r.name = "Invariant Violation", r;
  }
}
var uF = tt.default.createContext();
var lF = { initialChunks: {} };
var nd = "PENDING";
var cF = "RESOLVED";
var ds = "REJECTED";
function fF(e) {
  return typeof e == "function" ? { requireAsync: e, resolve: function() {
  }, chunkName: function() {
  } } : e;
}
var pF = function(t) {
  var r = function(i) {
    return tt.default.createElement(uF.Consumer, null, function(l) {
      return tt.default.createElement(t, Object.assign({ __chunkExtractor: l }, i));
    });
  };
  return t.displayName && (r.displayName = t.displayName + "WithChunkExtractor"), r;
};
var dF = function(t) {
  return t;
};
function sd(e) {
  var t = e.defaultResolveComponent, r = t === void 0 ? dF : t, n = e.render, i = e.onLoad;
  function l(S, P) {
    P === void 0 && (P = {});
    var A = fF(S), L = {};
    function D(W) {
      return P.cacheKey ? P.cacheKey(W) : A.resolve ? A.resolve(W) : "static";
    }
    function te(W, $, J) {
      var j = P.resolveComponent ? P.resolveComponent(W, $) : r(W);
      if (P.resolveComponent && !(0, ad.isValidElementType)(j))
        throw new Error("resolveComponent returned something that is not a React component!");
      return (0, id.default)(J, j, { preload: true }), j;
    }
    var X = function($) {
      var J = D($), j = L[J];
      return (!j || j.status === ds) && (j = A.requireAsync($), j.status = nd, L[J] = j, j.then(function() {
        j.status = cF;
      }, function(F) {
        console.error("loadable-components: failed to asynchronously load component", { fileName: A.resolve($), chunkName: A.chunkName($), error: F && F.message }), j.status = ds;
      })), j;
    }, ie = function(W) {
      is($, W), $.getDerivedStateFromProps = function(F, V) {
        var se = D(F);
        return ct({}, V, { cacheKey: se, loading: V.loading || V.cacheKey !== se });
      };
      function $(j) {
        var F;
        return F = W.call(this, j) || this, F.state = { result: null, error: null, loading: true, cacheKey: D(j) }, oF(!j.__chunkExtractor || A.requireSync, "SSR requires `@loadable/babel-plugin`, please install it"), j.__chunkExtractor ? P.ssr === false ? ln(F) : (A.requireAsync(j).catch(function() {
          return null;
        }), F.loadSync(), j.__chunkExtractor.addChunk(A.chunkName(j)), ln(F)) : (P.ssr !== false && (A.isReady && A.isReady(j) || A.chunkName && lF.initialChunks[A.chunkName(j)]) && F.loadSync(), F);
      }
      var J = $.prototype;
      return J.componentDidMount = function() {
        this.mounted = true;
        var F = this.getCache();
        F && F.status === ds && this.setCache(), this.state.loading && this.loadAsync();
      }, J.componentDidUpdate = function(F, V) {
        V.cacheKey !== this.state.cacheKey && this.loadAsync();
      }, J.componentWillUnmount = function() {
        this.mounted = false;
      }, J.safeSetState = function(F, V) {
        this.mounted && this.setState(F, V);
      }, J.getCacheKey = function() {
        return D(this.props);
      }, J.getCache = function() {
        return L[this.getCacheKey()];
      }, J.setCache = function(F) {
        F === void 0 && (F = void 0), L[this.getCacheKey()] = F;
      }, J.triggerOnLoad = function() {
        var F = this;
        i && setTimeout(function() {
          i(F.state.result, F.props);
        });
      }, J.loadSync = function() {
        if (!!this.state.loading)
          try {
            var F = A.requireSync(this.props), V = te(F, this.props, fe);
            this.state.result = V, this.state.loading = false;
          } catch (se) {
            console.error("loadable-components: failed to synchronously load component, which expected to be available", { fileName: A.resolve(this.props), chunkName: A.chunkName(this.props), error: se && se.message }), this.state.error = se;
          }
      }, J.loadAsync = function() {
        var F = this, V = this.resolveAsync();
        return V.then(function(se) {
          var _e = te(se, F.props, fe);
          F.safeSetState({ result: _e, loading: false }, function() {
            return F.triggerOnLoad();
          });
        }).catch(function(se) {
          return F.safeSetState({ error: se, loading: false });
        }), V;
      }, J.resolveAsync = function() {
        var F = this.props, V = F.__chunkExtractor, se = F.forwardedRef, _e = un(F, ["__chunkExtractor", "forwardedRef"]);
        return X(_e);
      }, J.render = function() {
        var F = this.props, V = F.forwardedRef, se = F.fallback, _e = F.__chunkExtractor, We = un(F, ["forwardedRef", "fallback", "__chunkExtractor"]), rt = this.state, ft = rt.error, Dt = rt.loading, Fe = rt.result;
        if (P.suspense) {
          var ke = this.getCache() || this.loadAsync();
          if (ke.status === nd)
            throw this.loadAsync();
        }
        if (ft)
          throw ft;
        var G = se || P.fallback || null;
        return Dt ? G : n({ fallback: G, result: Fe, options: P, props: ct({}, We, { ref: V }) });
      }, $;
    }(tt.default.Component), Re = pF(ie), fe = tt.default.forwardRef(function(W, $) {
      return tt.default.createElement(Re, Object.assign({ forwardedRef: $ }, W));
    });
    return fe.displayName = "Loadable", fe.preload = function(W) {
      fe.load(W);
    }, fe.load = function(W) {
      return X(W);
    }, fe;
  }
  function y(S, P) {
    return l(S, ct({}, P, { suspense: true }));
  }
  return { loadable: l, lazy: y };
}
function yF(e) {
  return e.__esModule ? e.default : e.default || e;
}
var od = sd({ defaultResolveComponent: yF, render: function(t) {
  var r = t.result, n = t.props;
  return tt.default.createElement(r, n);
} });
var mF = od.loadable;
var TF = od.lazy;
var ud = sd({ onLoad: function(t, r) {
  t && r.forwardedRef && (typeof r.forwardedRef == "function" ? r.forwardedRef(t) : r.forwardedRef.current = t);
}, render: function(t) {
  var r = t.result, n = t.props;
  return n.children ? n.children(r) : null;
} });
var SF = ud.loadable;
var bF = ud.lazy;
var ld = mF;
ld.lib = SF;
var EF = TF;
EF.lib = bF;
var cd = ld;
function pd({ getPreview: e, hostDir: t, children: r }) {
  let i = new URLSearchParams(window.location.search).get("preview");
  if (i) {
    let l = cd(() => Mn(this, null, function* () {
      try {
        let y = fd.default.relative("/" + t, "/" + i);
        return y.startsWith(".") || (y = "./" + y), y = y.replace(/\.[jt]sx?$/, ""), yield e(y);
      } catch (y) {
        return console.error(y), () => (0, import_jsx_runtime.jsx)("div", { children: "Loading component..." });
      }
    }));
    return (0, import_jsx_runtime.jsx)(l, {});
  }
  return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: r });
}
typeof window != "undefined" && (window.parent !== window ? (console.debug("MightyMeld devigner starting"), Lp()) : console.debug("MightyMeld devigner not starting; not in iframe"));
export {
  pd as Ghostbox
};
/*! Bundled license information:

@mightymeld/runtime/mightymeld/mjs/index.js:
  (**
   * @license React
   * react.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
  (**
   * @license React
   * react.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
  (** @license React v16.13.1
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
  (** @license React v16.13.1
   * react-is.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=@mightymeld_runtime_mightymeld.js.map
